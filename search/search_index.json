{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tanjun","text":"<p>A flexible command framework designed to extend Hikari.</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install Tanjun from PyPI using the following command in any Python 3.9 or above environment.</p> <pre><code>python -m pip install -U hikari-tanjun\n</code></pre>"},{"location":"#quick-usage","title":"Quick Usage","text":"<p>For usage see the documentation, usage guide, and tutorials and articles.</p>"},{"location":"#community-resources","title":"Community Resources","text":"<ul> <li>Tan-chan is a general utility library for   Tanjun. It includes a command annotation parsing extension which parses docstrings to   get the descriptions of slash commands and their options.</li> <li>Redis based implementations of the async cache dependency can be found in   hikari-sake &gt;=v1.0.1a1 (exposed by   sake.redis.ResourceClient.add_to_tanjun).</li> </ul>"},{"location":"#support","title":"Support","text":"<p>Hikari's support guild provides for support for Tanjun.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Before contributing you should read through the contributing guidelines and the code of conduct.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#2130-2023-04-10","title":"2.13.0 - 2023-04-10","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Support for sending stickers to just MessageContext.respond.</li> <li>Support for localising slash command option choice names.</li> <li>Support for passing a sequence of hikari.CommandChoices   to <code>choices</code> when adding an option to a slash command.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Bumped the minimum Hikari version to <code>2.0.0.dev118</code>.</li> </ul>"},{"location":"changelog/#2120-2023-03-12","title":"2.12.0 - 2023-03-12","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Support for declaring the options for a command using   <code>**kwargs: typing.Unpack[TypedDict]</code> when using the annotations parsing impl in   tanjun.annotations.</li> <li>tanjun.abc.NO_PASS for marking command options as being not passed when they   weren't provided.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Marked deprecated classes, functions and overloads as deprecated using <code>typing.deprecated</code>.   Deprecated class aliases are now separate classes to allow warning on init.</li> </ul>"},{"location":"changelog/#deprecated","title":"Deprecated","text":"<ul> <li>Renamed tanjun.parsing.UNDEFINED_DEFAULT and   tanjun.commands.slash.UNDEFINED_DEFAULT to tanjun.abc.NO_DEFAULT.</li> <li>tanjun.parsing.UndefinedT.</li> </ul>"},{"location":"changelog/#2114-2023-02-08","title":"2.11.4 - 2023-02-08","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li><code>Context.create_initial_response</code> (and by extension <code>Context.respond</code> for the initial   response specifically) will no-longer try to pass the attachment, component or embed as   the actual message content when passed for the <code>content</code> argument for REST-based   interaction commands.</li> <li>Removed use of and references to <code>hikari.RateLimitedError</code> to fix compatibility with   <code>hikari&gt;=2.0.0.dev116</code>.</li> </ul>"},{"location":"changelog/#2113-2023-02-01","title":"2.11.3 - 2023-02-01","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>tanjun.MenuHooks is now exported top-level.</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Improved the typing of callbacks which support DI to enforce the type of any positionally   passed arguments with a static type.</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>tanjun.annotations.Converted now properly overrides the actual type annotation for   slash commands.</li> <li>The <code>add_{}_option</code> and <code>with_{}_option</code> methods for the standard slash command impl   will no-longer mishandle iterable but non-sequence types like enum.Enum as if   they were a sequence of converters when they are passed as the value for <code>converters</code>.</li> </ul>"},{"location":"changelog/#2112-2023-01-23","title":"2.11.2 - 2023-01-23","text":""},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>tanjun.clients.Client.from_gateway_bot can now also take cache-less <code>ShardAware</code> bots.</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>tanjun.clients.Client.set_human_only no longer registers the internal check multiple   times when called with True multiple times.</li> </ul>"},{"location":"changelog/#2111-2023-01-07","title":"2.11.1 - 2023-01-07","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Support for specifying Guild Forum channels for the constraints of a channel command option.</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Bumped the minimum Hikari version to <code>2.0.0.dev115</code>.</li> </ul>"},{"location":"changelog/#2110-2022-12-31","title":"2.11.0 - 2022-12-31","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Support for passing relative timedeltas to tanjun.conversion.from_datetime.</li> <li>Support for passing multiple callbacks to <code>add_check</code>, <code>add_client_callback</code>, <code>add_listener</code>,   <code>add_on_close</code> and <code>add_on_open</code>.</li> <li>Support for creating modals in response to Slash and Context menu commands.</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Bumped the minimum Hikari version to <code>hikari~=2.0.0.dev113</code>.</li> </ul>"},{"location":"changelog/#2101a1-2022-12-02","title":"2.10.1a1 - 2022-12-02","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Slash command specific tanjun.annotations.InteractionChannel and   tanjun.annotations.InteractionMember types for annotation parsing.</li> <li>Exposed non-decorator version of with_annotated_args   at tanjun.annotations.parse_annotated_args.   This comes with the added functionality of letting you directly pass slash command option   descriptions to the callback via the <code>descriptions</code> argument (instead of putting strings in   annotations).</li> <li>Add cache component checks to the startup logging for converter client config compatibility.</li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>tanjun.annotations.with_annotated_args will now raise if a slash command-specific type is   used for a required message command parameter.</li> <li>Converter startup client config logs now only use info level when REST fallback is possible.</li> <li><code>allowed_types=[]</code> is now treated as allowing no channel types (rather than any) when passed to   tanjun.conversion.ToChannel.__init__.</li> <li>tanjun.annotations.Choices now raises a TypeError instead of ValueError if an enum   class which isn't a subclass of int, float or str is passed to it as a type variable   (e.g <code>Choices[Enum]</code>).</li> <li>tanjun.annotations.with_annotated_args now raises TypeError instead of ValueError if a   value of the wrong type is provided as any of the choices, min value or max value.</li> <li>The descriptors generated by tanjun.as_unloader and tanjun.as_loader now raise a   TypeError if the wrong client implementation is passed to them when <code>standard_impl</code> is True.</li> <li>Component.add_command,   Component.remove_command  and   Component.with_command now raise TypeError   instead of ValueError if the object isn't a message, menu or slash command.</li> <li>The standard converters in tanjun.conversion no-longer allow float to be passed.</li> <li>to_invite, ToInvite.__call__,   to_invite_with_metadata and   ToInviteWithMetadata.__call__ no-longer allows   int nor float to be passed.</li> <li>TimeSchedule.__init__ and tanjun.as_time_schedule now   raise a TypeError instead of ValueError when a float is passed in or for any of its arguments.</li> <li>The arguments for tanjun.clients.on_parser_error and   Client.set_human_only.</li> <li>The signatures of several internally used but publicly exported functions have been fixed to ensure   they better follow the library's rules for positional and keyword arguments.   For more information see https://github.com/FasterSpeeding/Tanjun/commit/a06b43d6bedb87c1c8e19eef3745127b40479a24.</li> </ul>"},{"location":"changelog/#deprecated_1","title":"Deprecated","text":"<ul> <li><code>BaseConverter.async_caches</code>, <code>BaseConverter.cache_components</code> and <code>BaseConverter.intents</code>.</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>The hot reloader will no-longer miss command changes made while it's in the   middle of redeclaring commands.</li> <li>Component.remove_command now supports menu commands.</li> </ul>"},{"location":"changelog/#2100a1-2022-11-24","title":"2.10.0a1 - 2022-11-24","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Support for message commands to tanjun.annotations.TheseChannels.</li> <li><code>allowed_types</code> field to tanjun.conversion.ToChannel to allow narrowing the allowed channel   types for a message command option.</li> <li>Support for toggleable case-insensitive message command name handling.</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>The hot reloader will no-longer retry to reload a module being targeted through a system path   (pathlib.Path) after one of its unloaders raises or finding out it has no unloaders.</li> <li>Allow passing hikari.GuildThreadChannel derived types   (+ hikari.InteractionChannel) to   TheseChannels, and to the <code>types</code> field of   with_channel_slash_option and   SlashCommand.add_channel_option.</li> <li>The spacing in <code>triggering_name</code> is now properly normalised for message commands in groups to ensure   only 1 space. This also fixes cases where names were being smashed together without any spaces.</li> <li>The hot reloader trying to declare commands multiple times.</li> <li>Actually set the attached component for commands within slash-command groups.</li> <li>Process converters attached to commands within slash-command groups to log for client   misconfiguration.</li> </ul>"},{"location":"changelog/#290a1-2022-11-08","title":"2.9.0a1 - 2022-11-08","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Added <code>bot_managed</code> argument to Client.from_gateway_bot   for automatically starting the client when the linked REST bot starts. This defaults to False   for backwards compatibility.</li> <li>Thread support (including a <code>SfCache[hikari.GuildThreadChannel]</code> concept).</li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Bumped the minimum Hikari version to <code>2.0.0.dev112</code>.</li> <li><code>SfCache[hikari.GuildChannel]</code> is now <code>SfCache[hikari.PermissibleGuildChannel]</code>.</li> <li>Allow None to be passed for <code>attachment</code> and <code>attachments</code> to edit response methods.</li> </ul>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>The ToChannel/to_channel   converter now correctly uses the registered async channel cache if set.</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>The project metadata dunder attributes from tanjun.   importlib.metadata should be used to get this metadata instead.</li> <li><code>replace_attachments</code> argument from the relevant context edit response methods.   For more information see https://github.com/hikari-py/hikari/releases/tag/2.0.0.dev112.</li> </ul>"},{"location":"changelog/#281a1-2022-10-24","title":"2.8.1a1 - 2022-10-24","text":""},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>No longer ignore <code>delete_after</code> for ephemeral responses.</li> </ul>"},{"location":"changelog/#280a1-2022-10-16","title":"2.8.0a1 - 2022-10-16","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>Support for specifying <code>min_length</code> and <code>max_length</code> for slash command string options.</li> <li>Support for specifying <code>min_length</code> and <code>max_length</code> for message command parsing options with either   no converters or converters which result in a collections.abc.Sized compatible value.</li> <li>Support for specifying the length of a string argument in annotation command declaration through   tanjun.annotations.Length.</li> <li>AutocompleteContext.triggering_name which acts   like Context.triggering_name.</li> <li>Support for localising check responses for application command contexts, and slash command +   context menu declarations (names and descriptions).   More information on how this works can be found in localisation.</li> </ul>"},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>Bumped the minimum Hikari version to <code>2.0.0.dev111</code>.</li> <li>Bumped the minimum Alluka version to <code>0.1.2</code>.</li> <li>tanjun.dependencies.HotReloader.add_to_client now returns None.</li> </ul>"},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>Make tanjun.commands.slash.SlashCommandGroup.as_sub_command's typing more   flexible to allow decorating other command objects.</li> <li><code>tanjun.context.slash.SlashContext.triggering_name</code> now returns the full triggering command name   for sub-commands instead of just the top level command's name.</li> <li>Optimise tanjun.checks.OwnPermissionCheck to use <code>context.app_permissions</code> instead of   calculating the bot's permissions for context menu command calls.</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>The generic value field from <code>BaseConverter</code>.</li> </ul>"},{"location":"changelog/#270a1-2022-09-24","title":"2.7.0a1 - 2022-09-24","text":""},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>Support for marking positional message arguments as optional when using annotation parsing.</li> <li>tanjun.annotations.Default for setting the default for an argument while leaving the actual   parameter required.</li> </ul>"},{"location":"changelog/#changed_10","title":"Changed","text":"<ul> <li>tanjun.annotations.Flag will no longer unset any previously set aliases.</li> </ul>"},{"location":"changelog/#deprecated_2","title":"Deprecated","text":"<ul> <li>tanjun.annotations.Flag.default and the <code>default</code> argument for   tanjun.annotations.Flag.__init__[].   tanjun.annotations.Default should be used instead.</li> </ul>"},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>Don't ignore parameter annotations when the top-level type-hint is a union.</li> </ul>"},{"location":"changelog/#263a1-2022-09-17","title":"2.6.3a1 - 2022-09-17","text":""},{"location":"changelog/#added_10","title":"Added","text":"<ul> <li><code>follow_wrapped</code> parameter to <code>Component.with_command</code>.</li> <li>MessageCommandGroup.as_sub_command,   MessageCommandGroup.as_sub_group,   SlashCommandGroup.as_sub_command and   SlashCommandGroup.make_sub_group   shorthand methods for creating sub-command and sub-command-groups directly on groups.</li> <li>Client.set_interaction_accepts for configuring   which interaction types a client should listen for and execute.</li> </ul>"},{"location":"changelog/#changed_11","title":"Changed","text":"<ul> <li>Client.set_message_accepts now   raises a RuntimeError if called while the client is running to ensure   consistent behaviour.</li> </ul>"},{"location":"changelog/#removed_2","title":"Removed","text":"<ul> <li>The broken <code>add_injector</code> argument from tanjun.clients.Client.add_component.</li> </ul>"},{"location":"changelog/#262a1-2022-09-05","title":"2.6.2a1 - 2022-09-05","text":""},{"location":"changelog/#added_11","title":"Added","text":"<ul> <li>tanjun.abc.Client.load_directory and tanjun.abc.Client.load_directory_async for loading all   the modules in a directory.</li> <li><code>path</code> properties to tanjun.errors.FailedModuleLoad and tanjun.errors.FailedModuleUnload   to indicate which module failed to load/unload.</li> <li>tanjun.errors.FailedModuleImport specialisation of tanjun.errors.FailedModuleLoad for   differentiating between the two cases when necessary.</li> </ul>"},{"location":"changelog/#261a1-2022-08-29","title":"2.6.1a1 - 2022-08-29","text":""},{"location":"changelog/#added_12","title":"Added","text":"<ul> <li><code>follow_wrapped</code> argument to the with check and with limiter decorators to allow for applying the   limiter/check to all the commands in a decorator chain (in a similar fashion to how   <code>with_parsed_annotations</code> behaves.</li> <li>Hot module reloading as a bot development aid.</li> </ul>"},{"location":"changelog/#changed_12","title":"Changed","text":"<ul> <li><code>tanjun.ModuleMissingUnloaders</code> is now raised by <code>client.unload_modules</code>, <code>client.reload_modules</code> and   <code>client.reload_modules_async</code> when the stored module has no unloaders instead of   <code>tanjun.ModuleMissingLoaders</code>.</li> <li>hikari.api.special_endpoints.CommandBuilder can also be included in the list   passed to <code>Client.declare_application_commands</code>'s first arg now.</li> </ul>"},{"location":"changelog/#changed_13","title":"Changed","text":"<ul> <li>Moved permissions functions to tanjun.permissions while keeping deprecated aliases in the now   deprecated module <code>tanjun.utilities</code>.</li> </ul>"},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>Inherit the global states for <code>default_member_permissions</code> and <code>is_dm_enabled</code>   in <code>declare_application_command</code>.</li> </ul>"},{"location":"changelog/#254a1-2022-08-11","title":"2.5.4a1 - 2022-08-11","text":""},{"location":"changelog/#added_13","title":"Added","text":"<ul> <li>V2 application permissions and <code>dms_enabled</code> config to slash and menu commands.</li> <li>Signature name validation for command options.</li> <li><code>wrapped_command</code> properties to <code>tanjun.SlashCommand</code>, <code>tanjun.MessageCommand</code> and <code>tanjun.MenuCommand</code>   for interospecting wrapped commands.</li> <li><code>key</code> argument to the <code>add_{}_slash_option</code> methods and <code>with_{}_slash_option</code> functions to allow the   argument's name in the callback's signature to be different from the option's declared name.</li> <li>Signature type-hint based command option declaration for both message and slash commands. More   information about this can be found in tanjun.annotations.</li> <li>Allow multiple events to be passed to <code>Client.with_listener</code>/<code>Component.with_listener</code> in one call.</li> </ul>"},{"location":"changelog/#changed_14","title":"Changed","text":"<ul> <li>If no events are passed to <code>Client.with_listener</code>/<code>Component.with_listener</code> it will now try to infer   the event type(s) from the callback's type-hints.</li> </ul>"},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>Slash command parent command tracking.</li> </ul>"},{"location":"changelog/#253a1-2022-07-04","title":"2.5.3a1 - 2022-07-04","text":""},{"location":"changelog/#added_14","title":"Added","text":"<ul> <li>Support for sending attachments with <code>Context.respond</code>, <code>CommandError</code> and   <code>SlashContext.create_initial_response</code>.</li> </ul>"},{"location":"changelog/#changed_15","title":"Changed","text":"<ul> <li>Allow <code>as_loader</code> and <code>as_unloader</code> to be used as decorators while passing keyword-arguments.</li> <li>Bumped minimum Hikari version to <code>2.0.0.dev109</code>.</li> </ul>"},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>Allow for implicitly passing an embed or component as <code>content</code> when creating the initial   response for an application command as a REST server to match the documented behaviour.</li> <li>The \"all_checks\" check failing on calls with DI.</li> </ul>"},{"location":"changelog/#252a1-2022-05-16","title":"2.5.2a1 - 2022-05-16","text":""},{"location":"changelog/#added_15","title":"Added","text":"<ul> <li><code>error</code> option to the standard checks and limiters to allow setting a callback which generates   a custom error.</li> <li><code>AbstractSchedule.force_stop</code> which immediately stops the tasks without waiting and is sync.</li> </ul>"},{"location":"changelog/#changed_16","title":"Changed","text":"<ul> <li>The cooldown limiter now uses Discord's timestamp format in its default error messages.</li> <li><code>AbstractCooldownManager.check_cooldown</code> now returns a <code>datetime.datetime</code> instead of a  <code>float</code>.</li> <li><code>halt_execution</code> now takes priority over <code>error_message</code> when configuring checks.</li> <li>The REST strategies for interaction handling now cancel the response future if the execution task   ends before it's set to avoid dangling waiting tasks.</li> <li>Command interaction handling now cancels auto-deferral if the command execution task finishes before   a response is given.</li> <li><code>AbstractSchedule.stop</code> is now async.</li> </ul>"},{"location":"changelog/#fixed_11","title":"Fixed","text":"<ul> <li>Some edge cases where closing schedule(s) may lead to futures being erroneously cancelled.</li> </ul>"},{"location":"changelog/#251a1-2022-05-02","title":"2.5.1a1 - 2022-05-02","text":""},{"location":"changelog/#added_16","title":"Added","text":"<ul> <li>A <code>send</code> method to <code>CommandError</code> which can be overridden to customise its response behaviour.</li> <li>Support for other create message arguments to <code>CommandError</code>.</li> </ul>"},{"location":"changelog/#changed_17","title":"Changed","text":"<ul> <li>Renamed <code>CommandError.message</code> to <code>.content</code>.</li> </ul>"},{"location":"changelog/#fixed_12","title":"Fixed","text":"<ul> <li>Allowed a type of <code>bool</code> (not a literal) to be passed to ensure_result typing wise.</li> <li>Some edge cases in the weekly schedule increment handling logic.</li> <li>Long running <code>delete_after</code> and command execution tasks will no-longer be cancelled by GC.</li> </ul>"},{"location":"changelog/#removed_3","title":"Removed","text":"<ul> <li><code>default_permission</code> options for slash commands as command permissions V2 broke and deprecated this.</li> <li><code>AutocompleteOption</code> as a lot of the promises this makes aren't realistic.   <code>AutocompleteContext.options</code> and <code>AutocompleteContext.focused</code> now use   <code>hikari.AutocompleteInteractionOption</code>.</li> </ul>"},{"location":"changelog/#250a1-2022-04-11","title":"2.5.0a1 - 2022-04-11","text":""},{"location":"changelog/#added_17","title":"Added","text":"<ul> <li>Time based async scheduler.</li> </ul>"},{"location":"changelog/#changed_18","title":"Changed","text":"<ul> <li>Bumped minimum hikari version to 2.0.0.dev108.</li> <li>Use <code>None</code> as the default for <code>max_value</code> and <code>min_value</code> in <code>parsing.py</code>.</li> <li>The interval schedule no-longer calls its main callback when it's started.</li> </ul>"},{"location":"changelog/#fixed_13","title":"Fixed","text":"<ul> <li>The interval schedule now explicitly prints tracebacks instead of leaving them to asyncio's   handler; this avoids relying on Asyncio detail which would wait until the Event is gc'ed to   print the traceback.</li> </ul>"},{"location":"changelog/#removed_4","title":"Removed","text":"<ul> <li><code>AbstractSchedule.iteration_count</code> (note, this property still exists on <code>IntervalSchedule</code>).</li> </ul>"},{"location":"changelog/#243a1-2022-03-12","title":"2.4.3a1 - 2022-03-12","text":""},{"location":"changelog/#added_18","title":"Added","text":"<ul> <li>Slash command \"attachment\" options.</li> </ul>"},{"location":"changelog/#242a1-2022-03-04","title":"2.4.2a1 - 2022-03-04","text":""},{"location":"changelog/#fixed_14","title":"Fixed","text":"<ul> <li>Add weakref slot to BaseConverter to improve standard converter compatibility with Alluka.</li> <li>Type compatibility with InteractionMessageBuilder when making the initial response as a REST bot.</li> <li>No longer duplicate embeds on slash create initial response for REST bots.</li> <li><code>has_responded</code> is now only set to <code>True</code> for slash command contexts after the   <code>create_initial_response</code> passes, avoiding issues where error logic calling <code>ctx.respond</code> after   a call to <code>create_initial_response</code> failed would try to create a followup and 404.</li> <li>Further resolve Paths in module loading logic:<ul> <li>User relative paths (<code>~</code>) can now be passed.</li> <li>It now normalises path (so separators), avoiding the same path but with different separators being registered multiple times.</li> <li>It now normalises symlinks, avoiding the same module being registered multiple times through different symlinks.</li> </ul> </li> </ul>"},{"location":"changelog/#241a1-2022-02-25","title":"2.4.1a1 - 2022-02-25","text":""},{"location":"changelog/#added_19","title":"Added","text":"<ul> <li>Alluka's dependency injection interface(s) have been upgraded to the standard Client interface   and Context interfaces.</li> <li>Standard message converter.</li> </ul>"},{"location":"changelog/#changed_19","title":"Changed","text":"<ul> <li><code>Coroutine</code> is now used instead of <code>Awaitable</code> for callback signature return types to account   for refactors made to DI logic in Alluka.</li> <li>The dependency injection implementation has been moved to https://github.com/FasterSpeeding/Alluka   and any new DI features may be indicated there rather than on Tanjun's (Note, DI is still supported)   changelog.</li> <li>Callbacks with invalid dependency injection declarations (are declaring a positional-only argument   as needing DI) now won't error until they're called with DI.</li> </ul>"},{"location":"changelog/#fixed_15","title":"Fixed","text":"<ul> <li>Duplication detection while checking for commands with overlapping names on declare.</li> <li>Relaxed menu command name validation to allow special characters and mixed cases.</li> </ul>"},{"location":"changelog/#removed_5","title":"Removed","text":"<ul> <li><code>tanjun.injecting.TypeDescriptor</code> and <code>tanjun.injecting.CallbackDescriptor</code> as these couldn't be   kept through the Alluka refactor.</li> <li><code>needs_injection</code> attributes.</li> </ul>"},{"location":"changelog/#deprecated_3","title":"Deprecated","text":"<ul> <li><code>tanjun.injecting</code> now only consists of deprecated aliases to Alluka types, with the only   <code>tanjun.inject</code> and <code>tanjun.injected</code> being left as not deprecated for the sake of ease of use.</li> </ul>"},{"location":"changelog/#240a1-2022-02-11","title":"2.4.0a1 - 2022-02-11","text":""},{"location":"changelog/#added_20","title":"Added","text":"<ul> <li><code>ephemeral</code> keyword-argument to <code>SlashContext</code>'s <code>create_initial_response</code>, <code>create_follow_up</code>   and <code>defer</code> methods as a shorthand for including <code>1 &lt;&lt; 6</code> in the passed flags.</li> <li>Context menu command support.</li> <li>Slash command autocomplete support.</li> <li><code>shard</code> is now a property on all contexts.</li> </ul>"},{"location":"changelog/#changed_20","title":"Changed","text":"<ul> <li><code>ShlexParser</code> no-longer treats <code>'</code> as a quote.</li> <li>Command objects can now be passed directly to <code>SlashCommand.__init__</code> and <code>MessageCommand.__init__</code>.</li> <li>The search snowflake conversion functions now return lists of snowflakes instead of iterators.</li> <li><code>tanjun.components</code> has been split into a directory of the same name with the structure   <code>tanjun.components.slash</code>, <code>tanjun.components.message</code>, <code>tanjun.components.base</code> and   <code>tanjun.components.menu</code>.</li> <li><code>tanjun.commands</code> has been split into a directory of the same name with the structure   <code>tanjun.commands.slash</code>, <code>tanjun.commands.message</code>, <code>tanjun.commands.base</code> and <code>tanjun.commands.menu</code>.</li> <li>Bumped the minimum hikari version to <code>hikari~=2.0.0.dev106</code>.</li> </ul>"},{"location":"changelog/#fixed_16","title":"Fixed","text":"<ul> <li>False-positive cache warnings from the standard converters.</li> <li>Mishandled edge cases for to_color.</li> <li>Mishandling of greedy arguments as reported by #200.</li> </ul>"},{"location":"changelog/#231a1-2022-01-27","title":"2.3.1a1 - 2022-01-27","text":""},{"location":"changelog/#added_21","title":"Added","text":"<ul> <li><code>SlashContext.boolean</code>, <code>SlashContext.float</code>, <code>SlashContext.integer</code>, <code>SlashContext.snowflake</code>   and <code>SlashContext.string</code> methods as short hands for asserting the option type and ensuring type   safety.</li> <li>A <code>MessageParser</code> standard abc.</li> <li><code>Client.set_metadata</code>, <code>Component.set_metadata</code> and <code>ExecutableCommand.set_metadata</code> fluent   methods to allow for chaining metadata setting.</li> <li>Complementary <code>Client.load_modules_async</code> and <code>Client.reload_modules_async</code> methods which execute   blocking file access operations in asyncio's threadpool executor.</li> <li>The module load, unload and reload methods now raise <code>FailedModuleLoad</code> and <code>FailedModuleUnload</code>   to relay errors raised by the target module or its (un)loaders.</li> <li><code>max_value</code> and <code>min_value</code> options for message command option parser options and arguments.</li> </ul>"},{"location":"changelog/#changed_21","title":"Changed","text":"<ul> <li><code>SlashContext.value</code> now returns <code>hikari.Snowflake</code> for object IDs.</li> <li><code>reload_modules</code> will now try to rollback a module if it failed to load before raising   and avoid trying to reload a module all together if no loaders or unloaders are found.</li> </ul>"},{"location":"changelog/#fixed_17","title":"Fixed","text":"<ul> <li><code>Context.get_channel</code> no longer raises an assertion error if the cache returns <code>None</code>.</li> <li>Schedules are now stopped if they are removed from a component while active.</li> <li>Schedules will no-longer raise a RuntimeError while closing a component if they were stopped before   before hand.</li> </ul>"},{"location":"changelog/#230a1-2022-01-13","title":"2.3.0a1 - 2022-01-13","text":""},{"location":"changelog/#added_22","title":"Added","text":"<ul> <li>Scheduled callback interface and interval implementation to the standard component implementation.</li> <li><code>always_defer</code> option to slash commands (not including groups).</li> <li><code>tanjun.MessageCommand</code> is now callable like <code>tanjun.SlashCommand</code>.</li> <li><code>MessageContext.respond</code> is now typed as allowing <code>bool</code> for the <code>reply</code> argument.</li> <li><code>min_value</code> and <code>max_value</code> option for int and float slash command options.</li> </ul>"},{"location":"changelog/#changed_22","title":"Changed","text":"<ul> <li>Bumped the minimum hikari version to hikari~=2.0.0.dev105.</li> <li><code>delete_after</code> is now ignored for ephemeral responses instead of leading to a 404.</li> <li>Renamed the standard conversion classes to fit the naming convention <code>To{Type}</code> (while leaving the   old names in as deprecated aliases) + added them to doc coverage/<code>conversion.__all__</code> by their new   names.</li> </ul>"},{"location":"changelog/#fixed_18","title":"Fixed","text":"<ul> <li>The client level ephemeral default is now respected for REST-based slash command execution.</li> <li>The client now waits until a component has been closed before \"unbinding\" it when the component is   removed from an active client.   This should fix previous behaviour where trying to remove a component from an active client would   lead to an error being raised.</li> </ul>"},{"location":"changelog/#removed_6","title":"Removed","text":"<ul> <li>Redundant checks, hooks and metadata keyword-arguments from the standard <code>MessageCommand</code>,   <code>MessageCommandGroup</code>, <code>SlashCommandGroup</code> and <code>SlashCommand</code> implementations' <code>__init__</code>s;   these should be set using methods/decorators.</li> <li>Redundant hook and check keyword-arguments from the standard <code>Client</code> impl; these should be set using   methods.</li> <li>The use of star imports in <code>tanjun.__init__</code> and <code>tanjun.dependencies.__init__</code> meaning that now only   the documented types and attributes for these modules (whatever's in the <code>__all__</code>) may be accessed   directly on them now.</li> <li><code>tanjun.MessageContext</code>, <code>tanjun.SlashContext</code> and <code>tanjun.Context</code> are no-longer exported on the top   level as in most cases their abc equivalent should be used.</li> </ul>"},{"location":"changelog/#223a1-2022-01-06","title":"2.2.3a1 - 2022-01-06","text":""},{"location":"changelog/#added_23","title":"Added","text":"<ul> <li>The interface for a generic (type-based) asynchronous cache dependency.</li> </ul> <p>While this doesn't introduce any new implementation(s), this interface has been integrated into   Tanjun (based on Hikari types) in places which are currently making cache/REST calls and can be used to   better integrate 3rd-party caches with Tanjun.</p> <p>Redis based implementations of this for the types found in Hikari's gateway cache interface can be found   in hikari-sake &gt;=v1.0.1a1 (exposed by   <code>RedisResource.add_to_tanjun</code>).</p>"},{"location":"changelog/#removed_7","title":"Removed","text":"<ul> <li><code>BaseConverter.convert</code> in-favour of having each standard converter directly implement <code>__call__</code>.</li> <li><code>tanjun.conversion.InjectableConverter</code>.</li> <li><code>InjectionContext.get_type_special_case</code> in favour of a <code>get_type_dependency</code> method which tries the   context's client before returning the special case if registered.</li> </ul>"},{"location":"changelog/#222a1-2021-12-26","title":"2.2.2a1 - 2021-12-26","text":""},{"location":"changelog/#added_24","title":"Added","text":"<ul> <li>Type based dependency injection now has ergonomic Union support.   This means that for <code>inject(type=Union[A, B, C])</code>/<code>inject(type=A | B | C)</code> the dependency injector will   try to find registered type injectors for <code>A</code>, <code>B</code> then <code>C</code> after trying to find a dependency injector   for the literal Union.</li> <li>Type based dependency injection now has support for defaults through unions with <code>None</code> and <code>Optional</code>.   This means that, for <code>inject(type=Union[A, B, None])</code>/<code>inject(type=A | B | None)</code> and   <code>inject(type=Optional[A])</code>, if no registered implementations are found for the relevant types then <code>None</code>   will be injected for the relevant argument.</li> </ul>"},{"location":"changelog/#changed_23","title":"Changed","text":"<ul> <li>Message command parser arguments are now passed by keyword instead of positionally.</li> <li>Cooldown checks can now run without a present AbstractOwners implementation.</li> </ul>"},{"location":"changelog/#fixed_19","title":"Fixed","text":"<ul> <li>The cooldown manager now increments the internal counter after checking for cooldown rather than before.   The old behaviour resulted in the last valid call to a bucket being ratelimited therefore essentially making   the real-world limit <code>limit-1</code>.</li> </ul>"},{"location":"changelog/#221a1-2021-11-30","title":"2.2.1a1 - 2021-11-30","text":""},{"location":"changelog/#added_25","title":"Added","text":"<ul> <li>Concurrency limiter dependency (in a similar style to cooldowns).</li> <li><code>disable_bucket</code> method to the in-memory concurrency and cooldown manager impls.</li> <li><code>any_checks</code>/<code>with_any_checks</code> and <code>all_checks</code>/<code>with_all_checks</code> functions for more garnular check   flow control. <code>any_checks</code> passes if any of the provided checks pass and <code>all_checks</code> passes if all   the provided checks pass while both ensure the checks are run sequentially rather than concurrently.</li> <li><code>as_slash_command</code>, <code>as_message_command</code> and <code>as_message_command_group</code> now support decorating Command   instances.</li> </ul>"},{"location":"changelog/#changed_24","title":"Changed","text":"<ul> <li><code>cached_inject</code> and <code>cache_callback</code> now both accept <code>float</code> and <code>int</code> seconds for <code>expire_after</code>.</li> <li><code>Owners.__init__</code> now accepts <code>float</code> and <code>int</code> seconds for <code>expire_after</code>.</li> <li>Renamed <code>tanjun.dependencies.owners.OwnerCheck</code> and <code>tanjun.dependencies.owners.AbstractOwnerCheck</code>   to <code>Owners</code> and <code>AbstractOwners</code> respectively.</li> <li><code>InMemoryConcurrencyLimiter.set_bucket</code>'s parameters are now positional only.</li> <li>Updated application command name and option name checking to allow for all unicode \\w characters   rather than just ASCII.</li> <li><code>@with_parser</code> now errors if a parser is already set.</li> <li><code>with_option</code> and <code>with_argument</code> command parser decorators now implicitly set shlex parser if not set.</li> </ul>"},{"location":"changelog/#removed_8","title":"Removed","text":"<ul> <li><code>TanjunWarning</code> and <code>StateWarning</code>.</li> </ul>"},{"location":"changelog/#220a1-2021-11-23","title":"2.2.0a1 - 2021-11-23","text":""},{"location":"changelog/#added_26","title":"Added","text":"<ul> <li>Upgraded <code>is_alive</code> attribute to the Client abstract interface.</li> <li>Upgraded <code>clear_application_commands</code>, <code>declare_global_commands</code>, <code>declare_slash_command</code> and   <code>declare_slash_commands</code> to the Client abstract interface.</li> <li><code>Client.dispatch_client_callback</code> and <code>ClientCallbackNames</code> to the abstract interface.</li> <li>Client and Component are now bound to a specific event loop with said loop being exposed by a <code>loop</code> property.</li> <li><code>BaseSlashCommand.tracked_command</code>.</li> <li>Upgraded <code>load_modules</code>, <code>unload_modules</code> and <code>reload_modules</code> to the Client abstract interface.</li> <li><code>Component.make_loader</code> shorthand method for making a module loader and unloader for a component.</li> <li><code>tanjun.abc.ClientLoader</code> to make loaders more standard and easier to custom implement.</li> <li>Command cooldowns.</li> </ul>"},{"location":"changelog/#changed_25","title":"Changed","text":"<ul> <li>Renamed <code>Client.clear_commands</code> to <code>Client.clear_application_commands</code>.</li> <li>Renamed <code>declare_slash_command</code> and <code>declare_slash_commands</code> to <code>declare_application_command</code> and   <code>declare_application_commands</code> respectively.</li> <li>Renamed <code>Client.detect_commands</code> to <code>Client.load_from_scope</code>.</li> <li>Restructured LoadableProtocol for re-use in <code>Client.load_from_scope</code> and rename to <code>ComponentLoader</code>.</li> </ul>"},{"location":"changelog/#fixed_20","title":"Fixed","text":"<ul> <li>Don't include the \"tracked command ID\" in slash command group builders as this leads to mis-matching ID   errors while declaring.</li> </ul>"},{"location":"changelog/#removed_9","title":"Removed","text":"<ul> <li>BaseSlashCommand.tracked_command_id is no-longer used in command builders and cannot passed to   <code>as_slash_command</code>, <code>slash_command_group</code>, <code>SlashCommand.__init__</code> and <code>SlashCommandGroup.__init__</code>   as <code>command_id</code> anymore.</li> <li><code>load_from_attributes</code> behaviour from the standard Component implementation.</li> </ul>"},{"location":"changelog/#214a1-2021-11-15","title":"2.1.4a1 - 2021-11-15","text":""},{"location":"changelog/#added_27","title":"Added","text":"<ul> <li><code>injecting.SelfInjectingCallback</code> and <code>tanjun.as_self_injecting</code> to let users make a callback self-injecting   by linking it to a client instance. This should make it easier to use Tanjun's dependency injection   externally.</li> <li>Dependency injection support for hook callbacks.</li> <li><code>voice</code> property to Context and Client.</li> <li><code>Component.detect_commands</code> for auto-loading commands from the current scope.</li> <li><code>delete_after</code> option to context response methods.</li> <li><code>expires_at</code> property to SlashContext.</li> </ul>"},{"location":"changelog/#changed_26","title":"Changed","text":"<ul> <li><code>Hooks</code> can now contain multiple callbacks per hook type.</li> <li><code>load_from_attributes</code> now defaults to <code>False</code> in <code>Component.__init__</code>.</li> </ul>"},{"location":"changelog/#fixed_21","title":"Fixed","text":"<ul> <li><code>SlashContext.respond</code> trying to edit in the initial response instead of create a follow up   if a deferred initial response was deleted.</li> </ul>"},{"location":"changelog/#removed_10","title":"Removed","text":"<ul> <li><code>injecting.BaseInjectableCallback</code> and other private extensions of this as these cases could   easily be achieved with <code>SelfInjectingCallback</code> and <code>CallbackDescriptor</code>.</li> </ul>"},{"location":"changelog/#213a1-2021-11-02","title":"2.1.3a1 - 2021-11-02","text":""},{"location":"changelog/#added_28","title":"Added","text":"<ul> <li><code>tanjun.dependencies.inject_lc(Type)</code> which is a shorthand for   <code>tanjun.injected(callback=tanjun.make_lc_resolver(Type))</code>.</li> <li><code>tanjun.dependencies.cached_inject(...)</code> which is a shorthand for   <code>tanjun.injected(callback=tanjun.cache_callback(...))</code>.</li> <li><code>tanjun.inject</code> which is identical to <code>tanjun.injecting.injected</code> but does not replace it.</li> </ul>"},{"location":"changelog/#changed_27","title":"Changed","text":"<ul> <li>Added USE_EXTERNAL_STICKERS to DM permissions.</li> <li><code>Client.listeners</code> now returns a sequence of callbacks rather than descriptors.</li> </ul>"},{"location":"changelog/#fixed_22","title":"Fixed","text":"<ul> <li>Removed <code>cache_callback</code> from injecting.pyi.</li> <li>Some bodged logging calls in declare_slash_commands which weren't providing the right amount of format args.</li> <li>Options not being sorted for slash commands within a command group.</li> <li>Stop shlex from treating stuff after a <code>#</code> as a comment.</li> </ul>"},{"location":"changelog/#212a1-2021-10-15","title":"2.1.2a1 - 2021-10-15","text":""},{"location":"changelog/#added_29","title":"Added","text":"<ul> <li><code>Client.iter_commands</code>, <code>Client.iter_message_commands</code> and <code>Client.iter_slash_commands</code>.</li> <li>Ephemeral default is now applicable at a client and component level with it defaulting to <code>None</code> on   components, this will propagate down from the client to the command being executed with each level   having the option to override its state or leave it as is.</li> <li><code>OwnerCheck</code> now relies on a standard dependency (which can easily be overridden) for its actual logic.</li> </ul>"},{"location":"changelog/#changed_28","title":"Changed","text":"<ul> <li>SlashCommand's ephemeral default now defaults to <code>None</code> indicating that the parent entity's state should   be used.</li> <li>Check functions such as <code>nsfw_check</code>, <code>sfw_check</code>, <code>dm_check</code>, <code>guild_check</code> have been replaced with   check classes (NsfwCheck, SfwCheck, DmCheck, GuildCheck).</li> <li>Renamed <code>ApplicationOwnerCheck</code> to <code>OwnerCheck</code>.</li> <li>Renamed <code>OwnPermissionsCheck</code> to <code>OwnPermissionCheck</code>.</li> <li>Moved <code>cache_callback</code> from <code>tanjun.injecting</code> to <code>tanjun.dependencies</code>.</li> </ul>"},{"location":"changelog/#deprecated_4","title":"Deprecated","text":"<ul> <li>Passing Iterable[tuple[str, value]] as choices to the slash command options has been deprecated   in favour of Mapping[str, value].</li> </ul>"},{"location":"changelog/#fixed_23","title":"Fixed","text":"<ul> <li><code>MessageContext</code> not being passed to the prefix getter as the only positional argument.</li> <li><code>Client.remove_component_by_name</code>.</li> </ul>"},{"location":"changelog/#removed_11","title":"Removed","text":"<ul> <li><code>tanjun.abc.ExecutableCommand.execute</code> and <code>check_context</code> as this doesn't work typing wise.   This doesn't effect the implementations nor full command types.</li> <li>Base <code>PermissionsCheck</code> class.</li> </ul>"},{"location":"changelog/#211a1-2021-10-09","title":"2.1.1a1 - 2021-10-09","text":""},{"location":"changelog/#added_30","title":"Added","text":"<ul> <li><code>ShlexParser.add_option</code> and <code>add_argument</code> methods which mirror the behaviour of <code>with_option</code> and <code>with_argument</code></li> <li>Fluent interface coverage has been increased to now include remove methods and parsing interfaces.</li> <li>Support for specifying which channel types you want with slash channel type options.</li> <li><code>custom_ids</code> argument to both <code>Client.declare_global_commands</code>, <code>Client.__init__</code> and   <code>Client.declare_slash_commands</code> to allow specifying the IDs of commands which are being updated.</li> <li><code>Client.remove_component_by_name</code> and <code>get_component_by_name</code>.</li> <li><code>Client.unload_modules</code> and <code>Client.reload_modules</code> to unload and reload from modules which also declare   a unloader.</li> <li><code>tanjun.as_unloader</code> decorator to enable declaring unloaders for modules.</li> <li>Let a Sequence of guild ids/objects be passed for <code>Client.__init__</code>'s declare_global_commands parameter   (although custom_ids isn't supported in this instance).</li> <li>Client now enforces that all registered component names are unique within the client.</li> </ul>"},{"location":"changelog/#changed_29","title":"Changed","text":"<ul> <li>Bumped minimum hikari version to 2.0.0.dev103.</li> <li>The default parser error handler is now set as Client.hooks (not Client.message_hooks) meaning that it   runs for all commands not just message commands.</li> <li>Replace <code>conversion.ColorConverter</code> and <code>conversion.SnowflakeConverter</code> with <code>to_snowflake</code> and <code>to_color</code>   pure function implementations.</li> <li><code>Client.load_modules</code> now errors if no loader descriptor is found.</li> </ul>"},{"location":"changelog/#deprecated_5","title":"Deprecated","text":"<ul> <li>Calling set_tracked_command with a command ID.</li> <li>Passing command_id to <code>SlashCommand.__init__</code>, <code>SlashCommandGroup.__init__</code>, <code>as_slash_command</code> and   <code>as_slash_command_group</code>.</li> <li>Renamed <code>set_global_commands</code> (both the Client method and init parameter) to declare_global_commands.</li> </ul>"},{"location":"changelog/#removed_12","title":"Removed","text":"<ul> <li><code>add_converter</code> and <code>remove_converter</code> from Parameter.</li> <li>The <code>BaseConverter</code> classes are no-longer included in <code>conversion.__all__</code> meaning that they are no-longer   documented.</li> </ul>"},{"location":"changelog/#210a1-2021-10-02","title":"2.1.0a1 - 2021-10-02","text":""},{"location":"changelog/#added_31","title":"Added","text":"<ul> <li>Adding an option to SlashCommand will now raise if the name is invalid (doesn't match the names regex).</li> <li>Validation to slash command classes.</li> <li>Special case type injector handling for the client itself.</li> </ul>"},{"location":"changelog/#changed_30","title":"Changed","text":"<ul> <li>Breaking: <code>Client.set_type_dependency</code> now takes a literal value rather than a callback.</li> <li><code>Client.declare_slash_commands</code> and <code>Client.set_global_commands</code> now check if the target resource's commands   match the commands to be declared before actually declaring them unless <code>force</code> is set to <code>True</code>. This   helps avoid issues with ratelimiting.</li> <li>Client level special cased type injectors are now handled as normal type injectors which are just implicitly   set from the start.</li> <li><code>Client.load_modules</code> now respects <code>__all__</code> if present.</li> </ul>"},{"location":"changelog/#fixed_24","title":"Fixed","text":"<ul> <li>Small change to help MyPy better understand protocol behaviour.</li> <li><code>SlashContext.mark_not_found</code> and <code>cancel_defer</code> are actually called if the command was not found in the REST flow.</li> </ul>"},{"location":"changelog/#removed_13","title":"Removed","text":"<ul> <li><code>Client.add_type_dependency</code> and <code>Client.add_callback_override</code></li> <li>Special case type dependency methods have been removed/hidden.</li> <li><code>pass_as_kwarg</code> option from slash command artificial member options as the always member constraint cannot   be present without pass_as_kwarg behaviour.</li> </ul>"},{"location":"changelog/#201a1post1-2021-09-26","title":"[2.0.1a1.post1] - 2021-09-26","text":""},{"location":"changelog/#fixed_25","title":"Fixed","text":"<ul> <li>Trailing <code>:</code> on a type: ignore comment which broke MyPy compatibility.</li> </ul>"},{"location":"changelog/#201a1-2021-09-25","title":"2.0.1a1 - 2021-09-25","text":""},{"location":"changelog/#added_32","title":"Added","text":"<ul> <li>Default client level message parser error handling hook.</li> <li>Component arguments to the relevant context create message methods.</li> </ul>"},{"location":"changelog/#changed_31","title":"Changed","text":"<ul> <li>Bumped minimum Hikari version to 2.0.0.dev102.</li> <li>Consistently raise ValueError instead of LookupErrors in places where a value is being removed.</li> <li><code>Context.fetch_channel</code> and <code>Context.get_channel</code> now return TextableChannel and TextableGuildChannel   respectively.</li> </ul>"},{"location":"changelog/#fixed_26","title":"Fixed","text":"<ul> <li>Actually call <code>Command.bind_client</code> and bind_component in the component add command methods and   specifically <code>SlashCommand.bind_client</code> in <code>Component.bind_client</code>.</li> <li>Return the command object from <code>Component.with_command methods</code>.</li> <li>Automatic deferral is now also cancelled in <code>SlashContext.create_initial_response</code>.</li> <li><code>SlashContext.edit_last_response</code> can now be used to edit a deferred response.</li> <li>Small typing fixes made while setting pyright to strict.</li> </ul>"},{"location":"changelog/#removed_14","title":"Removed","text":"<ul> <li>suppress_exceptions from <code>Client.dispatch_client_callback</code> cause it was poorly implemented and didn't make sense.</li> </ul>"},{"location":"changelog/#200a4-2021-09-17","title":"2.0.0a4 - 2021-09-17","text":""},{"location":"changelog/#added_33","title":"Added","text":"<ul> <li><code>expire_after</code> argument to <code>tanjun.injecting.cached_callback</code>.</li> <li>snowflake \"search\" functions and from_datetime to conversion.</li> <li>the snowflake \"parse\" methods are now exported by conversion.</li> <li><code>BaseConverter.requires_cache</code> and <code>cache_components</code> properties + check_client method to allow for   warning if a converter might not run as expected under the provided client (e.g. intent or state issues).</li> </ul>"},{"location":"changelog/#changed_32","title":"Changed","text":"<ul> <li>renamed \"conversion.parse_datetime\" to \"conversion.to_datetime\".</li> <li><code>Client.__init__</code> now allows <code>hikari.SnowflakeishOr[hikari.PartialGuild] | None</code> for set_global_commands.</li> </ul>"},{"location":"changelog/#removed_15","title":"Removed","text":"<ul> <li>BaseConverter.bind_client, bind_component, get_from_type, implementations, cache_bound, is_inheritable   and types methods/properties as these were part of an old system which assumed these would be inferred   from types which is no longer the case.</li> </ul>"},{"location":"changelog/#fixed_27","title":"Fixed","text":"<ul> <li>A failed startup set global commands call will no longer lead to it retrying on the next startup.</li> <li>Component level check errors not being caught when executing interactions.</li> <li>The internal state for whether a SlashContext has had it's initial response made or not not being set by   SlashContext.mark_not_found.</li> <li>Client.on_interaction_create_request not awaiting the client level checks.</li> </ul>"},{"location":"changelog/#200a3post1-2021-09-11","title":"[2.0.0a3.post1] - 2021-09-11","text":""},{"location":"changelog/#changed_33","title":"Changed","text":"<ul> <li>Client.add_listener is now fluent.</li> </ul>"},{"location":"changelog/#fixed_28","title":"Fixed","text":"<ul> <li>Bug around registering wrapped listeners where Hikari doesn't allow async callable objects to be registered.</li> </ul>"},{"location":"changelog/#200a3-2021-09-10","title":"2.0.0a3 - 2021-09-10","text":""},{"location":"changelog/#added_34","title":"Added","text":"<ul> <li>Add <code>always_float</code> keyword argument to with_float_slash_option.</li> <li>SlashContext.options mapping plus a resolvable option type to allow for more easily getting slash command   options without relying on passed keyword arguments.</li> <li>Automatic type injector special casing for components and commands within a command context.</li> <li>Split up tanjun.commands.SlashCommand.add_option into specific methods.</li> <li>Add <code>pass_as_kwarg</code> keyword argument to with slash option decorators with True default.</li> </ul>"},{"location":"changelog/#changed_34","title":"Changed","text":"<ul> <li>Renamed <code>Client.__init__</code> \"shard\" arg to \"shards\".</li> <li>Annotate implimation functions/properties which return collections as returning <code>collections.abc.Collection</code>   instead of their implemation specific subclass of Collcetion.</li> <li>Standard checks now have the same defaults as their with_* counterparts.</li> </ul>"},{"location":"changelog/#fixed_29","title":"Fixed","text":"<ul> <li>Bug around checks not being respected if they returned False.</li> <li>Client level check errors not being caught during execution.</li> <li>Don't erroneously dispatch message command not found callbacks when a component's execution returns true</li> <li>Don't fall back to normal command search in \"strict\" components and message command groups.</li> <li>Edit the command if command_id is passed to declare_slash_command instead of creating a new command.</li> <li>Missing call to checks in interaction request handler logic.</li> </ul>"},{"location":"changelog/#removed_16","title":"Removed","text":"<ul> <li>Client.check_message_context and Component.check_message_context.</li> <li>tanjun.commands.SlashCommand.add_option.</li> </ul>"},{"location":"changelog/#200a2-2021-09-07","title":"2.0.0a2 - 2021-09-07","text":""},{"location":"changelog/#added_35","title":"Added","text":"<ul> <li>Float slash command option type.</li> <li>Component add and remove client callbacks.</li> <li>Event listeners are now loaded into Client by Components and support dependency injection.</li> <li>Add/with and remove listener methods had to be added to the Client to support this.</li> <li>Exported the parsing, commands and utilities modules on a top level (thus also adding them to the generated docs).</li> <li>Allow for overriding the standard client's context builders.</li> <li>Add default_permission argument to slash command types.</li> <li>Dependency injection support to client callbacks.</li> <li>Injection type special casing is more granular on a context to context basis now rather than top level hardcoded.</li> <li>Injection.Descriptor, TypeDescriptor and CallbackDescriptor replaced the Getter and InjectableValue classes.</li> </ul>"},{"location":"changelog/#changed_35","title":"Changed","text":"<ul> <li>Component.listeners and Client.listeners now return Mapping[type[Event], Collection[Callback]].</li> <li>Dependency injection on a lower level has been restructured to remove any reliance on tanjun.abc.Context.   This means introducing an abstract injection context and implementing it with the standard context and a more   basic impl.</li> <li>More strictly use properties instead of public instance variables in injection implementation.</li> <li>Dependency injection now caches the results of callbacks within the scope of an execution context.</li> <li>Renamed the InjectedValue classes to InjectedCallbacks.</li> <li>Return CallbackDescriptors from InjectionClient.get_type_dependency and get_callback_override instead of   pure callbacks.</li> <li>Use Optional instead of UndefinedOr in injecting module where possible (e.g. the Injected callback and type fields).</li> <li>Process injected callbacks when they're first handled (passed to CallbackDescriptor) than when they're first called   This lowers the amount of external caching needed.</li> </ul>"},{"location":"changelog/#deprecated_6","title":"Deprecated","text":"<ul> <li>InjectionClient/Client .add_type_dependency and add_callback_override have been deprecated in favour of   set_type_dependency and set_callback_override and are scheduled to be removed a month after v2.0.0a2 is released.</li> </ul>"},{"location":"changelog/#removed_17","title":"Removed","text":"<ul> <li>injecting.Getter and injecting.InjectableValue.</li> <li>set_injector methods as the injection client is now passed around as part of a context.</li> <li>injection.resolve_getters (this logic is now on the descriptors).</li> </ul>"},{"location":"changelog/#fixed_30","title":"Fixed","text":"<ul> <li>Doc typo and export fixes.</li> <li>Fix handling of ctx.content and ctx.triggering_nameand in MessageCommandGroup to account for doubly nested command groups.</li> <li>Fix double-calling command group checks instead of calling the command group checks then the sub-command's check.</li> </ul>"},{"location":"changelog/#200a1-2021-08-30","title":"2.0.0a1 - 2021-08-30","text":""},{"location":"changelog/#added_36","title":"Added","text":"<ul> <li>For a TLDR of how Tanjun's interface looks after these changes see the   examples.</li> <li>Full slash command functionality, this includes new decorators for setting slash command specific options and slash   command + command group declaration and execution. Some examples of this may be found   here.</li> <li>Dependency injection, this feature is in it's early days and under documented but is still partially documented by   the examples here. For now this only covers   command callback, check (on both commands and components) and converter execution plus calls to the prefix getter   functions (since it's limited to calls which take a Context for the initial implementation).</li> <li>Increased test and documentation coverage.</li> <li>The ability to set a custom prefix getter function.</li> <li>More extensive examples.</li> <li>REST fallbacks to the standard converters where possible.</li> <li>A flag for setting which message commands the standard client should accept for execution.</li> <li>Client callback functions to allow for better integration between hikari's RESTBot and GatewayBot plus collecting   runtime metadata.</li> <li>Proxy methods and properties to the Context abcs to allow for calls when using the base Context abc.</li> <li>State tracking to Context to allow for similar functionality between the slash and message command flows when it   comes to dealing with responses (e.g. initial and last response logic).</li> <li>Introduced a proper nox framework for running checks and CI tasks.</li> <li><code>error_message</code> and <code>half_execution</code> arguments to the standard checks to allow commands to more granularly define   the behaviour for when they fail plus default them to having them send an error message when they fail if they were   added to a command through a decorator call as this works better with the slash command flow and is better UX (a   response explaining why it didn't work is better than no response).</li> </ul>"},{"location":"changelog/#changed_36","title":"Changed","text":"<ul> <li>Move away from enforcing subclassing behaviour in-favour of builder objects ~~you can still use subclassing behaviour   in places but don't tell anybody I told you that~~.</li> <li>Consistency fix by ensuring functions are always called \"callback\".</li> <li>Renamed <code>tanjun.traits</code> to <code>tanjun.abc</code>.</li> <li>Replaced strategy of inferring other hikari client traits from the first arg parsed to <code>Client.__init__</code> with having   the init explicitly take in each trait it needs as a separate argument while having shortcut <code>from_gateway_bot</code> and   <code>from_rest_bot</code> classmethods for building the standard client from hikari's \"bot\" traits.</li> <li>Only default to setting <code>set_human_only(True)</code> in <code>Client.from_gateway_bot</code>.</li> <li>API overhall around commands and context, this involved making a lot of classes and type hints generic to allow   for the slash context and message context to be interchaingable under the right circumstances.</li> <li>Made the callback signatures more generic for commands and converters to allow for implementations to introduce   features like dependency injection.</li> <li>Replaced MYPY with pyright as the standard type checker.</li> <li>Switch over to relative imports.</li> <li>Switched over to just importing the top level <code>hikari</code> module when possible to simplify imports.</li> <li>Moved the project metadata dunder properties direcltly to <code>tanjun</code> (from <code>tanjun.about.py</code>).</li> <li>Switched over to pdoc from pdoc3 for doc generation.</li> <li>Switched away from setuptools to pep 621 with flit for defining the library and it's metadata (including   requirements).</li> </ul>"},{"location":"changelog/#fixed_31","title":"Fixed","text":"<ul> <li>Fix some bugs with the standard checks.</li> </ul>"},{"location":"changelog/#removed_18","title":"Removed","text":"<ul> <li>A lot of impl specific setting and with methods from the abstract interfaces to avoid leaking impl detail.</li> <li>Support for python 3.8 in-order to switch over to using collection.abc generic classes due to this being more   forward compatible.</li> </ul>"},{"location":"usage/","title":"Usage","text":"<p>This guide is not a conclusive list of the features in Tanjun.</p> <p>You'll want to have some basic understanding of Hikari before you start using Tanjun. A basic Hikari guide can be found here.</p>"},{"location":"usage/#starting-with-hikari","title":"Starting with Hikari","text":"<p>Tanjun supports both REST server-based application command execution and gateway-based message and application command execution, and to run Tanjun you'll want to link it to a Hikari bot.</p> <pre><code>bot = hikari.impl.GatewayBot(\"TOKEN\")\nclient = tanjun.Client.from_gateway_bot(bot, declare_global_commands=True, mention_prefix=True)\n\n...\n\nbot.run()\n</code></pre> <p>Here a Tanjun client is linked to a gateway bot instance to enable both message and application command execution.</p> <p>There's no need to directly start or stop the Tanjun client as it'll be managed by lifetime events (unless <code>event_managed=False</code> is passed).</p> <p><code>declare_global_commands=True</code> instructs the client to declare the bot's slash commands and context menus on startup and <code>mention_prefix=True</code> allows the bot's message commands to be triggered by starting a command call with <code>@bot</code>.</p> <pre><code>bot = hikari.impl.RESTBot(\"TOKEN\", hikari.TokenType.BOT)\ntanjun.Client.from_rest_bot(bot, bot_managed=True, declare_global_commands=True)\nbot.run()\n</code></pre> <p>And here a Tanjun client is linked to a REST server bot instance to enable application command execution.</p> <p>Unlike when linked to a Gateway bot, <code>bot_managed=True</code> must be explicitly passed to Client.from_rest_bot to have the client automatically start when the Rest bot starts.</p>"},{"location":"usage/#client-lifetime-management","title":"Client lifetime management","text":"<p>While Hikari's bots provide systems for stating and stopping sub-components, these aren't cross-compatible nor Tanjun friendly and Tanjun's client callbacks provide a cross-compatible alternative for these (which also supports dependency injection).</p> <pre><code>client = tanjun.Client.from_gateway_bot(bot)\n\n@client.with_client_callback(tanjun.ClientCallbackNames.STARTING)\nasync def on_starting(client: alluka.Injected[tanjun.abc.Client]) -&gt; None:\n    client.set_type_dependency(aiohttp.ClientSession, aiohttp.ClientSession())\n\nasync def on_closed(session: alluka.Injected[aiohttp.ClientSession]) -&gt; None:\n    await session.close()\n\nclient.add_client_callback(tanjun.ClientCallbackNames.CLOSED, on_closed)\n</code></pre>"},{"location":"usage/#managing-bot-functionality","title":"Managing bot functionality","text":"<p>tanjun.components.Component exists as a way to manage and group bot functionality, storing functionality such as event listeners, commands, scheduled callbacks, and client callbacks.</p> <pre><code>component = tanjun.Component()\n\n@component.with_command\n@tanjun.as_slash_command(\"name\", \"description\")\nasync def slash_command(ctx: tanjun.abc.SlashContext) -&gt; None:\n    ...\n\n@component.with_listener()\nasync def event_listener(event: hikari.Event) -&gt; None:\n    ...\n</code></pre> <p>The <code>with_</code> methods on Component allow loading functionality like commands, event listeners, and schedules into it through a decorator call; the relevant <code>add_</code> functions allow adding functionality through chained calls.</p> <pre><code>@tanjun.as_message_command(\"name\")\nasync def command(ctx: tanjun.abc.MessageContext) -&gt; None:\n    ...\n\ncomponent = tanjun.Component().load_from_scope()\n</code></pre> <p>Alternatively, functionality which is represented by a dedicated object can be implicitly loaded from a module's global scope using Component.load_from_scope rather than directly calling <code>with_</code> and <code>add_</code> methods.</p>"},{"location":"usage/#loading-modules","title":"Loading modules","text":"<p>Components are used to represent the functionality in a Python module. While add_component can be used to directly add a component to a client, you can also declare \"loaders\" and \"unloaders\" for a module to more ergonomically load this functionality into a client.</p> <pre><code>component = tanjun.Component().load_from_scope()\n\n@tanjun.as_loader\ndef load(client: tanjun.Client) -&gt; None:\n    client.add_component(component)\n\n@tanjun.as_unloader\ndef unload(client: tanjun.Client) -&gt; None:\n    client.remove_component(component)\n</code></pre> <p>You can either declare one or more custom loaders and unloaders as shown above</p> <pre><code>component = tanjun.Component().load_from_scope()\n\nloader = component.make_loader()\n</code></pre> <p>or use make_loader to generate a loader and unloader for the component.</p> <pre><code>(\n    tanjun.Client.from_gateway_bot(bot)\n    .load_directory(\"./bot/components\", namespace=\"bot.components\")\n    .load_modules(\"bot.owner\")\n)\n</code></pre> <p>Modules with loaders can then be loaded into a client by calling load_directory to load from all the modules in a directory or load_modules to load specific modules.</p>"},{"location":"usage/#declaring-commands","title":"Declaring commands","text":"<p>Commands need to be contained within a component to be loaded into a client and may be added to a component either directly using Component.add_command/ Component.with_command (where add is chainable and with is a decorator callback) or implicitly using Component.load_from_scope.</p> <p>All command callbacks must be asynchronous and can use dependency injection.</p>"},{"location":"usage/#slash-commands","title":"Slash commands","text":"<pre><code>@tanjun.with_str_slash_option(\"option\", \"description\")\n@tanjun.as_slash_command(\"name\", \"description\")\nasync def slash_command(ctx: tanjun.abc.SlashContext) -&gt; None:\n    ...\n</code></pre> <p>Slash commands represent the commands you see when you start typing with \"/\" in Discord's message box and have names (which follow the restraints shown in https://discord.com/developers/docs/dispatch/field-values#predefined-field-values-accepted-locales) and descriptions (which can be up to 100 characters long).</p> <p>There are several different kinds of slash command arguments which all require an argument name and description (both of which have the same constraints as the relevant slash command fields) along with type-specific configuration. These can be configured using the following decorator functions and their <code>add_{type}_option</code> equivalent chainable methods on SlashCommand:</p> <ul> <li>with_attachment_slash_option</li> <li>with_bool_slash_option</li> <li>with_channel_slash_option</li> <li>with_float_slash_option</li> <li>with_int_slash_option</li> <li>with_member_slash_option</li> <li>with_mentionable_slash_option</li> <li>with_role_slash_option</li> <li>with_str_slash_option</li> <li>with_user_slash_option</li> </ul> <p>Most notably, only string arguments support converters (and the standard converters found in tanjun.conversion) similarly to message command arguments.</p> <pre><code>ding_group = tanjun.slash_command_group(\"ding\", \"ding group\")\n\n@ding_group.as_sub_command(\"dong\", \"dong command\")\nasync def dong_command(ctx: tanjun.abc.SlashContext) -&gt; None:\n    ...\n\nding_ding_group = ding_group.make_sub_group(\"ding\", \"ding ding group\")\n\n@ding_ding_group.as_sub_command(\"ding\", \"ding ding ding command\")\nasync def ding_command(ctx: tanjun.abc.SlashContext) -&gt; None:\n    ...\n</code></pre> <p>Slash commands can be stored in groups where the above example will be shown in the command menu as <code>\"/ding dong\"</code> and <code>\"/ding ding ding\"</code>. Unlike message command groups, slash command groups cannot be directly called as commands and can only be nested once. For more information on how slash command groups are configured see slash_command_group.</p>"},{"location":"usage/#message-commands","title":"Message commands","text":"<pre><code>tanjun.Client.from_gateway_bot(bot).add_prefix(\"!\")\n\n...\n\n@tanjun.with_option(\"reason\", \"--reason\", \"-r\", default=None)  # This can be triggered as --reason or -r\n@tanjun.with_multi_option(\"users\", \"--user\", \"-u\", default=None)  # This can be triggered as --user or -u\n@tanjun.with_greedy_argument(\"content\")\n@tanjun.with_argument(\"days\", converters=int)\n@tanjun.as_message_command(\"meow command\", \"description\")\nasync def message_command(ctx: tanjun.abc.MessageContext) -&gt; None:\n    ...\n</code></pre> <p>Message commands are triggered based on chat messages where the client's prefixes and command names are used to match executable message commands (the above example would match messages starting with <code>\"!meow command\"</code>). These will only be executed when linked to a gateway bot with the <code>MESSAGE_CONTENT</code> intent declared and when at least 1 prefix is set.</p> <p>To allow users to trigger a command by mentioning the bot before the command name (e.g. <code>@BotGirl meow command</code>) you can pass <code>mention_prefix=True</code> to either Client.from_gateway_bot or Client.__init__ while creating the bot.</p> <pre><code># prefixes=[\"!\"]\n\n@tanjun.as_message_command_group(\"groupy\")\nasync def groupy_group(ctx: tanjun.abc.MessageContext):\n    ...\n\n@groupy_group.as_sub_command(\"sus drink\")\nasync def sus_drink_command(ctx: tanjun.abc.MessageContext):\n    ...\n\n@groupy_group.as_sub_group(\"tour\")\nasync def tour_group(ctx: tanjun.abc.MessageContext):\n    ...\n\n@tour_group.as_sub_command(\"de france\")\nasync def de_france_command(ctx: tanjun.abc.MessageContext):\n    ...\n</code></pre> <p>Message command groups are a collection of message commands under a shared name and (unlike slash commands) can also be directly executed as a command. The above example would have the following commands: <code>\"!groupy\"</code>, <code>!\"groupy tour\"</code>, <code>\"!groupy tour de france\"</code> and <code>\"!groupy sus drink\"</code>. For more information on how message command groups are configured see as_message_command_group.</p>"},{"location":"usage/#argument-parsing","title":"Argument parsing","text":"<p>Message command argument parsing always handles string arguments and to declare parsed arguments you can use one of the <code>with_option</code> or <code>with_argument</code> methods in tanjun.parsing; while options are optional arguments that are passed based on a flag name (e.g. <code>\"--key\"</code>), arguments are passed positionally. It's worth noting that since decorators are executed from the bottom upwards positional arguments will follow the same order.</p> <p>Arguments and options have multiple parsing approaches: Arguments only parse one value by default; \"multi\" (can be applied to both) arguments parse multiple values separately (passed to the function as a list of values); \"greedy\" (argument only) arguments parse the remaining positional values as one big string (including spacing).</p> <p>The most helpful configuration for options and arguments is converters: these are callbacks which will be called to try convert an argument's raw value; the first callback to pass (not raise a ValueError) is used as the value. For more configuration see tanjun.parsing and for the standard converters see tanjun.conversion.</p>"},{"location":"usage/#context-menus","title":"Context menus","text":"<pre><code>@component.with_command\n@tanjun.as_message_menu(\"name\")\nasync def message_menu_command(ctx: tanjun.abc.MenuContext, message: hikari.Message) -&gt; None:\n    ...\n\n@component.with_command\n@tanjun.as_user_menu(\"name\")\nasync def user_menu_command(ctx: tanjun.abc.MenuContext, user: hikari.User) -&gt; None:\n    ...\n</code></pre> <p>Context menus represent the application commands shown when you click on a user or message in Discord and, unlike slash and message commands, do not have configurable arguments nor groups. For more information on configuring menu commands see tanjun.as_message_menu.</p>"},{"location":"usage/#annotation-based-command-declaration","title":"Annotation based command declaration","text":"<p>Previously you've seen how to manually declare command options per command type, now it's time to go higher.</p> <pre><code>from typing import Annotated, Optional\n\nfrom tanjun.annotations import Bool, Converted, Int, Ranged, Str, User\n\n@tanjun.annotations.with_annotated_args(follow_wrapped=True)\n@tanjun.as_slash_command(\"name\", \"description\")\n@tanjun.as_message_command(\"name\")\nasync def command(\n    ctx: tanjun.abc.Context,\n    name: Annotated[Str, \"description\"],\n    age: Annotated[Int, Ranged(13, 130), \"an int option with a min, max or 13, 130\"],\n    video: Annotated[Video, Converted(get_video), \"a string option which is converted with get_video\"],\n    user: Annotated[Optional[User], \"an optional user option which defaults to None\"] = None,\n    enabled: Annotated[Bool, \"an optional bool option which defaults to True\"] = True,\n) -&gt; None:\n    ...\n</code></pre> <p>tanjun.with_annotated_args provides a simple way to declare the arguments for both message and slash commands. While this feature is cross-compatible, there is one key difference: a description must be included for options when annotating for a slash command, which is done by passing a string value to typing.Annotated (as shown above).</p> <p>The special generic types offered in tanjun.annotations (e.g Ranged and Converted) return a typing.Annotated instance from their generic calls and can also be passed as arguments to Annotated like <code>Annotated[Int, Ranged(13, 130)]</code>, and <code>Annotated[Str, Converted(get_video)]</code>.</p> <p>This example doesn't demonstrate every feature of this, and More information on how arguments are configured through annotations can be found in tanjun.annotations.</p>"},{"location":"usage/#wrapped-commands","title":"Wrapped commands","text":"<p>When creating multiple command types in a decorator call chain, standard decorators which can be applied to multiple command types often have a <code>follow_wrapped</code> argument which will apply them to all the compatible commands in a chain if True is passed for it.</p> <p>When using <code>follow_wrapped</code> the relevant decorator will be applied to all the compatible <code>as_{}_command</code> decorator calls below it in the chain.</p> <pre><code>@tanjun.annotations.with_annotated_args(follow_wrapped=True)\n@tanjun.with_guild_check(follow_wrapped=True)\n@tanjun.as_slash_command(\"name\", \"description\")\n@tanjun.as_message_command(\"name\")\nasync def command(ctx: tanjun.abc.Context) -&gt; None:\n    ...\n</code></pre> <p>While the previous command examples have typed <code>ctx</code> as a context type that's specific to the command type, it's worth noting that abc.Context is a shared base for every command context type and may be used as the type for <code>ctx</code> when a callback supports multiple command types.</p>"},{"location":"usage/#responding-to-commands","title":"Responding to commands","text":"<pre><code>@tanjun.annotations.with_annotated_args(follow_wrapped=True)\n@tanjun.as_slash_command(\"name\", \"description\")\n@tanjun.as_message_command(\"name\")\n@tanjun.as_user_menu(\"name\")\nasync def command(\n    ctx: tanjun.abc.Context, user: typing.Annotated[typing.Optional[annotations.User], \"The user to target\"] = None\n) -&gt; None:\n    user = user or ctx.author\n    message = await ctx.respond(\n        \"message content\",\n        attachments=[hikari.File(\"./its/a/mystery.jpeg\")],\n        embeds=[hikari.Embed(title=str(ctx.author)).set_thumbnail(ctx.author.display_avatar_url)],\n        ensure_result=True,\n    )\n</code></pre> <p>Context.respond is used to respond to a command call, this has a similar signature to Hikari's message respond method but will only be guaranteed to return a hikari.messages.Message object when <code>ensure_result=True</code> is passed.</p>"},{"location":"usage/#ephemeral-responses","title":"Ephemeral responses","text":"<pre><code># All this command's responses will be ephemeral.\n@component.with_command\n@tanjun.as_slash_command(\"name\", \"description\", default_to_ephemeral=True)\nasync def command_1(ctx: tanjun.abc.SlashContext) -&gt; None:\n    await ctx.respond(\"hello friend\")\n\n@component.with_command\n@tanjun.as_user_menu(\"name\")\nasync def command_2(ctx: tanjun.abc.MenuContext, user: hikari.User) -&gt; None:\n    await ctx.create_initial_response(\"Starting the thing\", ephemeral=True)  # private response\n    await ctx.respond(\"meow\")  # public response\n    await ctx.create_followup(\"finished the thing\", ephemeral=True)  # private response\n</code></pre> <p>Ephemeral responses are a slash command and context menu exclusive feature which marks a response as private (so that only the command author can see it) and temporary. A response can be marked as ephemeral by either passing <code>ephemeral=True</code> to AppCommandContext.create_initial_response (when initially responding to the slash command) or AppCommandContext.create_followup (for followup responses). Alternatively, an ephemeral default can either be set on a client level (using Client.set_ephemeral_default), component level (using Component.set_ephemeral_default), or for a specific command (by passing <code>default_to_ephemeral=True</code> while creating a command) to have any relevant application command responses default to ephemeral (including calls to tanjun.abc.Context.respond).</p>"},{"location":"usage/#deferrals","title":"Deferrals","text":"<p>Slash commands and context menus traditionally need to give an initial response within 3 seconds. If you don't have a response message ready within 3 seconds, you can defer the first response using AppCommandContext.defer; the client will even automatically defer by default if you haven't created an initial response within a couple of seconds. Context.respond is aware of deferrals so you likely won't need to think about automatic deferral, unless you're using AppCommandContext.create_initial_response.</p> <p>A deferral should be finished by editing in the initial response using either Context.edit_initial_response or Context.respond and if you want a deferred response to be ephemeral you'll have to either pass <code>ephemeral=True</code> while deferring or have the ephemeral default set to True.</p> <p>Automatic deferral can be configured using Client.set_auto_defer_after, and commands can even be configured to always defer when they start executing by passing <code>always_defer=True</code> while creating the command.</p>"},{"location":"usage/#slash-command-autocomplete","title":"Slash command autocomplete","text":"<p>Autocomplete is a slash command exclusive feature that allows a bot to dynamically return choice suggestions to a user as they type a string option.</p> <p>Autocomplete callbacks must be asynchronous and support dependency injection.</p> <pre><code>@component.with_command\n@tanjun.with_str_slash_option(\"opt1\", \"description\")\n@tanjun.with_str_slash_option(\"opt2\", \"description\", default=None)\n@tanjun.as_slash_command(\"name\", \"description\")\nasync def slash_command(ctx: tanjun.abc.SlashContext, opt1: str, opt2: typing.Optional[str]) -&gt; None:\n    ...\n\n@slash_command.with_str_autocomplete(\"opt1\")\nasync def opt1_autocomplete(ctx: tanjun.abc.AutocompleteContext, value: str) -&gt; None:\n    await ctx.set_choices(((\"name\", \"value\"), (\"other_name\", \"other_value\")), other_other_name=\"other_other_value\")\n\nasync def opt2_autocomplete(ctx: tanjun.abc.AutocompleteContext, value: str) -&gt; None:\n    await ctx.set_choices({\"name\": \"value\", \"other_name\": \"other_value\"})\n\nslash_command.set_str_autocomplete(\"opt2\", opt2_autocomplete)\n</code></pre> <p>To set the results for an autocomplete interaction call AutocompleteContext.set_choices: this has a similar signature to dict and takes up to 25 choices (where both name and value have a limit of up to 100 characters).</p> <p>Unlike application commands, autocomplete must give a response within 3 seconds as these do not support deferrals.</p>"},{"location":"usage/#dependency-injection","title":"Dependency injection","text":"<p>Tanjun supports type-based dependency injection as a type-safe approach for handling global state for most of the callbacks it takes (e.g. command callbacks, checks, hook callbacks, event listeners, schedule callbacks) through Alluka.</p> <pre><code>client = tanjun.Client.from_gateway_bot(bot)\nclient.set_type_dependency(Foo, Foo())\nclient.set_type_dependency(Bar, Bar())\n</code></pre> <p>Here we set the dependencies for the types <code>Foo</code> and <code>Bar</code>.</p> <pre><code>@tanjun.as_slash_command(\"name\", \"description\")\nasync def command(\n    ctx: tanjun.abc.SlashContext, foo_impl: alluka.Injected[Foo], bar_impl: Bar = alluka.inject(type=Bar)\n) -&gt; None:\n    ...\n</code></pre> <p>And here we declare a command callback as taking the client set values for <code>Foo</code> and <code>Bar</code> as keyword arguments using two different approaches. Since both arguments don't provide a default, these commands will fail if no value for <code>Foo</code> or <code>Bar</code> has been set using Client.set_type_dependency.</p> <p>A more detailed guide on how this works and the full feature set (e.g. optional dependencies) can be found here. alluka.abc.Client is exposed at Client.injector.</p>"},{"location":"usage/#standard-and-special-cased-injected-types","title":"Standard and special cased injected types.","text":"<p>The following types are registered globally as type dependencies:</p> <ul> <li>tanjun.abc.Client</li> <li>tanjun.clients.Client</li> <li>tanjun.dependencies.AbstractOwners (for use with the standard owner check).</li> <li><code>tanjun.LazyConstant[hikari.OwnUser]</code> (for use with <code>tanjun.inject_lc(hikari.OwnUser)</code>)</li> <li>hikari.api.rest.RESTClient</li> <li>hikari.api.cache.Cache *</li> <li>hikari.api.event_manager.EventManager *</li> <li>hikari.api.interaction_server.InteractionServer *</li> <li>hikari.traits.ShardAware *</li> <li>hikari.api.voice.VoiceComponent *</li> </ul> <p>* These type dependencies are only registered if the relevant Hikari component     was included while creating the tanjun.clients.Client instance.</p> <p>The following type dependencies are available in specific contexts:</p> <ul> <li>tanjun.abc.AutocompleteContext: slash command autocomplete execution</li> <li>tanjun.abc.AppCommandContext: both slash and menu command execution (excluding any checks)</li> <li>tanjun.abc.MenuContext: menu command execution</li> <li>tanjun.abc.MessageContext: message command execution</li> <li>tanjun.abc.SlashContext: slash command execution</li> </ul> <ul> <li>tanjun.abc.Component: Command execution (excluding client checks)</li> </ul> <p>Both Client.from_gateway_bot and Client.from_rest_bot register type dependencies for the relevant hikari traits that the bot is compatible with. You can get this behaviour after directly initialising tanjun.clients.Client without a from method by calling Client.set_hikari_trait_injectors with the relevant bot object.</p>"},{"location":"usage/#advanced-command-flow-management","title":"Advanced command flow management","text":""},{"location":"usage/#checks","title":"Checks","text":"<p>Checks are functions that run before command execution to decide whether a command or group of commands matches a context and should be called with it.</p> <pre><code>@tanjun.with_guild_check(follow_wrapped=True)\n@tanjun.with_author_permission_check(hikari.Permissions.BAN_MEMBERS)\n@tanjun.with_own_permission_check(hikari.Permissions.BAN_MEMBERS, follow_wrapped=True)\n@tanjun.as_message_command(\"name\")\n@tanjun.as_slash_command(\"name\", \"description\", default_member_permissions=hikari.Permissions.BAN_MEMBERS)\nasync def command(ctx: tanjun.abc.Context) -&gt; None:\n    ...\n</code></pre> <p>There's a collection of standard checks in tanjun.checks that are all exported top-level and work with all the command types. The only optional configuration most users will care about for the standard checks is the <code>error_message</code> argument which lets you adjust the response messages these send when they fail.</p> <pre><code>component = (\n    tanjun.Component()\n    .add_check(tanjun.checks.GuildCheck())\n    .add_check(tanjun.checks.AuthorPermissionCheck(hikari.Permissions.BAN_MEMBERS))\n    .add_check(tanjun.checks.OwnPermissionCheck(hikari.Permissions.BAN_MEMBERS))\n)\n\n@component.with_check\nasync def db_check(ctx: tanjun.abc.Context, db: alluka.Injected[Db]) -&gt; bool:\n    if (await db.get_user(ctx.author.id)).banned:\n        raise tanjun.CommandError(\"You are banned from using this bot\")\n\n    return False\n\n@tanjun.with_owner_check(follow_wrapped=True)\n@tanjun.as_message_command(\"name\")\n@tanjun.as_slash_command(\"name\", \"description\")\nasync def owner_only_command(ctx: tanjun.abc.Context):\n    ...\n</code></pre> <p>Checks (both custom and standard) can be added to clients, components, and commands using either the chainable <code>add_check</code> method or the decorator style <code>with_check</code> method. The standard checks also provide <code>with_...</code> decorators which can be used to add the check to a command during a decorator chain. Checks on a client, component, or command group will be used for every child command.</p> <pre><code>def check(ctx: tanjun.abc.Context) -&gt; bool:\n    if ctx.author.discriminator % 2:\n        raise tanjun.CommandError(\"You are not one of the chosen ones\")\n\n    return True\n</code></pre> <p>Custom checks can be made by making a function with either the signature <code>def (tanjun.abc.Context, ...) -&gt; bool</code> or <code>async def (tanjun.abc.Context, ...) -&gt; bool</code> (where dependency injection is supported).  Returning True indicates that the check passed, and returning False indicates that the client should continue looking for a matching command as the check failed. You will probably want to raise CommandError to end command execution with a response rather than returning False.</p>"},{"location":"usage/#execution-hooks","title":"Execution hooks","text":"<p>Command hooks are callbacks that are called around command execution, these are contained within Hooks objects which may be added to a command, client, or component using <code>set_hooks</code> where hooks on a client, component or command group will be called for every child command.</p> <p>There are several different kinds of hooks which all support dependency injection and may be synchronous or asynchronous:</p> <pre><code>hooks = tanjun.AnyHooks()\n\n@hooks.with_pre_execution  # hooks.add_pre_execution\nasync def pre_execution_hook(ctx: tanjun.abc.Context) -&gt; None:\n    ...\n</code></pre> <p>Pre-execution hooks are called before the execution of a command but after command matching has finished and all the relevant checks have passed.</p> <pre><code>@hooks.with_post_execution  # hooks.add_post_execution\nasync def post_execution_hook(ctx: tanjun.abc.Context) -&gt; None:\n    ...\n</code></pre> <p>Post-execution hooks are called after a command has finished executing, regardless of whether it passed or failed.</p> <pre><code>@hooks.with_on_success  # hooks.add_success_hook\nasync def success_hook(ctx: tanjun.abc.Context) -&gt; None:\n    ...\n</code></pre> <p>Success hooks are called after a command has finished executing successfully (without raising any errors).</p> <pre><code>@hooks.with_on_error  # hooks.add_on_error\nasync def error_hook(ctx: tanjun.abc.Context, error: Exception) -&gt; typing.Optional[bool]:\n    ...\n</code></pre> <p>Error hooks are called when command's execution is ended early by an error raise that isn't a ParserError, CommandError or HaltExecution (as these are special-cased).</p> <p>The return value of an error hook is used with other error hook return values to workout whether the error should be re-raised: True acts as a vote towards suppressing the error, False acts as a vote towards re-raising the error and None acts as no vote. In the case of a tie the error will be re-raised.</p> <pre><code>@hooks.with_on_parser_error  # hooks.add_on_parser_error\nasync def parser_error_hook(ctx: tanjun.abc.Context, error: tanjun.ParserError) -&gt; None:\n    ...\n</code></pre> <p>Parser error hooks are called when the argument parsing of a message command failed. Parser errors are never re-raised.</p>"},{"location":"usage/#concurrency-limiter","title":"Concurrency limiter","text":"<p>Concurrency limiters allow you to limit how many calls can be made to a group of commands concurrently.</p> <pre><code>client = tanjun.Client.from_gateway_bot(bot)\n(\n    tanjun.InMemoryConcurrencyLimiter()\n    .set_bucket(\"main_commands\", tanjun.BucketResource.USER, 2)\n    .disable_bucket(\"plugin.meta\")\n    .add_to_client(client)\n)\n</code></pre> <p>Here InMemoryConcurrencyLimiter will manage the concurrency limits for all the commands in this bot instance with Limiter.set_bucket being called to limit the bucket <code>\"main_commands\"</code> to at most 2 concurrent executions per user, Limiter.disable_bucket being called to ensure that the bucket <code>\"plugin.meta\"</code> has no concurrency limit as unconfigured buckets will default to the configuration for the <code>\"default\"</code> bucket, and Limiter.add_to_client being used to set this limiter for a client (note that clients can only have 1 linked limiter).</p> <pre><code>@tanjun.with_concurrency_limit(\"main_commands\", follow_wrapped=True)\n@tanjun.annotations.with_annotated_args(follow_wrapped=True)\n@tanjun.as_message_command(\"name\")\n@tanjun.as_slash_command(\"name\", \"description\")\n@tanjun.as_user_menu(\"name\")\nasync def user_command(ctx: tanjun.abc.Context, user: typing.Annotated[annotations.User, \"A user\"]) -&gt; None:\n    ...\n</code></pre> <p>And here we use with_concurrency_limit to mark these commands as using the <code>\"main_commands\"</code> concurrency limit bucket; buckets share their limits for a resource across all the commands under it. For more information on the resources concurrency can be limited by see BucketResource.</p>"},{"location":"usage/#cooldowns","title":"Cooldowns","text":"<p>Cooldowns limit how often a group of commands can be called.</p> <pre><code>client = tanjun.Client.from_gateway_bot(bot)\n(\n    tanjun.InMemoryCooldownManager()\n    .set_bucket(\"main_commands\", tanjun.BucketResource.USER, 5, 60)\n    .disable_bucket(\"plugin.meta\")\n    .add_to_client(client)\n)\n</code></pre> <p>Here InMemoryCooldownManager will manage the cooldowns for all the commands in this bot instance with Manager.set_bucket being called to limit the bucket <code>\"main_commands\"</code> to 5 calls per user every 60 seconds, Manager.disable_bucket being called to ensure that the bucket <code>\"plugin.meta\"</code> has no cooldowns as unconfigured buckets will default to the configuration for the <code>\"default\"</code> bucket, and Manager.add_to_client being used to set this cooldown manager for a client (note that clients can only have 1 linked cooldown manager).</p> <pre><code>@tanjun.with_cooldown(\"main_commands\", follow_wrapped=True)\n@tanjun.annotations.with_annotated_args(follow_wrapped=True)\n@tanjun.as_message_command(\"name\")\n@tanjun.as_slash_command(\"name\", \"description\")\n@tanjun.as_user_menu(\"name\")\nasync def user_command(ctx: tanjun.abc.Context, user: typing.Annotated[annotations.User, \"A user\"]) -&gt; None:\n    ...\n</code></pre> <p>And here we use with_cooldown to mark these commands as using the <code>\"main_commands\"</code> cooldown bucket; buckets share their cooldowns for a resource across all the commands under it. For more information on the resources cooldowns can be set for see BucketResource.</p>"},{"location":"usage/#localisation","title":"Localisation","text":"<p>Localisation allows for tailoring the declarations and responses of slash commands and context menu commands to match specific regions by providing multiple translations of a field. Localisation on Discord is limited to the locales Discord supports (listed at hikari.locales.Locale).</p>"},{"location":"usage/#localising-command-declarations","title":"Localising command declarations","text":"<pre><code>@tanjun.as_slash_command({hikari.Locale.EN_US: \"Hola\"}, \"description\")\nasync def command(ctx: tanjun.abc.Context) -&gt; None:\n    ...\n</code></pre> <p>For fields which support localisation you've previously seen a single string being passed to them: this value is used as a default for all locales and for environments which don't support localisation (e.g. message command execution). But as shown above, you can also pass a dictionary of localised values to these fields.</p>"},{"location":"usage/#client-localiser","title":"Client localiser","text":"<p>Tanjun also provides an optional global localiser which allows for setting/overriding the locale-specific variants used for localised fields such as error message responses and application fields globally.</p> <pre><code>client = tanjun.Client.from_gateway_bot(bot)\n\n(\n    tanjun.dependencies.BasicLocaliser()\n    .set_variants(\n        \"slash:command name:name\", {hikari.Locale.EN_US: \"american variant\", hikari.Locale.EN_GB: \"english variant\"}\n    )\n    .set_variants(\n        \"message_menu:command name:check:tanjun.OwnerCheck\",\n        {hikari.Locale.JA: \"konnichiwa\", hikari.Locale.ES_ES: \"Hola\"},\n    )\n    .add_to_client(client)\n)\n</code></pre> <p>Specific fields may be overridden by their ID as shown above. There is no guaranteed format for field IDs but the standard implementations will always use the following formats unless explicitly overridden:</p> <ul> <li>Checks and limiters: <code>f\"{command_type}:{command_name}:check:{check_name}\"</code></li> <li>Command descriptions: <code>f\"{command_type}:{command_name}:description\"</code></li> <li>Command names: <code>f\"{command_type}:{command_name}:name\"</code></li> <li>Slash option names: <code>f\"slash:{command_name}:option.name:{option_name}\"</code></li> <li>Slash option descriptions: <code>f\"slash:{command_name}:option.description:{option_name}\"</code></li> <li>Slash option choice names: <code>f\"slash:{command_name}:choice.name:{choice_name}\"</code></li> </ul> <p><code>command_type</code> may be one of <code>\"message_menu\"</code>, <code>\"slash\"</code> or <code>\"user_menu\"</code>, <code>command_name</code> will be the full name of the command (including parent command names in the path), and standard check names will always be prefixed with <code>\"tanjun.\"</code>.</p> <p>It's highly recommended that 3rd party libraries match this format if possible.</p>"},{"location":"usage/#localising-command-responses","title":"Localising command responses","text":"<pre><code>LOCALISED_RESPONSES: dict[str, str] = {\n    hikari.Locale.DA: \"Hej\",\n    hikari.Locale.DE: \"Hallo\",\n    hikari.Locale.EN_GB: \"Good day fellow sir\",\n    hikari.Locale.EN_US: \"*shoots you*\",\n    hikari.Locale.ES_ES: \"Hola\",\n    hikari.Locale.FR: \"Bonjour, camarade baguette\",\n    hikari.Locale.PL: \"Musimy szerzy\u0107 gejostwo w Strefach wolnych od LGBT, musimy zrobi\u0107 rajd gejowski\",\n    hikari.Locale.SV_SE: \"Hej, jag \u00e4lskar min Bl\u00e5haj\",\n    hikari.Locale.VI: \"Xin ch\u00e0o, C\u00e2y n\u00f3i ti\u1ebfng Vi\u1ec7t\",\n    hikari.Locale.TR: \"Merhaba\",\n    hikari.Locale.CS: \"Ahoj\",\n    hikari.Locale.ZH_CN: \"\u81ea\u7531\u9999\u6e2f\",\n    hikari.Locale.JA: \"\u3053\u3093\u306b\u3061\u306f\u3001\u30a2\u30cb\u30e1\u306e\u5973\u306e\u5b50\u3060\u3063\u305f\u3089\u3044\u3044\u306e\u306b\",\n    hikari.Locale.ZH_TW: \"\u8ba9\u53f0\u6e7e\u81ea\u7531\",\n}\n\n@tanjun.as_slash_command(\"name\", \"description\")\nasync def as_slash_command(ctx: tanjun.abc.SlashContext) -&gt; None:\n    await ctx.respond(LOCALISED_RESPONSES.get(ctx.interaction.locale, \"hello\"))\n</code></pre> <p>tanjun.abc.AppCommandContext.interaction (base class for both tanjun.abc.SlashContext and tanjun.abc.MenuContext) both have the fields <code>guild_locale</code> and <code>locale</code> which provide the set locale of the guild and the user triggering the command respectively. This locale can be used to localise responses to specific languages within your own code.</p>"},{"location":"reference/","title":"tanjun","text":"<p>A flexible command framework designed to extend Hikari.</p> <p>Examples:</p> <p>A Tanjun client can be quickly initialised from a Hikari gateway bot through tanjun.Client.from_gateway_bot, this enables both slash (interaction) and message command execution:</p> <pre><code>bot = hikari.GatewayBot(\"BOT_TOKEN\")\n\n# As a note, unless event_managed=False is passed here then this client\n# will be managed based on gateway startup and stopping events.\n# mention_prefix=True instructs the client to also set mention prefixes on the\n# first startup.\nclient = tanjun.Client.from_gateway_bot(bot, declare_global_commands=True, mention_prefix=True)\n\ncomponent = tanjun.Component()\nclient.add_component(component)\n\n# Declare a message command with some basic parser logic.\n@component.with_command\n@tanjun.with_greedy_argument(\"name\", default=\"World\")\n@tanjun.as_message_command(\"test\")\nasync def test_command(ctx: tanjun.abc.Context, name: str) -&gt; None:\n    await ctx.respond(f\"Hello, {name}!\")\n\n# Declare a ping slash command\n@component.with_command\n@tanjun.with_user_slash_option(\"user\", \"The user facing command option's description\", default=None)\n@tanjun.as_slash_command(\"hello\", \"The command's user facing description\")\nasync def hello(ctx: tanjun.abc.Context, user: hikari.User | None) -&gt; None:\n    user = user or ctx.author\n    await ctx.respond(f\"Hello, {user}!\")\n</code></pre> <p>Alternatively, the client can also be built from a RESTBot but this will only enable slash (interaction) command execution:</p> <pre><code>bot = hikari.RESTBot(\"BOT_TOKEN\", \"Bot\")\n\n# declare_global_commands=True instructs the client to set the global commands\n# for the relevant bot on first startup (this will replace any previously\n# declared commands).\n#\n# `bot_managed=True` has to be explicitly passed here to indicate that the client\n# should automatically start when the linked REST bot starts.\nclient = tanjun.Client.from_rest_bot(bot, bot_managed=True, declare_global_commands=True)\n\n# This will load components from modules based on loader functions.\n# For more information on this see [tanjun.as_loader][].\nclient.load_modules(\"module.paths\")\n\n# Thanks to `bot_managed=True`, this will also start the client.\nbot.run()\n</code></pre> <p>For more extensive examples see the repository's examples.</p> <p>There are also written tutorials that cover making a bot from scratch through to advanced concepts like Dependency Injection.</p>"},{"location":"reference/#tanjun.AnyHooks","title":"AnyHooks  <code>module-attribute</code>","text":"<pre><code>AnyHooks = Hooks[tanjun.Context]\n</code></pre> <p>Hooks that can be used with any context.</p> <p>Note</p> <p>This is shorthand for <code>Hooks[tanjun.abc.Context]</code>.</p>"},{"location":"reference/#tanjun.MenuHooks","title":"MenuHooks  <code>module-attribute</code>","text":"<pre><code>MenuHooks = Hooks[tanjun.MenuContext]\n</code></pre> <p>Hooks that can be used with a menu context.</p> <p>Note</p> <p>This is shorthand for <code>Hooks[tanjun.abc.MenuContext]</code>.</p>"},{"location":"reference/#tanjun.MessageHooks","title":"MessageHooks  <code>module-attribute</code>","text":"<pre><code>MessageHooks = Hooks[tanjun.MessageContext]\n</code></pre> <p>Hooks that can be used with a message context.</p> <p>Note</p> <p>This is shorthand for <code>Hooks[tanjun.abc.MessageContext]</code>.</p>"},{"location":"reference/#tanjun.MissingDependencyError","title":"MissingDependencyError  <code>module-attribute</code>","text":"<pre><code>MissingDependencyError = alluka.MissingDependencyError\n</code></pre> <p>Type alias of alluka.MissingDependencyError.</p>"},{"location":"reference/#tanjun.SlashHooks","title":"SlashHooks  <code>module-attribute</code>","text":"<pre><code>SlashHooks = Hooks[tanjun.SlashContext]\n</code></pre> <p>Hooks that can be used with a slash context.</p> <p>Note</p> <p>This is shorthand for <code>Hooks[tanjun.abc.SlashContext]</code>.</p>"},{"location":"reference/#tanjun.to_channel","title":"to_channel  <code>module-attribute</code>","text":"<pre><code>to_channel: typing.Final[ToChannel] = ToChannel()\n</code></pre> <p>Convert user input to a hikari.channels.PartialChannel object.</p>"},{"location":"reference/#tanjun.to_colour","title":"to_colour  <code>module-attribute</code>","text":"<pre><code>to_colour: typing.Final[collections.Callable[[_SnowflakeIsh], hikari.Color]] = to_color\n</code></pre> <p>Convert user input to a hikari.colors.Color object.</p>"},{"location":"reference/#tanjun.to_emoji","title":"to_emoji  <code>module-attribute</code>","text":"<pre><code>to_emoji: typing.Final[ToEmoji] = ToEmoji()\n</code></pre> <p>Convert user input to a cached hikari.emojis.KnownCustomEmoji object.</p> <p>Note</p> <p>If you just want to convert input to a hikari.emojis.Emoji, hikari.emojis.CustomEmoji or hikari.emojis.UnicodeEmoji without making any cache or REST calls then you can just use the relevant hikari.emojis.Emoji.parse, hikari.emojis.CustomEmoji.parse or hikari.emojis.UnicodeEmoji.parse methods.</p>"},{"location":"reference/#tanjun.to_guild","title":"to_guild  <code>module-attribute</code>","text":"<pre><code>to_guild: typing.Final[ToGuild] = ToGuild()\n</code></pre> <p>Convert user input to a hikari.guilds.Guild object.</p>"},{"location":"reference/#tanjun.to_invite","title":"to_invite  <code>module-attribute</code>","text":"<pre><code>to_invite: typing.Final[ToInvite] = ToInvite()\n</code></pre> <p>Convert user input to a cached hikari.invites.InviteWithMetadata object.</p>"},{"location":"reference/#tanjun.to_invite_with_metadata","title":"to_invite_with_metadata  <code>module-attribute</code>","text":"<pre><code>to_invite_with_metadata: typing.Final[ToInviteWithMetadata] = ToInviteWithMetadata()\n</code></pre> <p>Convert user input to a hikari.invites.Invite object.</p>"},{"location":"reference/#tanjun.to_member","title":"to_member  <code>module-attribute</code>","text":"<pre><code>to_member: typing.Final[ToMember] = ToMember()\n</code></pre> <p>Convert user input to a hikari.guilds.Member object.</p>"},{"location":"reference/#tanjun.to_message","title":"to_message  <code>module-attribute</code>","text":"<pre><code>to_message: typing.Final[ToMessage] = ToMessage()\n</code></pre> <p>Convert user input to a hikari.messages.Message object.</p>"},{"location":"reference/#tanjun.to_presence","title":"to_presence  <code>module-attribute</code>","text":"<pre><code>to_presence: typing.Final[ToPresence] = ToPresence()\n</code></pre> <p>Convert user input to a cached hikari.presences.MemberPresence.</p>"},{"location":"reference/#tanjun.to_role","title":"to_role  <code>module-attribute</code>","text":"<pre><code>to_role: typing.Final[ToRole] = ToRole()\n</code></pre> <p>Convert user input to a hikari.guilds.Role object.</p>"},{"location":"reference/#tanjun.to_snowflake","title":"to_snowflake  <code>module-attribute</code>","text":"<pre><code>to_snowflake: typing.Final[collections.Callable[[_SnowflakeIsh], hikari.Snowflake]] = parse_snowflake\n</code></pre> <p>Convert user input to a hikari.snowflakes.Snowflake.</p> <p>Note</p> <p>This also range validates the input.</p>"},{"location":"reference/#tanjun.to_user","title":"to_user  <code>module-attribute</code>","text":"<pre><code>to_user: typing.Final[ToUser] = ToUser()\n</code></pre> <p>Convert user input to a hikari.users.User object.</p>"},{"location":"reference/#tanjun.to_voice_state","title":"to_voice_state  <code>module-attribute</code>","text":"<pre><code>to_voice_state: typing.Final[ToVoiceState] = ToVoiceState()\n</code></pre> <p>Convert user input to a cached hikari.voices.VoiceState.</p>"},{"location":"reference/#tanjun.BucketResource","title":"BucketResource","text":"<p>         Bases: <code>int</code>, <code>enum.Enum</code></p> <p>Resource target types used within command calldowns and concurrency limiters.</p>"},{"location":"reference/#tanjun.dependencies.limiters.BucketResource.CHANNEL","title":"CHANNEL  <code>class-attribute</code>","text":"<pre><code>CHANNEL = 2\n</code></pre> <p>A per-channel resource bucket.</p>"},{"location":"reference/#tanjun.dependencies.limiters.BucketResource.GLOBAL","title":"GLOBAL  <code>class-attribute</code>","text":"<pre><code>GLOBAL = 7\n</code></pre> <p>A global resource bucket.</p>"},{"location":"reference/#tanjun.dependencies.limiters.BucketResource.GUILD","title":"GUILD  <code>class-attribute</code>","text":"<pre><code>GUILD = 6\n</code></pre> <p>A per-guild resource bucket.</p> <p>When executed in a DM this will be per-DM.</p>"},{"location":"reference/#tanjun.dependencies.limiters.BucketResource.MEMBER","title":"MEMBER  <code>class-attribute</code>","text":"<pre><code>MEMBER = 1\n</code></pre> <p>A per-guild member resource bucket.</p> <p>When executed in a DM this will be per-DM.</p>"},{"location":"reference/#tanjun.dependencies.limiters.BucketResource.PARENT_CHANNEL","title":"PARENT_CHANNEL  <code>class-attribute</code>","text":"<pre><code>PARENT_CHANNEL = 3\n</code></pre> <p>A per-parent channel resource bucket.</p> <p>For DM channels this will be per-DM, for guild channels with no parents this'll be per-guild.</p>"},{"location":"reference/#tanjun.dependencies.limiters.BucketResource.TOP_ROLE","title":"TOP_ROLE  <code>class-attribute</code>","text":"<pre><code>TOP_ROLE = 5\n</code></pre> <p>A per-highest role resource bucket.</p> <p>When executed in a DM this will be per-DM, with this defaulting to targeting the @everyone role if they have no real roles.</p>"},{"location":"reference/#tanjun.dependencies.limiters.BucketResource.USER","title":"USER  <code>class-attribute</code>","text":"<pre><code>USER = 0\n</code></pre> <p>A per-user resource bucket.</p>"},{"location":"reference/#tanjun.Client","title":"Client","text":"<p>         Bases: <code>tanjun.Client</code></p> <p>Tanjun's standard tanjun.abc.Client implementation.</p> <p>This implementation supports dependency injection for checks, command callbacks, prefix getters and event listeners. For more information on how this works see alluka.</p> <p>When manually managing the lifetime of the client the linked rest app or bot must always be started before the Tanjun client.</p> <p>Note</p> <p>By default this client includes a parser error handling hook which will by overwritten if you call tanjun.Client.set_hooks.</p>"},{"location":"reference/#tanjun.clients.Client.checks","title":"checks  <code>property</code>","text":"<pre><code>checks: collections.Collection[tanjun.AnyCheckSig]\n</code></pre> <p>Collection of the level tanjun.abc.Context checks registered to this client.</p> <p>Note</p> <p>These may be taking advantage of the standard dependency injection.</p>"},{"location":"reference/#tanjun.clients.Client.hooks","title":"hooks  <code>property</code>","text":"<pre><code>hooks: typing.Optional[tanjun.AnyHooks]\n</code></pre> <p>Top level tanjun.abc.AnyHooks set for this client.</p> <p>These are called during both message, menu and slash command execution.</p>"},{"location":"reference/#tanjun.clients.Client.interaction_accepts","title":"interaction_accepts  <code>property</code>","text":"<pre><code>interaction_accepts: InteractionAcceptsEnum\n</code></pre> <p>The types of interactions this client is executing.</p>"},{"location":"reference/#tanjun.clients.Client.is_human_only","title":"is_human_only  <code>property</code>","text":"<pre><code>is_human_only: bool\n</code></pre> <p>Whether this client is only executing for non-bot/webhook users messages.</p>"},{"location":"reference/#tanjun.clients.Client.menu_hooks","title":"menu_hooks  <code>property</code>","text":"<pre><code>menu_hooks: typing.Optional[tanjun.MenuHooks]\n</code></pre> <p>Top level tanjun.abc.MenuHooks set for this client.</p> <p>These are only called during menu command execution.</p>"},{"location":"reference/#tanjun.clients.Client.message_accepts","title":"message_accepts  <code>property</code>","text":"<pre><code>message_accepts: MessageAcceptsEnum\n</code></pre> <p>Type of message create events this command client accepts for execution.</p>"},{"location":"reference/#tanjun.clients.Client.message_hooks","title":"message_hooks  <code>property</code>","text":"<pre><code>message_hooks: typing.Optional[tanjun.MessageHooks]\n</code></pre> <p>Top level tanjun.abc.MessageHooks set for this client.</p> <p>These are only called during message command execution.</p>"},{"location":"reference/#tanjun.clients.Client.prefix_getter","title":"prefix_getter  <code>property</code>","text":"<pre><code>prefix_getter: typing.Optional[PrefixGetterSig]\n</code></pre> <p>Prefix getter method set for this client.</p> <p>For more information on this callback's signature see tanjun.clients.PrefixGetterSig.</p>"},{"location":"reference/#tanjun.clients.Client.prefixes","title":"prefixes  <code>property</code>","text":"<pre><code>prefixes: collections.Collection[str]\n</code></pre> <p>Collection of the standard prefixes set for this client.</p>"},{"location":"reference/#tanjun.clients.Client.slash_hooks","title":"slash_hooks  <code>property</code>","text":"<pre><code>slash_hooks: typing.Optional[tanjun.SlashHooks]\n</code></pre> <p>Top level tanjun.abc.SlashHooks set for this client.</p> <p>These are only called during slash command execution.</p>"},{"location":"reference/#tanjun.clients.Client.__init__","title":"__init__","text":"<pre><code>__init__(rest, *, cache=None, events=None, server=None, shards=None, voice=None, event_managed=False, injector=None, mention_prefix=False, set_global_commands=False, declare_global_commands=False, command_ids=None, message_ids=None, user_ids=None, _stack_level=0)\n</code></pre> <p>Initialise a Tanjun client.</p> <p>Note</p> <p>For a quicker way to initiate this client around a standard bot aware client, see tanjun.Client.from_gateway_bot and tanjun.Client.from_rest_bot.</p> PARAMETER DESCRIPTION <code>rest</code> <p>The Hikari REST client this will use.</p> <p> TYPE: <code>hikari.api.RESTClient</code> </p> <code>cache</code> <p>The Hikari cache client this will use if applicable.</p> <p> TYPE: <code>typing.Optional[hikari.api.Cache]</code> DEFAULT: <code>None</code> </p> <code>events</code> <p>The Hikari event manager client this will use if applicable.</p> <p>This is necessary for message command dispatch and will also be necessary for interaction command dispatch if <code>server</code> isn't provided.</p> <p> TYPE: <code>typing.Optional[hikari.api.EventManager]</code> DEFAULT: <code>None</code> </p> <code>server</code> <p>The Hikari interaction server client this will use if applicable.</p> <p>This is used for interaction command dispatch if interaction events aren't being received from the event manager.</p> <p> TYPE: <code>typing.Optional[hikari.api.InteractionServer]</code> DEFAULT: <code>None</code> </p> <code>shards</code> <p>The Hikari shard aware client this will use if applicable.</p> <p> TYPE: <code>typing.Optional[hikari.ShardAware]</code> DEFAULT: <code>None</code> </p> <code>voice</code> <p>The Hikari voice component this will use if applicable.</p> <p> TYPE: <code>typing.Optional[hikari.api.VoiceComponent]</code> DEFAULT: <code>None</code> </p> <code>event_managed</code> <p>Whether or not this client is managed by the event manager.</p> <p>An event managed client will be automatically started and closed based on Hikari's lifetime events.</p> <p>This can only be passed as True if <code>events</code> is also provided.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>injector</code> <p>The alluka client this should use for dependency injection.</p> <p>If not provided then the client will initialise its own DI client.</p> <p> TYPE: <code>typing.Optional[alluka.abc.Client]</code> DEFAULT: <code>None</code> </p> <code>mention_prefix</code> <p>Whether or not mention prefixes should be automatically set when this client is first started.</p> <p>It should be noted that this only applies to message commands.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>declare_global_commands</code> <p>Whether or not to automatically set global slash commands when this client is first started.</p> <p>If one or more guild objects/IDs are passed here then the registered global commands will be set on the specified guild(s) at startup rather than globally.</p> <p>The endpoint this uses has a strict ratelimit which, as of writing, only allows for 2 requests per minute (with that ratelimit either being per-guild if targeting a specific guild otherwise globally).</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialGuild], hikari.SnowflakeishOr[hikari.PartialGuild], bool]</code> DEFAULT: <code>False</code> </p> <code>command_ids</code> <p>If provided, a mapping of top level command names to IDs of the existing commands to update.</p> <p>This will be used for all application commands but in cases where commands have overlapping names, <code>message_ids</code> and <code>user_ids</code> will take priority over this for their relevant command type.</p> <p>This field is complementary to <code>declare_global_commands</code> and, while it isn't necessarily required, this will in some situations help avoid permissions which were previously set for a command from being lost after a rename.</p> <p>This currently isn't supported when multiple guild IDs are passed for <code>declare_global_commands</code>.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p> <code>message_ids</code> <p>If provided, a mapping of message context menu command names to the IDs of existing commands to update.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p> <code>user_ids</code> <p>If provided, a mapping of user context menu command names to the IDs of existing commands to update.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises for the following reasons:</p> <ul> <li>If <code>event_managed</code> is <code>True</code> when <code>event_manager</code> is <code>None</code>.</li> <li>If <code>command_ids</code> is passed when multiple guild ids are provided for <code>declare_global_commands</code>.</li> <li>If <code>command_ids</code> is passed when <code>declare_global_commands</code> is <code>False</code>.</li> </ul>"},{"location":"reference/#tanjun.clients.Client.add_check","title":"add_check","text":"<pre><code>add_check(*checks)\n</code></pre> <p>Add a generic check to this client.</p> <p>This will be applied to both message and slash command execution.</p> PARAMETER DESCRIPTION <code>*checks</code> <p>The checks to add. These may be either synchronous or asynchronous and must take one positional argument of type tanjun.abc.Context with dependency injection being supported for its keyword arguments.</p> <p> TYPE: <code>tanjun.AnyCheckSig</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/#tanjun.clients.Client.add_component","title":"add_component","text":"<pre><code>add_component(component)\n</code></pre> <p>Add a component to this client.</p> PARAMETER DESCRIPTION <code>component</code> <p>The component to move to this client.</p> <p> TYPE: <code>tanjun.Component</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to allow chained calls.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the component's name is already registered.</p>"},{"location":"reference/#tanjun.clients.Client.add_prefix","title":"add_prefix","text":"<pre><code>add_prefix(prefixes)\n</code></pre> <p>Add a prefix used to filter message command calls.</p> <p>This will be matched against the first character(s) in a message's content to determine whether the message command search stage of execution should be initiated.</p> PARAMETER DESCRIPTION <code>prefixes</code> <p>Either a single string or an iterable of strings to be used as prefixes.</p> <p> TYPE: <code>typing.Union[collections.Iterable[str], str]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/#tanjun.clients.Client.close","title":"close  <code>async</code>","text":"<pre><code>close(*, deregister_listeners=True)\n</code></pre> <p>Close the client.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the client isn't running.</p>"},{"location":"reference/#tanjun.clients.Client.fetch_rest_application_id","title":"fetch_rest_application_id  <code>async</code>","text":"<pre><code>fetch_rest_application_id()\n</code></pre> <p>Fetch the ID of the application this client is linked to.</p> RETURNS DESCRIPTION <code>hikari.Snowflake</code> <p>The application ID of the application this client is linked to.</p>"},{"location":"reference/#tanjun.clients.Client.from_gateway_bot","title":"from_gateway_bot  <code>classmethod</code>","text":"<pre><code>from_gateway_bot(bot, /, *, event_managed=True, injector=None, mention_prefix=False, declare_global_commands=False, set_global_commands=False, command_ids=None, message_ids=None, user_ids=None)\n</code></pre> <p>Build a tanjun.Client from a gateway bot.</p> <p>Note</p> <p>This defaults the client to human only mode and sets type dependency injectors for the hikari traits present in <code>bot</code>.</p> PARAMETER DESCRIPTION <code>bot</code> <p>The bot client to build from.</p> <p>This will be used to infer the relevant Hikari clients to use.</p> <p> TYPE: <code>hikari.traits.ShardAware</code> </p> <code>event_managed</code> <p>Whether or not this client is managed by the event manager.</p> <p>An event managed client will be automatically started and closed based on Hikari's lifetime events.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>injector</code> <p>The alluka client this should use for dependency injection.</p> <p>If not provided then the client will initialise its own DI client.</p> <p> TYPE: <code>typing.Optional[alluka.abc.Client]</code> DEFAULT: <code>None</code> </p> <code>mention_prefix</code> <p>Whether or not mention prefixes should be automatically set when this client is first started.</p> <p>It should be noted that this only applies to message commands.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>declare_global_commands</code> <p>Whether or not to automatically set global slash commands when this client is first started.</p> <p>If one or more guild objects/IDs are passed here then the registered global commands will be set on the specified guild(s) at startup rather than globally.</p> <p>The endpoint this uses has a strict ratelimit which, as of writing, only allows for 2 requests per minute (with that ratelimit either being per-guild if targeting a specific guild otherwise globally).</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialGuild], hikari.SnowflakeishOr[hikari.PartialGuild], bool]</code> DEFAULT: <code>False</code> </p> <code>command_ids</code> <p>If provided, a mapping of top level command names to IDs of the commands to update.</p> <p>This field is complementary to <code>declare_global_commands</code> and, while it isn't necessarily required, this will in some situations help avoid permissions which were previously set for a command from being lost after a rename.</p> <p>This currently isn't supported when multiple guild IDs are passed for <code>declare_global_commands</code>.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p> <code>message_ids</code> <p>If provided, a mapping of message context menu command names to the IDs of existing commands to update.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p> <code>user_ids</code> <p>If provided, a mapping of user context menu command names to the IDs of existing commands to update.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/#tanjun.clients.Client.from_rest_bot","title":"from_rest_bot  <code>classmethod</code>","text":"<pre><code>from_rest_bot(bot, /, *, bot_managed=False, declare_global_commands=False, injector=None, set_global_commands=False, command_ids=None, message_ids=None, user_ids=None)\n</code></pre> <p>Build a tanjun.Client from a hikari.traits.RESTBotAware instance.</p> <p>Note</p> <p>This sets type dependency injectors for the hikari traits present in <code>bot</code> (including hikari.traits.RESTBotAware).</p> PARAMETER DESCRIPTION <code>bot</code> <p>The bot client to build from.</p> <p> TYPE: <code>hikari.RESTBotAware</code> </p> <code>declare_global_commands</code> <p>Whether or not to automatically set global slash commands when this client is first started.</p> <p>If one or more guild objects/IDs are passed here then the registered global commands will be set on the specified guild(s) at startup rather than globally.</p> <p>The endpoint this uses has a strict ratelimit which, as of writing, only allows for 2 requests per minute (with that ratelimit either being per-guild if targeting a specific guild otherwise globally).</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialGuild], hikari.SnowflakeishOr[hikari.PartialGuild], bool]</code> DEFAULT: <code>False</code> </p> <code>bot_managed</code> <p>Whether the client should be managed by the REST bot.</p> <p>A REST bot managed client will be automatically started and closed based on the REST bot's startup and shutdown callbacks.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>injector</code> <p>The alluka client this should use for dependency injection.</p> <p>If not provided then the client will initialise its own DI client.</p> <p> TYPE: <code>typing.Optional[alluka.abc.Client]</code> DEFAULT: <code>None</code> </p> <code>command_ids</code> <p>If provided, a mapping of top level command names to IDs of the existing commands to update.</p> <p>This will be used for all application commands but in cases where commands have overlapping names, <code>message_ids</code> and <code>user_ids</code> will take priority over this for their relevant command type.</p> <p>This field is complementary to <code>declare_global_commands</code> and, while it isn't necessarily required, this will in some situations help avoid permissions which were previously set for a command from being lost after a rename.</p> <p>This currently isn't supported when multiple guild IDs are passed for <code>declare_global_commands</code>.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p> <code>message_ids</code> <p>If provided, a mapping of message context menu command names to the IDs of existing commands to update.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p> <code>user_ids</code> <p>If provided, a mapping of user context menu command names to the IDs of existing commands to update.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/#tanjun.clients.Client.on_autocomplete_interaction_request","title":"on_autocomplete_interaction_request  <code>async</code>","text":"<pre><code>on_autocomplete_interaction_request(interaction)\n</code></pre> <p>Execute a command autocomplete based on received REST requests.</p> PARAMETER DESCRIPTION <code>interaction</code> <p>The interaction to execute autocomplete based on.</p> <p> TYPE: <code>hikari.AutocompleteInteraction</code> </p> RETURNS DESCRIPTION <code>hikari.api.InteractionAutocompleteBuilder</code> <p>The initial response to send back to Discord.</p>"},{"location":"reference/#tanjun.clients.Client.on_command_interaction_request","title":"on_command_interaction_request  <code>async</code>","text":"<pre><code>on_command_interaction_request(interaction)\n</code></pre> <p>Execute an app command based on received REST requests.</p> PARAMETER DESCRIPTION <code>interaction</code> <p>The interaction to execute a command based on.</p> <p> TYPE: <code>hikari.CommandInteraction</code> </p> RETURNS DESCRIPTION <code>hikari.api.InteractionMessageBuilder | hikari.api.InteractionDeferredBuilder | hikari.api.InteractionModalBuilder</code> <p>The initial response to send back to Discord.</p>"},{"location":"reference/#tanjun.clients.Client.on_gateway_autocomplete_create","title":"on_gateway_autocomplete_create  <code>async</code>","text":"<pre><code>on_gateway_autocomplete_create(interaction)\n</code></pre> <p>Execute command autocomplete based on a received gateway interaction create.</p> PARAMETER DESCRIPTION <code>interaction</code> <p>The interaction to execute a command based on.</p> <p> TYPE: <code>hikari.AutocompleteInteraction</code> </p>"},{"location":"reference/#tanjun.clients.Client.on_gateway_command_create","title":"on_gateway_command_create  <code>async</code>","text":"<pre><code>on_gateway_command_create(interaction)\n</code></pre> <p>Execute an app command based on a received gateway interaction create.</p> PARAMETER DESCRIPTION <code>interaction</code> <p>The interaction to execute a command based on.</p> <p> TYPE: <code>hikari.CommandInteraction</code> </p>"},{"location":"reference/#tanjun.clients.Client.on_interaction_create_event","title":"on_interaction_create_event  <code>async</code>","text":"<pre><code>on_interaction_create_event(event)\n</code></pre> <p>Handle a gateway interaction create event.</p> <p>This will execute both application command and autocomplete interactions.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to execute commands based on.</p> <p> TYPE: <code>hikari.InteractionCreateEvent</code> </p>"},{"location":"reference/#tanjun.clients.Client.on_message_create_event","title":"on_message_create_event  <code>async</code>","text":"<pre><code>on_message_create_event(event)\n</code></pre> <p>Execute a message command based on a gateway event.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to handle.</p> <p> TYPE: <code>hikari.MessageCreateEvent</code> </p>"},{"location":"reference/#tanjun.clients.Client.open","title":"open  <code>async</code>","text":"<pre><code>open(*, register_listeners=True)\n</code></pre> <p>Start the client.</p> <p>If <code>mention_prefix</code> was passed to tanjun.Client.__init__ or tanjun.Client.from_gateway_bot then this function may make a fetch request to Discord if it cannot get the current user from the cache.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the client is already active.</p>"},{"location":"reference/#tanjun.clients.Client.remove_check","title":"remove_check","text":"<pre><code>remove_check(check)\n</code></pre> <p>Remove a check from the client.</p> PARAMETER DESCRIPTION <code>check</code> <p>The check to remove.</p> <p> TYPE: <code>tanjun.AnyCheckSig</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the check was not previously added.</p>"},{"location":"reference/#tanjun.clients.Client.remove_prefix","title":"remove_prefix","text":"<pre><code>remove_prefix(prefix)\n</code></pre> <p>Remove a message content prefix from the client.</p> PARAMETER DESCRIPTION <code>prefix</code> <p>The prefix to remove.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the prefix is not registered with the client.</p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/#tanjun.clients.Client.set_auto_defer_after","title":"set_auto_defer_after","text":"<pre><code>set_auto_defer_after(time)\n</code></pre> <p>Set when this client should automatically defer execution of commands.</p> <p>Warning</p> <p>If <code>time</code> is set to None then automatic deferrals will be disabled. This may lead to unexpected behaviour.</p> PARAMETER DESCRIPTION <code>time</code> <p>The time in seconds to defer interaction command responses after.</p> <p> TYPE: <code>typing.Optional[float]</code> </p>"},{"location":"reference/#tanjun.clients.Client.set_autocomplete_ctx_maker","title":"set_autocomplete_ctx_maker","text":"<pre><code>set_autocomplete_ctx_maker(maker=context.AutocompleteContext)\n</code></pre> <p>Set the autocomplete context maker to use when creating contexts.</p> <p>Warning</p> <p>The caller must return an instance of tanjun.context.AutocompleteContext rather than just any implementation of the AutocompleteContext abc due to this client relying on implementation detail of tanjun.context.AutocompleteContext.</p> PARAMETER DESCRIPTION <code>maker</code> <p>The autocomplete context maker to use.</p> <p>This is a callback which should match the signature of tanjun.context.AutocompleteContext.init and return an instance of tanjun.context.AutocompleteContext.</p> <p> TYPE: <code>_AutocompleteContextMakerProto</code> DEFAULT: <code>context.AutocompleteContext</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This client to enable method chaining.</p>"},{"location":"reference/#tanjun.clients.Client.set_case_sensitive","title":"set_case_sensitive","text":"<pre><code>set_case_sensitive(state)\n</code></pre> <p>Set whether this client defaults to being case sensitive for message commands.</p> PARAMETER DESCRIPTION <code>state</code> <p>Whether this client's message commands should be matched case-sensitively.</p> <p>This may be overridden by component specific configuration.</p> <p> TYPE: <code>bool</code> </p>"},{"location":"reference/#tanjun.clients.Client.set_default_app_command_permissions","title":"set_default_app_command_permissions","text":"<pre><code>set_default_app_command_permissions(permissions)\n</code></pre> <p>Set the default member permissions needed for this client's commands.</p> <p>Warning</p> <p>This may be overridden by guild staff and does not apply to admins.</p> PARAMETER DESCRIPTION <code>permissions</code> <p>The default member permissions needed for this client's application commands.</p> <p>This may be overridden by tanjun.abc.AppCommand.default_member_permissions and tanjun.abc.Component.default_app_cmd_permissions; if this is left as None then this config will be inherited from the parent client.</p> <p> TYPE: <code>typing.Union[int, hikari.Permissions]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This client to enable method chaining.</p>"},{"location":"reference/#tanjun.clients.Client.set_dms_enabled_for_app_cmds","title":"set_dms_enabled_for_app_cmds","text":"<pre><code>set_dms_enabled_for_app_cmds(state)\n</code></pre> <p>Set whether this clients's commands should be enabled in DMs.</p> PARAMETER DESCRIPTION <code>state</code> <p>Whether to enable this client's commands in DMs.</p> <p>This may be overridden by tanjun.abc.AppCommand.is_dm_enabled and tanjun.abc.Component.dms_enabled_for_app_cmds; if this is left as None then this config will be inherited from the parent client.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This client to enable method chaining.</p>"},{"location":"reference/#tanjun.clients.Client.set_ephemeral_default","title":"set_ephemeral_default","text":"<pre><code>set_ephemeral_default(state)\n</code></pre> <p>Set whether slash contexts spawned by this client should default to ephemeral responses.</p> <p>This defaults to False if not explicitly set.</p> PARAMETER DESCRIPTION <code>state</code> <p>Whether slash command contexts executed in this client should should default to ephemeral.</p> <p>This will be overridden by any response calls which specify flags.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This client to enable method chaining.</p>"},{"location":"reference/#tanjun.clients.Client.set_global_commands","title":"set_global_commands  <code>async</code>","text":"<pre><code>set_global_commands(*, application=None, guild=hikari.UNDEFINED, force=False)\n</code></pre> <p>Alias of tanjun.Client.declare_global_commands.</p> <p>deprecated</p> <p>Since v2.1.1a1; use tanjun.Client.declare_global_commands instead.</p>"},{"location":"reference/#tanjun.clients.Client.set_hikari_trait_injectors","title":"set_hikari_trait_injectors","text":"<pre><code>set_hikari_trait_injectors(bot)\n</code></pre> <p>Set type based dependency injection based on the hikari traits found in <code>bot</code>.</p> <p>This is a short hand for calling tanjun.Client.add_type_dependency for all the hikari trait types <code>bot</code> is valid for with bot.</p> PARAMETER DESCRIPTION <code>bot</code> <p>The hikari client to set dependency injectors for.</p> <p> TYPE: <code>hikari.RESTAware</code> </p>"},{"location":"reference/#tanjun.clients.Client.set_hooks","title":"set_hooks","text":"<pre><code>set_hooks(hooks)\n</code></pre> <p>Set the general command execution hooks for this client.</p> <p>The callbacks within this hook will be added to every slash and message command execution started by this client.</p> PARAMETER DESCRIPTION <code>hooks</code> <p>The general command execution hooks to set for this client.</p> <p>Passing None will remove all hooks.</p> <p> TYPE: <code>typing.Optional[tanjun.AnyHooks]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/#tanjun.clients.Client.set_human_only","title":"set_human_only","text":"<pre><code>set_human_only(value=True)\n</code></pre> <p>Set whether or not message commands execution should be limited to \"human\" users.</p> <p>Note</p> <p>This doesn't apply to interaction commands as these can only be triggered by a \"human\" (normal user account).</p> PARAMETER DESCRIPTION <code>value</code> <p>Whether or not message commands execution should be limited to \"human\" users.</p> <p>Passing True here will prevent message commands from being executed based on webhook and bot messages.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"reference/#tanjun.clients.Client.set_interaction_accepts","title":"set_interaction_accepts","text":"<pre><code>set_interaction_accepts(accepts)\n</code></pre> <p>Set the kind of interactions this client should execute.</p> PARAMETER DESCRIPTION <code>accepts</code> <p>Bitfield of the interaction types this client should execute.</p> <p> TYPE: <code>InteractionAcceptsEnum</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If called while the client is running.</p>"},{"location":"reference/#tanjun.clients.Client.set_interaction_not_found","title":"set_interaction_not_found","text":"<pre><code>set_interaction_not_found(message)\n</code></pre> <p>Set the response message for when an interaction command is not found.</p> <p>Warning</p> <p>Setting this to None may lead to unexpected behaviour (especially when the client is still set to auto-defer interactions) and should only be done if you know what you're doing.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message to respond with when an interaction command isn't found.</p> <p> TYPE: <code>typing.Optional[str]</code> </p>"},{"location":"reference/#tanjun.clients.Client.set_menu_ctx_maker","title":"set_menu_ctx_maker","text":"<pre><code>set_menu_ctx_maker(maker=context.MenuContext)\n</code></pre> <p>Set the autocomplete context maker to use when creating contexts.</p> <p>Warning</p> <p>The caller must return an instance of tanjun.context.MenuContext rather than just any implementation of the MenuContext abc due to this client relying on implementation detail of tanjun.context.MenuContext.</p> PARAMETER DESCRIPTION <code>maker</code> <p>The autocomplete context maker to use.</p> <p>This is a callback which should match the signature of tanjun.context.MenuContext.init and return an instance of tanjun.context.MenuContext.</p> <p> TYPE: <code>_MenuContextMakerProto</code> DEFAULT: <code>context.MenuContext</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This client to enable method chaining.</p>"},{"location":"reference/#tanjun.clients.Client.set_menu_hooks","title":"set_menu_hooks","text":"<pre><code>set_menu_hooks(hooks)\n</code></pre> <p>Set the menu command execution hooks for this client.</p> <p>The callbacks within this hook will be added to every menu command execution started by this client.</p> PARAMETER DESCRIPTION <code>hooks</code> <p>The menu context specific command execution hooks to set for this client.</p> <p>Passing None will remove the hooks.</p> <p> TYPE: <code>typing.Optional[tanjun.MenuHooks]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/#tanjun.clients.Client.set_menu_not_found","title":"set_menu_not_found","text":"<pre><code>set_menu_not_found(message)\n</code></pre> <p>Set the response message for when a menu command is not found.</p> <p>Warning</p> <p>Setting this to None may lead to unexpected behaviour (especially when the client is still set to auto-defer interactions) and should only be done if you know what you're doing.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message to respond with when a menu command isn't found.</p> <p> TYPE: <code>typing.Optional[str]</code> </p>"},{"location":"reference/#tanjun.clients.Client.set_message_accepts","title":"set_message_accepts","text":"<pre><code>set_message_accepts(accepts)\n</code></pre> <p>Set the kind of messages commands should be executed based on.</p> PARAMETER DESCRIPTION <code>accepts</code> <p>The type of messages commands should be executed based on.</p> <p> TYPE: <code>MessageAcceptsEnum</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If called while the client is running.</p> <code>ValueError</code> <p>If <code>accepts</code> is set to anything other than tanjun.clients.MessageAcceptsEnum.NONE when the client doesn't have a linked event manager.</p>"},{"location":"reference/#tanjun.clients.Client.set_message_ctx_maker","title":"set_message_ctx_maker","text":"<pre><code>set_message_ctx_maker(maker=context.MessageContext)\n</code></pre> <p>Set the message context maker to use when creating context for a message.</p> <p>Warning</p> <p>The caller must return an instance of tanjun.context.MessageContext rather than just any implementation of the MessageContext abc due to this client relying on implementation detail of tanjun.context.MessageContext.</p> PARAMETER DESCRIPTION <code>maker</code> <p>The message context maker to use.</p> <p>This is a callback which should match the signature of tanjun.context.MessageContext.__init__ and return an instance of tanjun.context.MessageContext.</p> <p> TYPE: <code>_MessageContextMakerProto</code> DEFAULT: <code>context.MessageContext</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This client to enable method chaining.</p>"},{"location":"reference/#tanjun.clients.Client.set_message_hooks","title":"set_message_hooks","text":"<pre><code>set_message_hooks(hooks)\n</code></pre> <p>Set the message command execution hooks for this client.</p> <p>The callbacks within this hook will be added to every message command execution started by this client.</p> PARAMETER DESCRIPTION <code>hooks</code> <p>The message context specific command execution hooks to set for this client.</p> <p>Passing None will remove all hooks.</p> <p> TYPE: <code>typing.Optional[tanjun.MessageHooks]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/#tanjun.clients.Client.set_prefix_getter","title":"set_prefix_getter","text":"<pre><code>set_prefix_getter(getter)\n</code></pre> <p>Set the callback used to retrieve message prefixes set for the relevant guild.</p> PARAMETER DESCRIPTION <code>getter</code> <p>The callback which'll be used to retrieve prefixes for the guild a message context is from. If None is passed here then the callback will be unset.</p> <p>This should be an async callback which one argument of type tanjun.abc.MessageContext and returns an iterable of string prefixes. Dependency injection is supported for this callback's keyword arguments.</p> <p> TYPE: <code>typing.Optional[PrefixGetterSig]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/#tanjun.clients.Client.set_slash_ctx_maker","title":"set_slash_ctx_maker","text":"<pre><code>set_slash_ctx_maker(maker=context.SlashContext)\n</code></pre> <p>Set the slash context maker to use when creating context for a slash command.</p> <p>Warning</p> <p>The caller must return an instance of tanjun.context.SlashContext rather than just any implementation of the SlashContext abc due to this client relying on implementation detail of tanjun.context.SlashContext.</p> PARAMETER DESCRIPTION <code>maker</code> <p>The slash context maker to use.</p> <p>This is a callback which should match the signature of tanjun.context.SlashContext.__init__ and return an instance of tanjun.context.SlashContext.</p> <p> TYPE: <code>_SlashContextMakerProto</code> DEFAULT: <code>context.SlashContext</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This client to enable method chaining.</p>"},{"location":"reference/#tanjun.clients.Client.set_slash_hooks","title":"set_slash_hooks","text":"<pre><code>set_slash_hooks(hooks)\n</code></pre> <p>Set the slash command execution hooks for this client.</p> <p>The callbacks within this hook will be added to every slash command execution started by this client.</p> PARAMETER DESCRIPTION <code>hooks</code> <p>The slash context specific command execution hooks to set for this client.</p> <p>Passing None will remove the hooks.</p> <p> TYPE: <code>typing.Optional[tanjun.SlashHooks]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/#tanjun.clients.Client.set_slash_not_found","title":"set_slash_not_found","text":"<pre><code>set_slash_not_found(message)\n</code></pre> <p>Set the response message for when a slash command is not found.</p> <p>Warning</p> <p>Setting this to None may lead to unexpected behaviour (especially when the client is still set to auto-defer interactions) and should only be done if you know what you're doing.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message to respond with when a slash command isn't found.</p> <p> TYPE: <code>typing.Optional[str]</code> </p>"},{"location":"reference/#tanjun.clients.Client.with_check","title":"with_check","text":"<pre><code>with_check(check)\n</code></pre> <p>Add a check to this client through a decorator call.</p> PARAMETER DESCRIPTION <code>check</code> <p>The check to add. This may be either synchronous or asynchronous and must take one positional argument of type tanjun.abc.Context with dependency injection being supported for its keyword arguments.</p> <p> TYPE: <code>tanjun.abc.CheckSig</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.CheckSig</code> <p>The added check.</p>"},{"location":"reference/#tanjun.clients.Client.with_prefix_getter","title":"with_prefix_getter","text":"<pre><code>with_prefix_getter(getter)\n</code></pre> <p>Set the prefix getter callback for this client through decorator call.</p> <p>Examples:</p> <pre><code>client = tanjun.Client.from_rest_bot(bot)\n\n@client.with_prefix_getter\nasync def prefix_getter(ctx: tanjun.abc.MessageContext) -&gt; collections.abc.Iterable[str]:\n    raise NotImplementedError\n</code></pre> PARAMETER DESCRIPTION <code>getter</code> <p>The callback which'll be  to retrieve prefixes for the guild a message event is from.</p> <p>This should be an async callback which one argument of type tanjun.abc.MessageContext and returns an iterable of string prefixes. Dependency injection is supported for this callback's keyword arguments.</p> <p> TYPE: <code>PrefixGetterSig</code> </p> RETURNS DESCRIPTION <code>PrefixGetterSig</code> <p>The registered callback.</p>"},{"location":"reference/#tanjun.ClientCallbackNames","title":"ClientCallbackNames","text":"<p>         Bases: <code>str</code>, <code>enum.Enum</code></p> <p>Enum of the standard client callback names.</p> <p>These should be dispatched by all tanjun.abc.Client implementations.</p>"},{"location":"reference/#tanjun.abc.ClientCallbackNames.CLOSED","title":"CLOSED  <code>class-attribute</code>","text":"<pre><code>CLOSED = 'closed'\n</code></pre> <p>Called when the client has finished closing.</p> <p>No positional arguments are provided for this event.</p>"},{"location":"reference/#tanjun.abc.ClientCallbackNames.CLOSING","title":"CLOSING  <code>class-attribute</code>","text":"<pre><code>CLOSING = 'closing'\n</code></pre> <p>Called when the client is initially instructed to close.</p> <p>No positional arguments are provided for this event.</p>"},{"location":"reference/#tanjun.abc.ClientCallbackNames.COMPONENT_ADDED","title":"COMPONENT_ADDED  <code>class-attribute</code>","text":"<pre><code>COMPONENT_ADDED = 'component_added'\n</code></pre> <p>Called when a component is added to an active client.</p> <p>Warning</p> <p>This event isn't dispatched for components which were registered while the client is inactive.</p> <p>The first positional argument is the tanjun.abc.Component being added.</p>"},{"location":"reference/#tanjun.abc.ClientCallbackNames.COMPONENT_REMOVED","title":"COMPONENT_REMOVED  <code>class-attribute</code>","text":"<pre><code>COMPONENT_REMOVED = 'component_removed'\n</code></pre> <p>Called when a component is added to an active client.</p> <p>Warning</p> <p>This event isn't dispatched for components which were removed while the client is inactive.</p> <p>The first positional argument is the tanjun.abc.Component being removed.</p>"},{"location":"reference/#tanjun.abc.ClientCallbackNames.MENU_COMMAND_NOT_FOUND","title":"MENU_COMMAND_NOT_FOUND  <code>class-attribute</code>","text":"<pre><code>MENU_COMMAND_NOT_FOUND = 'menu_command_not_found'\n</code></pre> <p>Called when a menu command is not found.</p> <p>tanjun.abc.MenuContext is provided as the first positional argument.</p>"},{"location":"reference/#tanjun.abc.ClientCallbackNames.MESSAGE_COMMAND_NOT_FOUND","title":"MESSAGE_COMMAND_NOT_FOUND  <code>class-attribute</code>","text":"<pre><code>MESSAGE_COMMAND_NOT_FOUND = 'message_command_not_found'\n</code></pre> <p>Called when a message command is not found.</p> <p>tanjun.abc.MessageContext is provided as the first positional argument.</p>"},{"location":"reference/#tanjun.abc.ClientCallbackNames.SLASH_COMMAND_NOT_FOUND","title":"SLASH_COMMAND_NOT_FOUND  <code>class-attribute</code>","text":"<pre><code>SLASH_COMMAND_NOT_FOUND = 'slash_command_not_found'\n</code></pre> <p>Called when a slash command is not found.</p> <p>tanjun.abc.SlashContext is provided as the first positional argument.</p>"},{"location":"reference/#tanjun.abc.ClientCallbackNames.STARTED","title":"STARTED  <code>class-attribute</code>","text":"<pre><code>STARTED = 'started'\n</code></pre> <p>Called when the client has finished starting.</p> <p>No positional arguments are provided for this event.</p>"},{"location":"reference/#tanjun.abc.ClientCallbackNames.STARTING","title":"STARTING  <code>class-attribute</code>","text":"<pre><code>STARTING = 'starting'\n</code></pre> <p>Called when the client is initially instructed to start.</p> <p>No positional arguments are provided for this event.</p>"},{"location":"reference/#tanjun.CommandError","title":"CommandError","text":"<p>         Bases: <code>TanjunError</code></p> <p>An error which is sent as a response to the command call.</p>"},{"location":"reference/#tanjun.errors.CommandError.attachments","title":"attachments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attachments = [attachment] if attachment else attachments\n</code></pre> <p>Sequence of the attachments to be sent as a response to the command, if set.</p>"},{"location":"reference/#tanjun.errors.CommandError.components","title":"components  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>components = [component] if component else components\n</code></pre> <p>Sequence of the components to be sent as a response to the command, if set.</p>"},{"location":"reference/#tanjun.errors.CommandError.content","title":"content  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>content = content\n</code></pre> <p>The response error message's content.</p>"},{"location":"reference/#tanjun.errors.CommandError.delete_after","title":"delete_after  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delete_after = delete_after\n</code></pre> <p>The seconds after which the response message should be deleted, if set.</p>"},{"location":"reference/#tanjun.errors.CommandError.embeds","title":"embeds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>embeds = [embed] if embed else embeds\n</code></pre> <p>Sequence of the embeds to be sent as a response to the command, if set.</p>"},{"location":"reference/#tanjun.errors.CommandError.mentions_everyone","title":"mentions_everyone  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mentions_everyone = mentions_everyone\n</code></pre> <p>Whether or not the response should be allowed to mention <code>@everyone</code>/<code>@here</code>.</p>"},{"location":"reference/#tanjun.errors.CommandError.role_mentions","title":"role_mentions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>role_mentions = role_mentions\n</code></pre> <p>Configuration for the response's allowed role mentions.</p> <p>If this is a sequence then the response will only be allowed to mention roles in the sequence.</p> <p>If this is a bool then the response will only be allowed to mention roles if the value is <code>True</code>.</p>"},{"location":"reference/#tanjun.errors.CommandError.user_mentions","title":"user_mentions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user_mentions = user_mentions\n</code></pre> <p>Configuration for the response's allowed user mentions.</p> <p>If this is a sequence then the response will only be allowed to mention users in the sequence.</p> <p>If this is a bool then the response will only be allowed to mention users if the value is <code>True</code>.</p>"},{"location":"reference/#tanjun.errors.CommandError.__init__","title":"__init__","text":"<pre><code>__init__(content=hikari.UNDEFINED, *, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Initialise a command error.</p> PARAMETER DESCRIPTION <code>content</code> <p>The content to respond with.</p> <p>If provided, the message contents. If hikari.undefined.UNDEFINED, then nothing will be sent in the content.</p> <p> TYPE: <code>hikari.UndefinedOr[typing.Any]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>delete_after</code> <p>If provided, the seconds after which the response message should be deleted.</p> <p>Slash command responses can only be deleted within 15 minutes of the command being received.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, float, int, None]</code> DEFAULT: <code>None</code> </p> <code>attachment</code> <p>A singular attachment to respond with.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Resourceish]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachments</code> <p>A sequence of attachments to respond with.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Resourceish]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>component</code> <p>If provided, builder object of the component to include in this response.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.api.ComponentBuilder]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>components</code> <p>If provided, a sequence of the component builder objects to include in this response.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.api.ComponentBuilder]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embed</code> <p>An embed to respond with.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Embed]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embeds</code> <p>A sequence of embeds to respond with.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Embed]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>mentions_everyone</code> <p>If provided, whether the message should parse @everyone/@here mentions.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>user_mentions</code> <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.users.PartialUser derivatives to enforce mentioning specific users.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialUser], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>role_mentions</code> <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialRole], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>Raised for any of the following reasons:</p> <ul> <li>When both <code>attachment</code> and <code>attachments</code> are provided.</li> <li>When both <code>component</code> and <code>components</code> are passed.</li> <li>When both <code>embed</code> and <code>embeds</code> are passed.</li> <li>If more than 100 entries are passed for <code>role_mentions</code>.</li> <li>If more than 100 entries are passed for <code>user_mentions</code>.</li> </ul>"},{"location":"reference/#tanjun.errors.CommandError.send","title":"send  <code>async</code>","text":"<pre><code>send(ctx, /, *, ensure_result=False)\n</code></pre> <p>Send this error as a command response.</p> PARAMETER DESCRIPTION <code>ctx</code> <p>The command call context to respond to.</p> <p> TYPE: <code>tanjun.Context</code> </p> <code>ensure_result</code> <p>Ensure that this call will always return a message object.</p> <p>If True then this will always return hikari.messages.Message, otherwise this will return <code>hikari.Message | None</code>.</p> <p>It's worth noting that, under certain scenarios within the slash command flow, this may lead to an extre request being made.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>delete_after</code> would be more than 15 minutes after the slash command was called.</p> <code>hikari.BadRequestError</code> <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> <code>hikari.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.ForbiddenError</code> <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> <code>hikari.NotFoundError</code> <p>If the channel is not found.</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/#tanjun.Component","title":"Component","text":"<p>         Bases: <code>tanjun.Component</code></p> <p>Standard implementation of tanjun.abc.Component.</p> <p>This is a collcetion of commands (both message and slash), hooks and listener callbacks which can be added to a generic client.</p> <p>Note</p> <p>This implementation supports dependency injection for its checks, command callbacks and listeners when linked to a client which supports dependency injection.</p>"},{"location":"reference/#tanjun.components.Component.checks","title":"checks  <code>property</code>","text":"<pre><code>checks: collections.Collection[tanjun.AnyCheckSig]\n</code></pre> <p>Collection of the checks being run against every command execution in this component.</p>"},{"location":"reference/#tanjun.components.Component.hooks","title":"hooks  <code>property</code>","text":"<pre><code>hooks: typing.Optional[tanjun.AnyHooks]\n</code></pre> <p>The general command hooks set for this component, if any.</p>"},{"location":"reference/#tanjun.components.Component.menu_hooks","title":"menu_hooks  <code>property</code>","text":"<pre><code>menu_hooks: typing.Optional[tanjun.MenuHooks]\n</code></pre> <p>The menu command hooks set for this component, if any.</p>"},{"location":"reference/#tanjun.components.Component.message_hooks","title":"message_hooks  <code>property</code>","text":"<pre><code>message_hooks: typing.Optional[tanjun.MessageHooks]\n</code></pre> <p>The message command hooks set for this component, if any.</p>"},{"location":"reference/#tanjun.components.Component.schedules","title":"schedules  <code>property</code>","text":"<pre><code>schedules: collections.Collection[schedules_.AbstractSchedule]\n</code></pre> <p>Collection of the schedules registered to this component.</p>"},{"location":"reference/#tanjun.components.Component.slash_hooks","title":"slash_hooks  <code>property</code>","text":"<pre><code>slash_hooks: typing.Optional[tanjun.SlashHooks]\n</code></pre> <p>The slash command hooks set for this component, if any.</p>"},{"location":"reference/#tanjun.components.Component.__init__","title":"__init__","text":"<pre><code>__init__(*, name=None, strict=False)\n</code></pre> <p>Initialise a new component.</p> PARAMETER DESCRIPTION <code>name</code> <p>The component's identifier.</p> <p>If not provided then this will be a random string.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>strict</code> <p>Whether this component should use a stricter (more optimal) approach for message command search.</p> <p>When this is True, message command names will not be allowed to contain spaces and will have to be unique to one command within the component.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"reference/#tanjun.components.Component.add_check","title":"add_check","text":"<pre><code>add_check(*checks)\n</code></pre> <p>Add a command check to this component to be used for all its commands.</p> PARAMETER DESCRIPTION <code>*checks</code> <p>The checks to add.</p> <p> TYPE: <code>tanjun.AnyCheckSig</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This component to enable method chaining.</p>"},{"location":"reference/#tanjun.components.Component.add_client_callback","title":"add_client_callback","text":"<pre><code>add_client_callback(name, /, *callbacks)\n</code></pre> <p>Add a client callback.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name this callback is being registered to.</p> <p>This is case-insensitive.</p> <p> TYPE: <code>typing.Union[str, tanjun.ClientCallbackNames]</code> </p> <code>*callbacks</code> <p>The callbacks to register.</p> <p>These may be sync or async and must return None. The positional and keyword arguments a callback should expect depend on implementation detail around the <code>name</code> being subscribed to.</p> <p> TYPE: <code>tanjun.MetaEventSig</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/#tanjun.components.Component.add_command","title":"add_command","text":"<pre><code>add_command(command)\n</code></pre> <p>Add a command to this component.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add.</p> <p> TYPE: <code>tanjun.ExecutableCommand[typing.Any]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The current component to allow for chaining.</p>"},{"location":"reference/#tanjun.components.Component.add_message_command","title":"add_message_command","text":"<pre><code>add_message_command(command)\n</code></pre> <p>Add a message command to the component.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add.</p> <p> TYPE: <code>tanjun.MessageCommand[typing.Any]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The component to allow method chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If one of the command's name is already registered in a strict component.</p>"},{"location":"reference/#tanjun.components.Component.add_on_close","title":"add_on_close","text":"<pre><code>add_on_close(*callbacks)\n</code></pre> <p>Add a close callback to this component.</p> <p>Note</p> <p>Unlike the closing and closed client callbacks, this is only called for the current component's lifetime and is guaranteed to be called regardless of when the component was added to a client.</p> PARAMETER DESCRIPTION <code>*callbacks</code> <p>The close callbacks to add to this component.</p> <p>This should take no positional arguments, return None and may take use injected dependencies.</p> <p> TYPE: <code>OnCallbackSig</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The component object to enable call chaining.</p>"},{"location":"reference/#tanjun.components.Component.add_on_open","title":"add_on_open","text":"<pre><code>add_on_open(*callbacks)\n</code></pre> <p>Add a open callback to this component.</p> <p>Note</p> <p>Unlike the starting and started client callbacks, this is only called for the current component's lifetime and is guaranteed to be called regardless of when the component was added to a client.</p> PARAMETER DESCRIPTION <code>*callbacks</code> <p>The open callbacks to add to this component.</p> <p>These should take no positional arguments, return None and may request injected dependencies.</p> <p> TYPE: <code>OnCallbackSig</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The component object to enable call chaining.</p>"},{"location":"reference/#tanjun.components.Component.add_schedule","title":"add_schedule","text":"<pre><code>add_schedule(schedule)\n</code></pre> <p>Add a schedule to the component.</p> PARAMETER DESCRIPTION <code>schedule</code> <p>The schedule to add.</p> <p> TYPE: <code>schedules_.AbstractSchedule</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The component itself for chaining.</p>"},{"location":"reference/#tanjun.components.Component.get_client_callbacks","title":"get_client_callbacks","text":"<pre><code>get_client_callbacks(name)\n</code></pre> <p>Get a collection of the callbacks registered for a specific name.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name to get the callbacks registered for.</p> <p>This is case-insensitive.</p> <p> TYPE: <code>typing.Union[str, tanjun.ClientCallbackNames]</code> </p> RETURNS DESCRIPTION <code>collections.abc.Collection[MetaEventSig]</code> <p>Collection of the callbacks for the provided name.</p>"},{"location":"reference/#tanjun.components.Component.load_from_scope","title":"load_from_scope","text":"<pre><code>load_from_scope(*, include_globals=False, scope=None)\n</code></pre> <p>Load entries such as top-level commands into the component from the calling scope.</p> <p>Note</p> <p>This will load schedules which support and commands AbstractComponentLoader (all standard implementations support this) and will ignore commands which are owned by command groups.</p> <p>Note</p> <p>This will detect entries from the calling scope which implement tanjun.components.AbstractComponentLoader unless <code>scope</code> is passed but this isn't possible in a stack-less python implementation; in stack-less environments the scope will have to be explicitly passed as <code>scope</code>.</p> PARAMETER DESCRIPTION <code>include_globals</code> <p>Whether to include global variables (along with local) while detecting from the calling scope.</p> <p>This cannot be True when <code>scope</code> is provided and will only ever be needed when the local scope is different from the global scope.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>scope</code> <p>The scope to detect entries which implement tanjun.components.AbstractComponentLoader from.</p> <p>This overrides the default usage of stackframe introspection.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, typing.Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The current component to allow for chaining.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If this is called in a python implementation which doesn't support stack frame inspection when <code>scope</code> is not provided.</p> <code>ValueError</code> <p>If <code>scope</code> is provided when <code>include_globals</code> is True.</p>"},{"location":"reference/#tanjun.components.Component.make_loader","title":"make_loader","text":"<pre><code>make_loader(*, copy=True)\n</code></pre> <p>Make a loader/unloader for this component.</p> <p>This enables loading, unloading and reloading of this component into a client by targeting the module using tanjun.Client.load_modules, tanjun.Client.unload_modules and tanjun.Client.reload_modules.</p> PARAMETER DESCRIPTION <code>copy</code> <p>Whether to copy the component before loading it into a client.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.ClientLoader</code> <p>The loader for this component.</p>"},{"location":"reference/#tanjun.components.Component.remove_check","title":"remove_check","text":"<pre><code>remove_check(check)\n</code></pre> <p>Remove a command check from this component.</p> PARAMETER DESCRIPTION <code>check</code> <p>The check to remove.</p> <p> TYPE: <code>tanjun.AnyCheckSig</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This component to enable method chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the check is not registered with this component.</p>"},{"location":"reference/#tanjun.components.Component.remove_client_callback","title":"remove_client_callback","text":"<pre><code>remove_client_callback(name, callback)\n</code></pre> <p>Remove a client callback.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name this callback is being registered to.</p> <p>This is case-insensitive.</p> <p> TYPE: <code>str</code> </p> <code>callback</code> <p>The callback to remove from the client's callbacks.</p> <p> TYPE: <code>tanjun.MetaEventSig</code> </p> RAISES DESCRIPTION <code>KeyError</code> <p>If the provided name isn't found.</p> <code>ValueError</code> <p>If the provided callback isn't found.</p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/#tanjun.components.Component.remove_command","title":"remove_command","text":"<pre><code>remove_command(command)\n</code></pre> <p>Remove a command from this component.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to remove.</p> <p> TYPE: <code>tanjun.ExecutableCommand[typing.Any]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This component to enable method chaining.</p>"},{"location":"reference/#tanjun.components.Component.remove_schedule","title":"remove_schedule","text":"<pre><code>remove_schedule(schedule)\n</code></pre> <p>Remove a schedule from the component.</p> PARAMETER DESCRIPTION <code>schedule</code> <p>The schedule to remove</p> <p> TYPE: <code>schedules_.AbstractSchedule</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The component itself for chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the schedule isn't registered.</p>"},{"location":"reference/#tanjun.components.Component.set_case_sensitive","title":"set_case_sensitive","text":"<pre><code>set_case_sensitive(state)\n</code></pre> <p>Set whether this component defaults to being case sensitive for component.</p> PARAMETER DESCRIPTION <code>state</code> <p>Whether this component's message commands should be matched case-sensitively.</p> <p>If this is left as None then the client's case-sensitive setting will be used.</p> <p> TYPE: <code>typing.Optional[bool]</code> </p>"},{"location":"reference/#tanjun.components.Component.set_default_app_command_permissions","title":"set_default_app_command_permissions","text":"<pre><code>set_default_app_command_permissions(permissions)\n</code></pre> <p>Set the default member permissions needed for this component's commands.</p> <p>Warning</p> <p>This may be overridden by guild staff and does not apply to admins.</p> PARAMETER DESCRIPTION <code>permissions</code> <p>The default member permissions needed for this component's application commands.</p> <p>If this is left as None then this config will be inherited from the parent client.</p> <p>This may be overridden by tanjun.abc.AppCommand.default_member_permissions and if this is left as None then this config will be inherited from the parent client.</p> <p> TYPE: <code>typing.Union[int, hikari.Permissions, None]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This client to enable method chaining.</p>"},{"location":"reference/#tanjun.components.Component.set_dms_enabled_for_app_cmds","title":"set_dms_enabled_for_app_cmds","text":"<pre><code>set_dms_enabled_for_app_cmds(state)\n</code></pre> <p>Set whether this component's commands should be enabled in DMs.</p> PARAMETER DESCRIPTION <code>state</code> <p>Whether to enable this component's commands in DMs.</p> <p>This may be overridden by tanjun.abc.AppCommand.is_dm_enabled and if this is left as None then this config will be inherited from the parent client.</p> <p> TYPE: <code>typing.Optional[bool]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This client to enable method chaining.</p>"},{"location":"reference/#tanjun.components.Component.set_ephemeral_default","title":"set_ephemeral_default","text":"<pre><code>set_ephemeral_default(state)\n</code></pre> <p>Set whether slash contexts executed in this component should default to ephemeral responses.</p> PARAMETER DESCRIPTION <code>state</code> <p>Whether slash command contexts executed in this component should should default to ephemeral. This will be overridden by any response calls which specify flags.</p> <p>Setting this to None will let the default set on the parent client propagate and decide the ephemeral default behaviour.</p> <p> TYPE: <code>typing.Optional[bool]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This component to enable method chaining.</p>"},{"location":"reference/#tanjun.components.Component.set_hooks","title":"set_hooks","text":"<pre><code>set_hooks(hooks)\n</code></pre> <p>Set hooks to be called during the execution of all of this component's commands.</p> PARAMETER DESCRIPTION <code>hooks</code> <p>The command hooks to set.</p> <p> TYPE: <code>typing.Optional[tanjun.AnyHooks]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This component to enable method chaining.</p>"},{"location":"reference/#tanjun.components.Component.set_menu_hooks","title":"set_menu_hooks","text":"<pre><code>set_menu_hooks(hooks)\n</code></pre> <p>Set hooks to be called during the execution of this component's menu commands.</p> PARAMETER DESCRIPTION <code>hooks</code> <p>The menu command hooks to set.</p> <p> TYPE: <code>typing.Optional[tanjun.MenuHooks]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This component to enable method chaining.</p>"},{"location":"reference/#tanjun.components.Component.set_message_hooks","title":"set_message_hooks","text":"<pre><code>set_message_hooks(hooks)\n</code></pre> <p>Set hooks to be called during the execution of this component's message commands.</p> PARAMETER DESCRIPTION <code>hooks</code> <p>The message command hooks to set.</p> <p> TYPE: <code>typing.Optional[tanjun.MessageHooks]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This component to enable method chaining.</p>"},{"location":"reference/#tanjun.components.Component.set_slash_hooks","title":"set_slash_hooks","text":"<pre><code>set_slash_hooks(hooks)\n</code></pre> <p>Set hooks to be called during the execution of this component's slash commands.</p> PARAMETER DESCRIPTION <code>hooks</code> <p>The slash command hooks to set.</p> <p> TYPE: <code>typing.Optional[tanjun.SlashHooks]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This component to enable method chaining.</p>"},{"location":"reference/#tanjun.components.Component.with_check","title":"with_check","text":"<pre><code>with_check(check)\n</code></pre> <p>Add a general command check to this component through a decorator call.</p> PARAMETER DESCRIPTION <code>check</code> <p>The check to add.</p> <p> TYPE: <code>tanjun.abc.CheckSig</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.CheckSig</code> <p>The added check.</p>"},{"location":"reference/#tanjun.components.Component.with_client_callback","title":"with_client_callback","text":"<pre><code>with_client_callback(name)\n</code></pre> <p>Add a client callback through a decorator call.</p> <p>Examples:</p> <pre><code>client = tanjun.Client.from_rest_bot(bot)\n\n@client.with_client_callback(\"closed\")\nasync def on_close() -&gt; None:\n    raise NotImplementedError\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>The name this callback is being registered to.</p> <p>This is case-insensitive.</p> <p> TYPE: <code>typing.Union[str, tanjun.ClientCallbackNames]</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MetaEventSig], tanjun.abc.MetaEventSig]</code> <p>Decorator callback used to register the client callback.</p> <p>This may be sync or async and must return None. The positional and keyword arguments a callback should expect depend on implementation detail around the <code>name</code> being subscribed to.</p>"},{"location":"reference/#tanjun.components.Component.with_command","title":"with_command","text":"<pre><code>with_command(command=None, /, *, copy=False, follow_wrapped=False)\n</code></pre> <p>Add a command to this component through a decorator call.</p> <p>Examples:</p> <p>This may be used inconjunction with tanjun.as_slash_command and tanjun.as_message_command.</p> <pre><code>@component.with_command\n@tanjun.with_slash_str_option(\"option_name\", \"option description\")\n@tanjun.as_slash_command(\"command_name\", \"command description\")\nasync def slash_command(ctx: tanjun.abc.Context, arg: str) -&gt; None:\n    await ctx.respond(f\"Hi {arg}\")\n</code></pre> <pre><code>@component.with_command\n@tanjun.with_argument(\"argument_name\")\n@tanjun.as_message_command(\"command_name\")\nasync def message_command(ctx: tanjun.abc.Context, arg: str) -&gt; None:\n    await ctx.respond(f\"Hi {arg}\")\n</code></pre> PARAMETER DESCRIPTION <code>command</code> <p>The command to add to this component.</p> <p> TYPE: <code>typing.Optional[_CommandT]</code> DEFAULT: <code>None</code> </p> <code>copy</code> <p>Whether to copy the command before adding it to this component.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>follow_wrapped</code> <p>Whether to also add any commands <code>command</code> wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.ExecutableCommand</code> <p>The added command.</p>"},{"location":"reference/#tanjun.components.Component.with_on_close","title":"with_on_close","text":"<pre><code>with_on_close(callback)\n</code></pre> <p>Add a close callback to this component through a decorator call.</p> <p>Note</p> <p>Unlike the closing and closed client callbacks, this is only called for the current component's lifetime and is guaranteed to be called regardless of when the component was added to a client.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The close callback to add to this component.</p> <p>This should take no positional arguments, return None and may request injected dependencies.</p> <p> TYPE: <code>OnCallbackSig</code> </p> RETURNS DESCRIPTION <code>OnCallbackSig</code> <p>The added close callback.</p>"},{"location":"reference/#tanjun.components.Component.with_on_open","title":"with_on_open","text":"<pre><code>with_on_open(callback)\n</code></pre> <p>Add a open callback to this component through a decorator call.</p> <p>Note</p> <p>Unlike the starting and started client callbacks, this is only called for the current component's lifetime and is guaranteed to be called regardless of when the component was added to a client.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The open callback to add to this component.</p> <p>This should take no positional arguments, return None and may take use injected dependencies.</p> <p> TYPE: <code>OnCallbackSig</code> </p> RETURNS DESCRIPTION <code>OnCallbackSig</code> <p>The added open callback.</p>"},{"location":"reference/#tanjun.components.Component.with_schedule","title":"with_schedule","text":"<pre><code>with_schedule(schedule)\n</code></pre> <p>Add a schedule to the component through a decorator call.</p>"},{"location":"reference/#tanjun.components.Component.with_schedule--example","title":"Example","text":"<p>This may be used in conjunction with tanjun.as_interval or tanjun.as_time_schedule.</p> <pre><code>@component.with_schedule\n@tanjun.as_interval(60)\nasync def my_schedule():\n    print(\"I'm running every minute!\")\n</code></pre> PARAMETER DESCRIPTION <code>schedule</code> <p>The schedule to add.</p> <p> TYPE: <code>tanjun.schedules.AbstractSchedule</code> </p> RETURNS DESCRIPTION <code>tanjun.schedules.AbstractSchedule</code> <p>The added schedule.</p>"},{"location":"reference/#tanjun.ConversionError","title":"ConversionError","text":"<p>         Bases: <code>ParserError</code></p> <p>Error raised by a parser parameter when it failed to converter a value.</p>"},{"location":"reference/#tanjun.errors.ConversionError.errors","title":"errors  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>errors = tuple(errors)\n</code></pre> <p>Sequence of the errors that were caught during conversion for this parameter.</p>"},{"location":"reference/#tanjun.errors.ConversionError.parameter","title":"parameter  <code>class-attribute</code>","text":"<pre><code>parameter: str\n</code></pre> <p>Name of the parameter this error was raised for.</p>"},{"location":"reference/#tanjun.errors.ConversionError.__init__","title":"__init__","text":"<pre><code>__init__(message, parameter, /, *, errors=())\n</code></pre> <p>Initialise a conversion error.</p> PARAMETER DESCRIPTION <code>parameter</code> <p>The parameter this was raised by.</p> <p> TYPE: <code>str</code> </p> <code>errors</code> <p>An iterable of the source value errors which were raised during conversion.</p> <p> TYPE: <code>collections.Iterable[ValueError]</code> DEFAULT: <code>()</code> </p>"},{"location":"reference/#tanjun.FailedCheck","title":"FailedCheck","text":"<p>         Bases: <code>TanjunError</code>, <code>RuntimeError</code></p> <p>Error raised as an alternative to returning <code>False</code> in a check.</p>"},{"location":"reference/#tanjun.FailedModuleImport","title":"FailedModuleImport","text":"<p>         Bases: <code>FailedModuleLoad</code></p> <p>Error raised when a module failed to import.</p> <p>This is a specialisation of tanjun.errors.FailedModuleLoad.</p>"},{"location":"reference/#tanjun.FailedModuleLoad","title":"FailedModuleLoad","text":"<p>         Bases: <code>TanjunError</code></p> <p>Error raised when a module fails to load.</p> <p>This may be raised by the module failing to import or by one of its loaders erroring.</p> <p>This source error can be accessed at FailedModuleLoad.cause.</p>"},{"location":"reference/#tanjun.errors.FailedModuleLoad.__cause__","title":"__cause__  <code>class-attribute</code>","text":"<pre><code>__cause__: Exception\n</code></pre> <p>The root error.</p>"},{"location":"reference/#tanjun.errors.FailedModuleLoad.path","title":"path  <code>property</code>","text":"<pre><code>path: typing.Union[str, pathlib.Path]\n</code></pre> <p>The path of the module which caused the error.</p>"},{"location":"reference/#tanjun.FailedModuleUnload","title":"FailedModuleUnload","text":"<p>         Bases: <code>TanjunError</code></p> <p>Error raised when a module fails to unload.</p> <p>This may be raised by the module failing to import or by one of its unloaders erroring.</p> <p>The source error can be accessed at FailedModuleUnload.cause.</p>"},{"location":"reference/#tanjun.errors.FailedModuleUnload.__cause__","title":"__cause__  <code>class-attribute</code>","text":"<pre><code>__cause__: Exception\n</code></pre> <p>The root error.</p>"},{"location":"reference/#tanjun.errors.FailedModuleUnload.path","title":"path  <code>property</code>","text":"<pre><code>path: typing.Union[str, pathlib.Path]\n</code></pre> <p>The path of the module which caused the error.</p>"},{"location":"reference/#tanjun.HaltExecution","title":"HaltExecution","text":"<p>         Bases: <code>TanjunError</code></p> <p>Error raised while looking for a command in-order to end-execution early.</p> <p>For the most part, this will be raised during checks in-order to prevent other commands from being tried.</p>"},{"location":"reference/#tanjun.Hooks","title":"Hooks","text":"<p>         Bases: <code>tanjun.Hooks[_ContextT_contra]</code></p> <p>Standard implementation of tanjun.abc.Hooks used for command execution.</p> <p>This will take either tanjun.abc.Context, tanjun.abc.MessageContext or tanjun.abc.SlashContext dependent on what its bound by (generic wise).</p> <p>Note</p> <p>This implementation adds a concept of parser errors which won't be dispatched to general \"error\" hooks and do not share the error suppression semantics as they favour to always suppress the error if a registered handler is found.</p>"},{"location":"reference/#tanjun.hooks.Hooks.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> <p>Initialise a command hook object.</p>"},{"location":"reference/#tanjun.hooks.Hooks.add_to_command","title":"add_to_command","text":"<pre><code>add_to_command(command)\n</code></pre> <p>Add this hook object to a command.</p> <p>Note</p> <p>This will likely override any previously added hooks.</p> <p>Examples:</p> <p>This method may be used as a command decorator:</p> <pre><code>@standard_hooks.add_to_command\n@as_message_command(\"command\")\nasync def command_command(ctx: tanjun.abc.Context) -&gt; None:\n    await ctx.respond(\"You've called a command!\")\n</code></pre> PARAMETER DESCRIPTION <code>command</code> <p>The command to add the hooks to.</p> <p> TYPE: <code>tanjun.abc.ExecutableCommand</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.ExecutableCommand</code> <p>The command with the hooks added.</p>"},{"location":"reference/#tanjun.hooks.Hooks.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Copy this hook object.</p>"},{"location":"reference/#tanjun.hooks.Hooks.set_on_error","title":"set_on_error","text":"<pre><code>set_on_error(callback)\n</code></pre> <p>Set the error callback for this hook object.</p> <p>Note</p> <p>This will not be called for tanjun.ParserErrors as these are generally speaking expected. To handle those see Hooks.set_on_parser_error.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to set for this hook. This will remove any previously set callbacks.</p> <p>This callback should take two positional arguments (of type tanjun.abc.Context and Exception) and may be either synchronous or asynchronous.</p> <p>Returning True indicates that the error should be suppressed, False that it should be re-raised and None that no decision has been made. This will be accounted for along with the decisions other error hooks make by majority rule.</p> <p> TYPE: <code>typing.Optional[tanjun.ErrorHookSig[_ContextT_contra]]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The hook object to enable method chaining.</p>"},{"location":"reference/#tanjun.hooks.Hooks.set_on_parser_error","title":"set_on_parser_error","text":"<pre><code>set_on_parser_error(callback)\n</code></pre> <p>Set the parser error callback for this hook object.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to set for this hook. This will remove any previously set callbacks.</p> <p>This callback should take two positional arguments (of type tanjun.abc.Context and tanjun.ParserError), return None and may be either synchronous or asynchronous.</p> <p>It's worth noting that, unlike general error handlers, this will always suppress the error.</p> <p> TYPE: <code>typing.Optional[tanjun.ParserHookSig[_ContextT_contra]]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The hook object to enable method chaining.</p>"},{"location":"reference/#tanjun.hooks.Hooks.set_on_success","title":"set_on_success","text":"<pre><code>set_on_success(callback)\n</code></pre> <p>Set the success callback for this hook object.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to set for this hook. This will remove any previously set callbacks.</p> <p>This callback should take one positional argument (of type tanjun.abc.Context), return None and may be either synchronous or asynchronous.</p> <p> TYPE: <code>typing.Optional[tanjun.HookSig[_ContextT_contra]]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The hook object to enable method chaining.</p>"},{"location":"reference/#tanjun.hooks.Hooks.set_post_execution","title":"set_post_execution","text":"<pre><code>set_post_execution(callback)\n</code></pre> <p>Set the post-execution callback for this hook object.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to set for this hook. This will remove any previously set callbacks.</p> <p>This callback should take one positional argument (of type tanjun.abc.Context), return None and may be either synchronous or asynchronous.</p> <p> TYPE: <code>typing.Optional[tanjun.HookSig[_ContextT_contra]]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The hook object to enable method chaining.</p>"},{"location":"reference/#tanjun.hooks.Hooks.set_pre_execution","title":"set_pre_execution","text":"<pre><code>set_pre_execution(callback)\n</code></pre> <p>Set the pre-execution callback for this hook object.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to set for this hook. This will remove any previously set callbacks.</p> <p>This callback should take one positional argument (of type tanjun.abc.Context), return None and may be either synchronous or asynchronous.</p> <p> TYPE: <code>typing.Optional[tanjun.HookSig[_ContextT_contra]]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The hook object to enable method chaining.</p>"},{"location":"reference/#tanjun.HotReloader","title":"HotReloader","text":"<p>Manages hot reloading modules for a Tanjun client..</p> <p>Warning</p> <p>An instance of this can only be linked to 1 client.</p> <p>Examples:</p> <pre><code>client = tanjun.Client.from_gateway_bot(bot)\n(\n    tanjun.dependencies.HotReloader()\n    .add_modules(\"python.module.path\", pathlib.Path(\"./module.py\"))\n    .add_directory(\"./modules/\")\n    .add_to_client(client)\n)\n</code></pre>"},{"location":"reference/#tanjun.dependencies.reloaders.HotReloader.__init__","title":"__init__","text":"<pre><code>__init__(*, commands_guild=None, interval=datetime.timedelta(microseconds=500000), redeclare_cmds_after=datetime.timedelta(seconds=10), unload_on_delete=True)\n</code></pre> <p>Initialise a hot reloader.</p> <p>Warning</p> <p><code>redeclare_cmds_after</code> is not aware of commands declared outside of the reloader and will lead to commands being redeclared on startup when mixed with tanjun.clients.Client.__init__'s <code>declare_global_commands</code> argument when it is not None.</p> PARAMETER DESCRIPTION <code>commands_guild</code> <p>Object or ID of the guild to declare commands in if <code>redeclare_cmds_after</code> is not None.</p> <p> TYPE: <code>typing.Optional[hikari.SnowflakeishOr[hikari.PartialGuild]]</code> DEFAULT: <code>None</code> </p> <code>interval</code> <p>How often this should scan files and directories for changes in seconds.</p> <p> TYPE: <code>typing.Union[int, float, datetime.timedelta]</code> DEFAULT: <code>datetime.timedelta(microseconds=500000)</code> </p> <code>redeclare_cmds_after</code> <p>How often to redeclare application commands after a change to the commands is detected.</p> <p>If None is passed here then this will not redeclare the application's commands.</p> <p> TYPE: <code>typing.Union[int, float, datetime.timedelta, None]</code> DEFAULT: <code>datetime.timedelta(seconds=10)</code> </p> <code>unload_on_delete</code> <p>Whether this should unload modules when their relevant file is deleted.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"reference/#tanjun.dependencies.reloaders.HotReloader.add_directory","title":"add_directory","text":"<pre><code>add_directory(directory, /, *, namespace=None)\n</code></pre> <p>Add a directory for this hot reloader to track.</p> <p>Note</p> <p>This will only reload modules directly in the target directory and will not scan sub-directories.</p> PARAMETER DESCRIPTION <code>directory</code> <p>Path of the directory to hot reload.</p> <p> TYPE: <code>typing.Union[str, pathlib.Path]</code> </p> <code>namespace</code> <p>The python namespace this directory's modules should be imported from, if applicable.</p> <p>This work as <code>{namespace}.{file.name.removesuffix(\".py\")}</code> and will have the same behaviour as when a str is passed to tanjun.abc.Client.load_modules if passed.</p> <p>If left as None then this will have the same behaviour as when a pathlib.Path is passed to tanjun.abc.Client.load_modules.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The hot reloader to enable chained calls.</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If the directory cannot be found</p>"},{"location":"reference/#tanjun.dependencies.reloaders.HotReloader.add_directory_async","title":"add_directory_async  <code>async</code>","text":"<pre><code>add_directory_async(directory, /, *, namespace=None)\n</code></pre> <p>Asynchronous variant of tanjun.dependencies.reloaders.HotReloader.add_directory.</p> <p>Unlike tanjun.dependencies.reloaders.HotReloader.add_directory, this method will run blocking code in a background thread.</p> <p>For more information on the behaviour of this method see the documentation for tanjun.dependencies.reloaders.HotReloader.add_directory.</p>"},{"location":"reference/#tanjun.dependencies.reloaders.HotReloader.add_modules","title":"add_modules","text":"<pre><code>add_modules(*paths)\n</code></pre> <p>Add modules for this hot reloader to track.</p> PARAMETER DESCRIPTION <code>*paths</code> <p>Module paths for this hot reloader to track.</p> <p>This has the same behaviour as [tanjun.abc.Client.load_modules][ for how [pathlib.Path][] and str are treated.</p> <p> TYPE: <code>typing.Union[str, pathlib.Path]</code> DEFAULT: <code>()</code> </p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If the module's file doesn't exist anymore.</p> <code>ModuleNotFoundError</code> <p>If the str module path cannot be imported.</p>"},{"location":"reference/#tanjun.dependencies.reloaders.HotReloader.add_modules_async","title":"add_modules_async  <code>async</code>","text":"<pre><code>add_modules_async(*paths)\n</code></pre> <p>Asynchronous variant of tanjun.dependencies.reloaders.HotReloader.add_modules.</p> <p>Unlike tanjun.dependencies.reloaders.HotReloader.add_modules, this method will run blocking code in a background thread.</p> <p>For more information on the behaviour of this method see the documentation for tanjun.abc.Client.load_modules.</p>"},{"location":"reference/#tanjun.dependencies.reloaders.HotReloader.add_to_client","title":"add_to_client","text":"<pre><code>add_to_client(client)\n</code></pre> <p>Add this to a tanjun.abc.Client instance.</p> <p>This registers start and closing callbacks which handle the lifetime of this and adds this as a type dependency.</p> PARAMETER DESCRIPTION <code>client</code> <p>The client to link this hot reloader to.</p> <p> TYPE: <code>tanjun.Client</code> </p>"},{"location":"reference/#tanjun.dependencies.reloaders.HotReloader.scan","title":"scan  <code>async</code>","text":"<pre><code>scan(client)\n</code></pre> <p>Manually scan this hot reloader's tracked modules for changes.</p> PARAMETER DESCRIPTION <code>client</code> <p>The client to reload and unload modules in.</p> <p> TYPE: <code>tanjun.Client</code> </p>"},{"location":"reference/#tanjun.dependencies.reloaders.HotReloader.start","title":"start","text":"<pre><code>start(client)\n</code></pre> <p>Start the hot reloader.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the hot reloader is already running.</p>"},{"location":"reference/#tanjun.dependencies.reloaders.HotReloader.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stop the hot reloader.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the hot reloader isn't running.</p>"},{"location":"reference/#tanjun.InMemoryConcurrencyLimiter","title":"InMemoryConcurrencyLimiter","text":"<p>         Bases: <code>AbstractConcurrencyLimiter</code></p> <p>In-memory standard implementation of AbstractConcurrencyLimiter.</p> <p>Examples:</p> <p>InMemoryConcurrencyLimiter.set_bucket may be used to set the concurrency limits for a specific bucket:</p> <pre><code>(\n    InMemoryConcurrencyLimiter()\n    # Set the default bucket template to 10 concurrent uses of the command per-user.\n    .set_bucket(\"default\", tanjun.BucketResource.USER, 10)\n    # Set the \"moderation\" bucket with a limit of 5 concurrent uses per-guild.\n    .set_bucket(\"moderation\", tanjun.BucketResource.GUILD, 5)\n    .set_bucket()\n    # add_to_client will setup the concurrency manager (setting it as an\n    # injected dependency and registering callbacks to manage it).\n    .add_to_client(client)\n)\n</code></pre>"},{"location":"reference/#tanjun.dependencies.limiters.InMemoryConcurrencyLimiter.add_to_client","title":"add_to_client","text":"<pre><code>add_to_client(client)\n</code></pre> <p>Add this concurrency manager to a tanjun client.</p> <p>Note</p> <p>This registers the manager as a type dependency and manages opening and closing the manager based on the client's life cycle.</p> PARAMETER DESCRIPTION <code>client</code> <p>The client to add this concurrency manager to.</p> <p> TYPE: <code>tanjun.Client</code> </p>"},{"location":"reference/#tanjun.dependencies.limiters.InMemoryConcurrencyLimiter.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Stop the concurrency manager.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the concurrency manager is not running.</p>"},{"location":"reference/#tanjun.dependencies.limiters.InMemoryConcurrencyLimiter.disable_bucket","title":"disable_bucket","text":"<pre><code>disable_bucket(bucket_id)\n</code></pre> <p>Disable a concurrency limit bucket.</p> <p>This will stop the bucket from ever hitting a concurrency limit and also prevents the bucket from defaulting.</p> <p>Note</p> <p>\"default\" is a special <code>bucket_id</code> which is used as a template for unknown bucket IDs.</p> PARAMETER DESCRIPTION <code>bucket_id</code> <p>The bucket to disable.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This concurrency manager to allow for chaining.</p>"},{"location":"reference/#tanjun.dependencies.limiters.InMemoryConcurrencyLimiter.open","title":"open","text":"<pre><code>open(*, _loop=None)\n</code></pre> <p>Start the concurrency manager.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the concurrency manager is already running. If called in a thread with no running event loop.</p>"},{"location":"reference/#tanjun.dependencies.limiters.InMemoryConcurrencyLimiter.set_bucket","title":"set_bucket","text":"<pre><code>set_bucket(bucket_id, resource, limit)\n</code></pre> <p>Set the concurrency limit for a specific bucket.</p> <p>Note</p> <p>\"default\" is a special <code>bucket_id</code> which is used as a template for unknown bucket IDs.</p> PARAMETER DESCRIPTION <code>bucket_id</code> <p>The ID of the bucket to set the concurrency limit for.</p> <p> TYPE: <code>str</code> </p> <code>resource</code> <p>The type of resource to target for the concurrency limit.</p> <p> TYPE: <code>BucketResource</code> </p> <code>limit</code> <p>The maximum number of concurrent uses to allow.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The concurrency manager to allow call chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If an invalid resource type is given. if limit is less 0 or negative.</p>"},{"location":"reference/#tanjun.InMemoryCooldownManager","title":"InMemoryCooldownManager","text":"<p>         Bases: <code>AbstractCooldownManager</code></p> <p>In-memory standard implementation of AbstractCooldownManager.</p> <p>Examples:</p> <p>InMemoryCooldownManager.set_bucket may be used to set the cooldown for a specific bucket:</p> <pre><code>(\n    InMemoryCooldownManager()\n    # Set the default bucket template to a per-user 10 uses per-60 seconds cooldown.\n    .set_bucket(\"default\", tanjun.BucketResource.USER, 10, 60)\n    # Set the \"moderation\" bucket to a per-guild 100 uses per-5 minutes cooldown.\n    .set_bucket(\"moderation\", tanjun.BucketResource.GUILD, 100, datetime.timedelta(minutes=5))\n    .set_bucket()\n    # add_to_client will setup the cooldown manager (setting it as an\n    # injected dependency and registering callbacks to manage it).\n    .add_to_client(client)\n)\n</code></pre>"},{"location":"reference/#tanjun.dependencies.limiters.InMemoryCooldownManager.add_to_client","title":"add_to_client","text":"<pre><code>add_to_client(client)\n</code></pre> <p>Add this cooldown manager to a tanjun client.</p> <p>Note</p> <p>This registers the manager as a type dependency and manages opening and closing the manager based on the client's life cycle.</p> PARAMETER DESCRIPTION <code>client</code> <p>The client to add this cooldown manager to.</p> <p> TYPE: <code>tanjun.Client</code> </p>"},{"location":"reference/#tanjun.dependencies.limiters.InMemoryCooldownManager.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Stop the cooldown manager.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the cooldown manager is not running.</p>"},{"location":"reference/#tanjun.dependencies.limiters.InMemoryCooldownManager.disable_bucket","title":"disable_bucket","text":"<pre><code>disable_bucket(bucket_id)\n</code></pre> <p>Disable a cooldown bucket.</p> <p>This will stop the bucket from ever hitting a cooldown and also prevents the bucket from defaulting.</p> <p>Note</p> <p>\"default\" is a special <code>bucket_id</code> which is used as a template for unknown bucket IDs.</p> PARAMETER DESCRIPTION <code>bucket_id</code> <p>The bucket to disable.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This cooldown manager to allow for chaining.</p>"},{"location":"reference/#tanjun.dependencies.limiters.InMemoryCooldownManager.open","title":"open","text":"<pre><code>open(*, _loop=None)\n</code></pre> <p>Start the cooldown manager.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the cooldown manager is already running. If called in a thread with no running event loop.</p>"},{"location":"reference/#tanjun.dependencies.limiters.InMemoryCooldownManager.set_bucket","title":"set_bucket","text":"<pre><code>set_bucket(bucket_id, resource, limit, reset_after)\n</code></pre> <p>Set the cooldown for a specific bucket.</p> <p>Note</p> <p>\"default\" is a special <code>bucket_id</code> which is used as a template for unknown bucket IDs.</p> PARAMETER DESCRIPTION <code>bucket_id</code> <p>The ID of the bucket to set the cooldown for.</p> <p> TYPE: <code>str</code> </p> <code>resource</code> <p>The type of resource to target for the cooldown.</p> <p> TYPE: <code>BucketResource</code> </p> <code>limit</code> <p>The number of uses per cooldown period.</p> <p> TYPE: <code>int</code> </p> <code>reset_after</code> <p>The cooldown period.</p> <p> TYPE: <code>typing.Union[int, float, datetime.timedelta]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The cooldown manager to allow call chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If an invalid resource type is given. If reset_after or limit are negative, 0 or invalid. if limit is less 0 or negative.</p>"},{"location":"reference/#tanjun.InteractionAcceptsEnum","title":"InteractionAcceptsEnum","text":"<p>         Bases: <code>enum.IntFlag</code></p> <p>The possible configurations for which interaction this client should execute.</p>"},{"location":"reference/#tanjun.clients.InteractionAcceptsEnum.ALL","title":"ALL  <code>class-attribute</code>","text":"<pre><code>ALL = AUTOCOMPLETE | COMMANDS\n</code></pre> <p>Execute all the interaction types Tanjun supports.</p>"},{"location":"reference/#tanjun.clients.InteractionAcceptsEnum.AUTOCOMPLETE","title":"AUTOCOMPLETE  <code>class-attribute</code>","text":"<pre><code>AUTOCOMPLETE = enum.auto()\n</code></pre> <p>Execute autocomplete interactions.</p>"},{"location":"reference/#tanjun.clients.InteractionAcceptsEnum.COMMANDS","title":"COMMANDS  <code>class-attribute</code>","text":"<pre><code>COMMANDS = enum.auto()\n</code></pre> <p>Execute command interactions.</p> <p>This includes slash command and context menu calls.</p>"},{"location":"reference/#tanjun.clients.InteractionAcceptsEnum.NONE","title":"NONE  <code>class-attribute</code>","text":"<pre><code>NONE = 0\n</code></pre> <p>Set the client to execute no interactions.</p>"},{"location":"reference/#tanjun.LazyConstant","title":"LazyConstant","text":"<p>         Bases: <code>typing.Generic[_T]</code></p> <p>Injected type used to hold and generate lazy constants.</p> <p>Note</p> <p>To easily resolve this type use inject_lc.</p>"},{"location":"reference/#tanjun.dependencies.data.LazyConstant.callback","title":"callback  <code>property</code>","text":"<pre><code>callback: alluka.abc.CallbackSig[_T]\n</code></pre> <p>Descriptor of the callback used to get this constant's initial value.</p>"},{"location":"reference/#tanjun.dependencies.data.LazyConstant.__init__","title":"__init__","text":"<pre><code>__init__(callback)\n</code></pre> <p>Initiate a new lazy constant.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback used to resolve this to a constant value.</p> <p>This supports dependency injection and may either be sync or asynchronous.</p> <p> TYPE: <code>alluka.abc.CallbackSig[_T]</code> </p>"},{"location":"reference/#tanjun.dependencies.data.LazyConstant.acquire","title":"acquire","text":"<pre><code>acquire()\n</code></pre> <p>Acquire this lazy constant as an asynchronous lock.</p> <p>This is used to ensure that the value is only generated once and should be kept acquired until LazyConstant.set_value has been called.</p> RETURNS DESCRIPTION <code>contextlib.AbstractAsyncContextManager[typing.Any]</code> <p>Context manager that can be used to acquire the lock.</p>"},{"location":"reference/#tanjun.dependencies.data.LazyConstant.get_value","title":"get_value","text":"<pre><code>get_value()\n</code></pre> <p>Get the value of this constant if set, else None.</p>"},{"location":"reference/#tanjun.dependencies.data.LazyConstant.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Clear the internally stored value.</p>"},{"location":"reference/#tanjun.dependencies.data.LazyConstant.set_value","title":"set_value","text":"<pre><code>set_value(value)\n</code></pre> <p>Set the constant value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to set.</p> <p> TYPE: <code>_T</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the constant has already been set.</p>"},{"location":"reference/#tanjun.MenuCommand","title":"MenuCommand","text":"<p>         Bases: <code>base.PartialCommand[tanjun.MenuContext]</code>, <code>tanjun.MenuCommand[_AnyMenuCallbackSigT, _MenuTypeT]</code></p> <p>Base class used for the standard menu command implementations.</p>"},{"location":"reference/#tanjun.commands.menu.MenuCommand.wrapped_command","title":"wrapped_command  <code>property</code>","text":"<pre><code>wrapped_command: typing.Optional[tanjun.ExecutableCommand[typing.Any]]\n</code></pre> <p>The command object this wraps, if any.</p>"},{"location":"reference/#tanjun.commands.menu.MenuCommand.__init__","title":"__init__","text":"<pre><code>__init__(callback, type_, name, /, *, always_defer=False, default_member_permissions=None, default_to_ephemeral=None, dm_enabled=None, is_global=True, _wrapped_command=None)\n</code></pre> <p>Initialise a user or message menu command.</p> <p>Note</p> <p>Under the standard implementation, <code>is_global</code> is used to determine whether the command should be bulk set by tanjun.Client.declare_global_commands or when <code>declare_global_commands</code> is True</p> <p>Note</p> <p>If you want your first response to be ephemeral while using <code>always_defer</code>, you must set <code>default_to_ephemeral</code> to <code>True</code>.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback to execute when the command is invoked.</p> <p>This should be an asynchronous callback which takes one positional argument of type tanjun.abc.MenuContext, returns None and may use dependency injection to access other services.</p> <p> TYPE: <code>tanjun.abc.MenuCallbackSig</code> </p> <code>type_</code> <p>The type of menu command this is.</p> <p>Only hikari.commands.CommandType.USER and hikari.commands.CommandType.MESSAGE are valid here.</p> <p> TYPE: <code>hikari.commands.CommandType</code> </p> <code>name</code> <p>The command's name (supports localisation).</p> <p>This must be between 1 and 32 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>always_defer</code> <p>Whether the contexts this command is executed with should always be deferred before being passed to the command's callback.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>default_member_permissions</code> <p>Member permissions necessary to utilize this command by default.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Union[hikari.Permissions, int, None]</code> DEFAULT: <code>None</code> </p> <code>default_to_ephemeral</code> <p>Whether this command's responses should default to ephemeral unless flags are set to override this.</p> <p>If this is left as None then the default set on the parent command(s), component or client will be in effect.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>dm_enabled</code> <p>Whether this command is enabled in DMs with the bot.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>is_global</code> <p>Whether this command is a global command.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MenuCallbackSig], MenuCommand]</code> <p>The decorator callback used to make a tanjun.MenuCommand.</p> <p>This can either wrap a raw command callback or another callable command instance (e.g. tanjun.MenuCommand, tanjun.MessageCommand, tanjun.SlashCommand) and will manage loading the other command into a component when using tanjun.Component.load_from_scope.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the command name isn't in the length range of 1 to 32.</li> <li>If the command name has uppercase characters.</li> </ul>"},{"location":"reference/#tanjun.commands.menu.MenuCommand.set_ephemeral_default","title":"set_ephemeral_default","text":"<pre><code>set_ephemeral_default(state)\n</code></pre> <p>Set whether this command's responses should default to ephemeral.</p> PARAMETER DESCRIPTION <code>state</code> <p>Whether this command's responses should default to ephemeral. This will be overridden by any response calls which specify flags.</p> <p>Setting this to None will let the default set on the parent command(s), component or client propagate and decide the ephemeral default for contexts used by this command.</p> <p> TYPE: <code>typing.Optional[bool]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This command to allow for chaining.</p>"},{"location":"reference/#tanjun.MessageAcceptsEnum","title":"MessageAcceptsEnum","text":"<p>         Bases: <code>str</code>, <code>enum.Enum</code></p> <p>The possible configurations for which events tanjun.Client should execute commands based on.</p>"},{"location":"reference/#tanjun.clients.MessageAcceptsEnum.ALL","title":"ALL  <code>class-attribute</code>","text":"<pre><code>ALL = 'ALL'\n</code></pre> <p>Set the client to execute commands based on both DM and guild message create events.</p>"},{"location":"reference/#tanjun.clients.MessageAcceptsEnum.DM_ONLY","title":"DM_ONLY  <code>class-attribute</code>","text":"<pre><code>DM_ONLY = 'DM_ONLY'\n</code></pre> <p>Set the client to execute commands based only DM message create events.</p>"},{"location":"reference/#tanjun.clients.MessageAcceptsEnum.GUILD_ONLY","title":"GUILD_ONLY  <code>class-attribute</code>","text":"<pre><code>GUILD_ONLY = 'GUILD_ONLY'\n</code></pre> <p>Set the client to execute commands based only guild message create events.</p>"},{"location":"reference/#tanjun.clients.MessageAcceptsEnum.NONE","title":"NONE  <code>class-attribute</code>","text":"<pre><code>NONE = 'NONE'\n</code></pre> <p>Set the client to not execute commands based on message create events.</p>"},{"location":"reference/#tanjun.clients.MessageAcceptsEnum.get_event_type","title":"get_event_type","text":"<pre><code>get_event_type()\n</code></pre> <p>Get the base event type this mode listens to.</p> RETURNS DESCRIPTION <code>type[hikari.events.MessageCreateEvent] | None</code> <p>The type object of the MessageCreateEvent class this mode will register a listener for.</p> <p>This will be None if this mode disables listening to message create events.</p>"},{"location":"reference/#tanjun.MessageCommand","title":"MessageCommand","text":"<p>         Bases: <code>base.PartialCommand[tanjun.MessageContext]</code>, <code>tanjun.MessageCommand[_MessageCallbackSigT]</code></p> <p>Standard implementation of a message command.</p>"},{"location":"reference/#tanjun.commands.message.MessageCommand.wrapped_command","title":"wrapped_command  <code>property</code>","text":"<pre><code>wrapped_command: typing.Optional[tanjun.ExecutableCommand[typing.Any]]\n</code></pre> <p>The command object this wraps, if any.</p>"},{"location":"reference/#tanjun.commands.message.MessageCommand.__init__","title":"__init__","text":"<pre><code>__init__(callback, name, /, *names, validate_arg_keys=True, _wrapped_command=None)\n</code></pre> <p>Initialise a message command.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback to execute when the command is invoked.</p> <p>This should be an asynchronous callback which takes one positional argument of type tanjun.abc.MessageContext, returns None and may use dependency injection to access other services.</p> <p> TYPE: <code>tanjun.abc.MessageCallbackSig</code> </p> <code>name</code> <p>The command name.</p> <p> TYPE: <code>str</code> </p> <code>*names</code> <p>Other names for the command.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>validate_arg_keys</code> <p>Whether to validate that option keys match the command callback's signature.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"reference/#tanjun.MessageCommandGroup","title":"MessageCommandGroup","text":"<p>         Bases: <code>MessageCommand[_MessageCallbackSigT]</code>, <code>tanjun.MessageCommandGroup[_MessageCallbackSigT]</code></p> <p>Standard implementation of a message command group.</p>"},{"location":"reference/#tanjun.commands.message.MessageCommandGroup.__init__","title":"__init__","text":"<pre><code>__init__(callback, name, /, *names, strict=False, validate_arg_keys=True, _wrapped_command=None)\n</code></pre> <p>Initialise a message command group.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback to execute when the command is invoked.</p> <p>This should be an asynchronous callback which takes one positional argument of type tanjun.abc.MessageContext, returns None and may use dependency injection to access other services.</p> <p> TYPE: <code>tanjun.abc.MessageCallbackSig</code> </p> <code>name</code> <p>The command name.</p> <p> TYPE: <code>str</code> </p> <code>*names</code> <p>Other names for the command.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>strict</code> <p>Whether this command group should only allow commands without spaces in their names.</p> <p>This allows for a more optimised command search pattern to be used and enforces that command names are unique to a single command within the group.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>validate_arg_keys</code> <p>Whether to validate that option keys match the command callback's signature.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"reference/#tanjun.commands.message.MessageCommandGroup.add_command","title":"add_command","text":"<pre><code>add_command(command)\n</code></pre> <p>Add a command to this group.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add.</p> <p> TYPE: <code>tanjun.MessageCommand[typing.Any]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The group instance to enable chained calls.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If one of the command's names is already registered in a strict command group.</p>"},{"location":"reference/#tanjun.commands.message.MessageCommandGroup.as_sub_command","title":"as_sub_command","text":"<pre><code>as_sub_command(name, /, *names, validate_arg_keys=True)\n</code></pre> <p>Build a message command in this group from a decorated callback.</p> PARAMETER DESCRIPTION <code>name</code> <p>The command name.</p> <p> TYPE: <code>str</code> </p> <code>*names</code> <p>Other names for the command.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>validate_arg_keys</code> <p>Whether to validate that option keys match the command callback's signature.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MessageCallbackSig], MessageCommand]</code> <p>The decorator callback used to make a sub-command.</p> <p>This can either wrap a raw command callback or another callable command instance (e.g. tanjun.MenuCommand, tanjun.MessageCommand, tanjun.SlashCommand).</p>"},{"location":"reference/#tanjun.commands.message.MessageCommandGroup.as_sub_group","title":"as_sub_group","text":"<pre><code>as_sub_group(name, /, *names, strict=False, validate_arg_keys=True)\n</code></pre> <p>Build a message command group in this group from a decorated callback.</p> PARAMETER DESCRIPTION <code>name</code> <p>The command name.</p> <p> TYPE: <code>str</code> </p> <code>*names</code> <p>Other names for the command.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>strict</code> <p>Whether this command group should only allow commands without spaces in their names.</p> <p>This allows for a more optimised command search pattern to be used and enforces that command names are unique to a single command within the group.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>validate_arg_keys</code> <p>Whether to validate that option keys match the command callback's signature.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MessageCallbackSig], MessageCommand]</code> <p>The decorator callback used to make a sub-command group.</p> <p>This can either wrap a raw command callback or another callable command instance (e.g. tanjun.MenuCommand, tanjun.MessageCommand, tanjun.SlashCommand).</p>"},{"location":"reference/#tanjun.ModuleMissingLoaders","title":"ModuleMissingLoaders","text":"<p>         Bases: <code>RuntimeError</code>, <code>TanjunError</code></p> <p>Error raised when a module is missing loaders.</p>"},{"location":"reference/#tanjun.errors.ModuleMissingLoaders.message","title":"message  <code>property</code>","text":"<pre><code>message: str\n</code></pre> <p>The error message.</p>"},{"location":"reference/#tanjun.errors.ModuleMissingLoaders.path","title":"path  <code>property</code>","text":"<pre><code>path: typing.Union[str, pathlib.Path]\n</code></pre> <p>The path of the module which is missing loaders.</p>"},{"location":"reference/#tanjun.ModuleMissingUnloaders","title":"ModuleMissingUnloaders","text":"<p>         Bases: <code>RuntimeError</code>, <code>TanjunError</code></p> <p>Error raised when a module is missing unloaders.</p>"},{"location":"reference/#tanjun.errors.ModuleMissingUnloaders.message","title":"message  <code>property</code>","text":"<pre><code>message: str\n</code></pre> <p>The error message.</p>"},{"location":"reference/#tanjun.errors.ModuleMissingUnloaders.path","title":"path  <code>property</code>","text":"<pre><code>path: typing.Union[str, pathlib.Path]\n</code></pre> <p>The path of the module which is missing unloaders.</p>"},{"location":"reference/#tanjun.ModuleStateConflict","title":"ModuleStateConflict","text":"<p>         Bases: <code>ValueError</code>, <code>TanjunError</code></p> <p>Error raised when a module cannot be (un)loaded due to a state conflict.</p>"},{"location":"reference/#tanjun.errors.ModuleStateConflict.message","title":"message  <code>property</code>","text":"<pre><code>message: str\n</code></pre> <p>The error message.</p>"},{"location":"reference/#tanjun.errors.ModuleStateConflict.path","title":"path  <code>property</code>","text":"<pre><code>path: typing.Union[str, pathlib.Path]\n</code></pre> <p>The path of the module which caused the error.</p>"},{"location":"reference/#tanjun.NotEnoughArgumentsError","title":"NotEnoughArgumentsError","text":"<p>         Bases: <code>ParserError</code></p> <p>Error raised by the parser when not enough arguments are found for a parameter.</p>"},{"location":"reference/#tanjun.errors.NotEnoughArgumentsError.parameter","title":"parameter  <code>class-attribute</code>","text":"<pre><code>parameter: str\n</code></pre> <p>Name of the parameter this error was raised for.</p>"},{"location":"reference/#tanjun.errors.NotEnoughArgumentsError.__init__","title":"__init__","text":"<pre><code>__init__(message, parameter)\n</code></pre> <p>Initialise a not enough arguments error.</p> PARAMETER DESCRIPTION <code>message</code> <p>The error message.</p> <p> TYPE: <code>str</code> </p> <code>parameter</code> <p>The parameter this error was raised for.</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/#tanjun.ParserError","title":"ParserError","text":"<p>         Bases: <code>TanjunError</code>, <code>ValueError</code></p> <p>Base error raised by a parser or parameter during parsing.</p> <p>Note</p> <p>Expected errors raised by the parser will subclass this error.</p>"},{"location":"reference/#tanjun.errors.ParserError.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre> <p>String message for this error.</p> <p>Note</p> <p>This may be used as a command response message.</p>"},{"location":"reference/#tanjun.errors.ParserError.parameter","title":"parameter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parameter = parameter\n</code></pre> <p>Name of the this was raised for.</p> <p>Note</p> <p>This will be None if it was raised while parsing the provided message content.</p>"},{"location":"reference/#tanjun.errors.ParserError.__init__","title":"__init__","text":"<pre><code>__init__(message, parameter)\n</code></pre> <p>Initialise a parser error.</p> PARAMETER DESCRIPTION <code>message</code> <p>String message for this error.</p> <p> TYPE: <code>str</code> </p> <code>parameter</code> <p>Name of the parameter which caused this error, should be None if not applicable.</p> <p> TYPE: <code>typing.Optional[str]</code> </p>"},{"location":"reference/#tanjun.ShlexParser","title":"ShlexParser","text":"<p>         Bases: <code>AbstractOptionParser</code></p> <p>A shlex based AbstractOptionParser implementation.</p>"},{"location":"reference/#tanjun.parsing.ShlexParser.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> <p>Initialise a shlex parser.</p>"},{"location":"reference/#tanjun.SlashCommand","title":"SlashCommand","text":"<p>         Bases: <code>BaseSlashCommand</code>, <code>tanjun.SlashCommand[_SlashCallbackSigT]</code></p> <p>Standard implementation of a slash command.</p>"},{"location":"reference/#tanjun.commands.slash.SlashCommand.wrapped_command","title":"wrapped_command  <code>property</code>","text":"<pre><code>wrapped_command: typing.Optional[tanjun.ExecutableCommand[typing.Any]]\n</code></pre> <p>The command object this wraps, if any.</p>"},{"location":"reference/#tanjun.commands.slash.SlashCommand.__init__","title":"__init__","text":"<pre><code>__init__(callback, name, description, /, *, always_defer=False, default_member_permissions=None, default_to_ephemeral=None, dm_enabled=None, is_global=True, sort_options=True, validate_arg_keys=True, _wrapped_command=None)\n</code></pre> <p>Initialise a slash command.</p> <p>Note</p> <p>Under the standard implementation, <code>is_global</code> is used to determine whether the command should be bulk set by tanjun.Client.declare_global_commands or when <code>declare_global_commands</code> is True</p> <p>Warning</p> <p><code>default_member_permissions</code>, <code>dm_enabled</code> and <code>is_global</code> are ignored for commands within slash command groups.</p> <p>Note</p> <p>If you want your first response to be ephemeral while using <code>always_defer</code>, you must set <code>default_to_ephemeral</code> to <code>True</code>.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback to execute when the command is invoked.</p> <p>This should be an asynchronous callback which takes one positional argument of type tanjun.abc.SlashContext, returns <code>None</code> and may use dependency injection to access other services.</p> <p> TYPE: <code>tanjun.abc.SlashCallbackSig</code> </p> <code>name</code> <p>The command's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The command's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>always_defer</code> <p>Whether the contexts this command is executed with should always be deferred before being passed to the command's callback.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>default_member_permissions</code> <p>Member permissions necessary to utilize this command by default.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Union[hikari.Permissions, int, None]</code> DEFAULT: <code>None</code> </p> <code>default_to_ephemeral</code> <p>Whether this command's responses should default to ephemeral unless flags are set to override this.</p> <p>If this is left as None then the default set on the parent command(s), component or client will be in effect.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>dm_enabled</code> <p>Whether this command is enabled in DMs with the bot.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>is_global</code> <p>Whether this command is a global command.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>sort_options</code> <p>Whether this command should sort its set options based on whether they're required.</p> <p>If this is True then the options are re-sorted to meet the requirement from Discord that required command options be listed before optional ones.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>validate_arg_keys</code> <p>Whether to validate that option keys match the command callback's signature.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the command name doesn't fit Discord's requirements.</li> <li>If the command name has uppercase characters.</li> <li>If the description is over 100 characters long.</li> </ul>"},{"location":"reference/#tanjun.commands.slash.SlashCommand.add_attachment_option","title":"add_attachment_option","text":"<pre><code>add_attachment_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None, pass_as_kwarg=True)\n</code></pre> <p>Add an attachment option to the slash command.</p> <p>Note</p> <p>This will result in options of type hikari.messages.Attachment.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The option's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>default</code> <p>The option's default value.</p> <p>If this is left as no default then this option will be required.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>key</code> <p>Name of the argument this option's value should be passed to.</p> <p>This defaults to the first name provided in <code>name</code> and is no-op if <code>pass_as_kwarg</code> is False.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>pass_as_kwarg</code> <p>Whether or not to pass this option as a keyword argument to the command callback.</p> <p>If False is passed here then <code>default</code> will only decide whether the option is required without the actual value being used and the <code>coverters</code> field will be ignored.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the option name doesn't fit Discord's requirements.</li> <li>If the option name has uppercase characters.</li> <li>If the option description is over 100 characters in length.</li> <li>If the command already has 25 options.</li> <li>If <code>name</code> isn't valid for this command's callback when <code>validate_arg_keys</code> is True.</li> </ul>"},{"location":"reference/#tanjun.commands.slash.SlashCommand.add_bool_option","title":"add_bool_option","text":"<pre><code>add_bool_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None, pass_as_kwarg=True)\n</code></pre> <p>Add a boolean option to a slash command.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The option's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>default</code> <p>The option's default value.</p> <p>If this is left as no default then this option will be required.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>key</code> <p>Name of the argument this option's value should be passed to.</p> <p>This defaults to the first name provided in <code>name</code> and is no-op if <code>pass_as_kwarg</code> is False.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>pass_as_kwarg</code> <p>Whether or not to pass this option as a keyword argument to the command callback.</p> <p>If False is passed here then <code>default</code> will only decide whether the option is required without the actual value being used.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the option name doesn't fit Discord's requirements.</li> <li>If the option name has uppercase characters.</li> <li>If the option description is over 100 characters in length.</li> <li>If the command already has 25 options.</li> <li>If <code>name</code> isn't valid for this command's callback when <code>validate_arg_keys</code> is True.</li> </ul>"},{"location":"reference/#tanjun.commands.slash.SlashCommand.add_channel_option","title":"add_channel_option","text":"<pre><code>add_channel_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None, types=None, pass_as_kwarg=True)\n</code></pre> <p>Add a channel option to a slash command.</p> <p>Note</p> <p>This will always result in hikari.interactions.base_interactions.InteractionChannel.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The option's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>default</code> <p>The option's default value.</p> <p>If this is left as no default then this option will be required.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>types</code> <p>A collection of the channel classes and types this option should accept.</p> <p>If left as None or empty then the option will allow all channel types.</p> <p> TYPE: <code>typing.Optional[collections.Collection[typing.Union[type[hikari.PartialChannel], int]]]</code> DEFAULT: <code>None</code> </p> <code>key</code> <p>Name of the argument this option's value should be passed to.</p> <p>This defaults to the first name provided in <code>name</code> and is no-op if <code>pass_as_kwarg</code> is False.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>pass_as_kwarg</code> <p>Whether or not to pass this option as a keyword argument to the command callback.</p> <p>If False is passed here then <code>default</code> will only decide whether the option is required without the actual value being used.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the option name doesn't fit Discord's requirements.</li> <li>If the option name has uppercase characters.</li> <li>If the option description is over 100 characters in length.</li> <li>If the command already has 25 options.</li> <li>If an invalid type is passed in <code>types</code>.</li> <li>If <code>name</code> isn't valid for this command's callback when <code>validate_arg_keys</code> is True.</li> </ul>"},{"location":"reference/#tanjun.commands.slash.SlashCommand.add_float_option","title":"add_float_option","text":"<pre><code>add_float_option(name, description, /, *, always_float=True, autocomplete=None, choices=None, converters=(), default=tanjun.NO_DEFAULT, key=None, min_value=None, max_value=None, pass_as_kwarg=True, _stack_level=0)\n</code></pre> <p>Add a float option to a slash command.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The option's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>always_float</code> <p>If this is set to True then the value will always be converted to a float (this will happen before it's passed to converters).</p> <p>This masks behaviour from Discord where we will either be provided a float or int dependent on what the user provided.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>autocomplete</code> <p>The autocomplete callback for the option.</p> <p>More information on this callback's signature can be found at tanjun.abc.AutocompleteSig and the 2nd positional argument should be of type float.</p> <p> TYPE: <code>typing.Optional[tanjun.AutocompleteSig[float]]</code> DEFAULT: <code>None</code> </p> <code>choices</code> <p>The option's choices.</p> <p>This is a mapping of [option_name, option_value] where option_name should be a string of up to 100 characters and option_value should be a float.</p> <p> TYPE: <code>collections.abc.Mapping[str, float] | None</code> DEFAULT: <code>None</code> </p> <code>converters</code> <p>The option's converters.</p> <p>This may be either one or multiple converter callbacks used to convert the option's value to the final form. If no converters are provided then the raw value will be passed.</p> <p>Only the first converter to pass will be used.</p> <p> TYPE: <code>typing.Union[collections.Sequence[ConverterSig[float]], ConverterSig[float]]</code> DEFAULT: <code>()</code> </p> <code>default</code> <p>The option's default value.</p> <p>If this is left as no default then this option will be required.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>key</code> <p>Name of the argument this option's value should be passed to.</p> <p>This defaults to the first name provided in <code>name</code> and is no-op if <code>pass_as_kwarg</code> is False.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>min_value</code> <p>The option's (inclusive) minimum value.</p> <p> TYPE: <code>typing.Optional[float]</code> DEFAULT: <code>None</code> </p> <code>max_value</code> <p>The option's (inclusive) maximum value.</p> <p> TYPE: <code>typing.Optional[float]</code> DEFAULT: <code>None</code> </p> <code>pass_as_kwarg</code> <p>Whether or not to pass this option as a keyword argument to the command callback.</p> <p>If False is passed here then <code>default</code> will only decide whether the option is required without the actual value being used and the fields <code>coverters</code>, and <code>always_float</code> will be ignored.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the option name doesn't fit Discord's requirements.</li> <li>If the option name has uppercase characters.</li> <li>If the option description is over 100 characters in length.</li> <li>If the option has more than 25 choices.</li> <li>If the command already has 25 options.</li> <li>If <code>min_value</code> is greater than <code>max_value</code>.</li> <li>If <code>name</code> isn't valid for this command's callback when <code>validate_arg_keys</code> is True.</li> </ul>"},{"location":"reference/#tanjun.commands.slash.SlashCommand.add_int_option","title":"add_int_option","text":"<pre><code>add_int_option(name, description, /, *, autocomplete=None, choices=None, converters=(), default=tanjun.NO_DEFAULT, key=None, min_value=None, max_value=None, pass_as_kwarg=True, _stack_level=0)\n</code></pre> <p>Add an integer option to the slash command.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The option's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>autocomplete</code> <p>The autocomplete callback for the option.</p> <p>More information on this callback's signature can be found at tanjun.abc.AutocompleteSig and the 2nd positional argument should be of type int.</p> <p> TYPE: <code>typing.Optional[tanjun.AutocompleteSig[int]]</code> DEFAULT: <code>None</code> </p> <code>choices</code> <p>The option's choices.</p> <p>This is a mapping of [option_name, option_value] where option_name should be a string of up to 100 characters and option_value should be an integer.</p> <p> TYPE: <code>collections.abc.Mapping[str, int] | None</code> DEFAULT: <code>None</code> </p> <code>converters</code> <p>The option's converters.</p> <p>This may be either one or multiple converter callbacks used to convert the option's value to the final form. If no converters are provided then the raw value will be passed.</p> <p>Only the first converter to pass will be used.</p> <p> TYPE: <code>typing.Union[collections.Sequence[ConverterSig[int]], ConverterSig[int]]</code> DEFAULT: <code>()</code> </p> <code>default</code> <p>The option's default value.</p> <p>If this is left as undefined then this option will be required.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>key</code> <p>Name of the argument this option's value should be passed to.</p> <p>This defaults to the first name provided in <code>name</code> and is no-op if <code>pass_as_kwarg</code> is False.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>min_value</code> <p>The option's (inclusive) minimum value.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>max_value</code> <p>The option's (inclusive) maximum value.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>pass_as_kwarg</code> <p>Whether or not to pass this option as a keyword argument to the command callback.</p> <p>If False is passed here then <code>default</code> will only decide whether the option is required without the actual value being used and the <code>coverters</code> field will be ignored.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the option name doesn't fit Discord's requirements.</li> <li>If the option name has uppercase characters.</li> <li>If the option description is over 100 characters in length.</li> <li>If the option has more than 25 choices.</li> <li>If the command already has 25 options.</li> <li>If <code>min_value</code> is greater than <code>max_value</code>.</li> <li>If <code>name</code> isn't valid for this command's callback when <code>validate_arg_keys</code> is True.</li> </ul>"},{"location":"reference/#tanjun.commands.slash.SlashCommand.add_member_option","title":"add_member_option","text":"<pre><code>add_member_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None)\n</code></pre> <p>Add a member option to a slash command.</p> <p>Note</p> <p>This will always result in hikari.interactions.base_interactions.InteractionMember.</p> <p>Warning</p> <p>Unlike the other options, this is an artificial option which adds a restraint to the USER option type and therefore cannot have <code>pass_as_kwarg</code> set to False as this artificial constraint isn't present when its not being passed as a keyword argument.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The option's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>default</code> <p>The option's default value.</p> <p>If this is left as no default then this option will be required.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>key</code> <p>Name of the argument this option's value should be passed to.</p> <p>This defaults to the first name provided in <code>name</code> and is no-op if <code>pass_as_kwarg</code> is False.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the option name doesn't fit Discord's requirements.</li> <li>If the option name has uppercase characters.</li> <li>If the option description is over 100 characters in length.</li> <li>If the command already has 25 options.</li> <li>If <code>name</code> isn't valid for this command's callback when <code>validate_arg_keys</code> is True.</li> </ul>"},{"location":"reference/#tanjun.commands.slash.SlashCommand.add_mentionable_option","title":"add_mentionable_option","text":"<pre><code>add_mentionable_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None, pass_as_kwarg=True)\n</code></pre> <p>Add a mentionable option to a slash command.</p> <p>Note</p> <p>This may target roles, guild members or users and results in <code>hikari.User | hikari.InteractionMember | hikari.Role</code>.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The option's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>default</code> <p>The option's default value.</p> <p>If this is left as no default then this option will be required.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>key</code> <p>Name of the argument this option's value should be passed to.</p> <p>This defaults to the first name provided in <code>name</code> and is no-op if <code>pass_as_kwarg</code> is False.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>pass_as_kwarg</code> <p>Whether or not to pass this option as a keyword argument to the command callback.</p> <p>If False is passed here then <code>default</code> will only decide whether the option is required without the actual value being used.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the option name doesn't fit Discord's requirements.</li> <li>If the option name has uppercase characters.</li> <li>If the option description is over 100 characters in length.</li> <li>If the command already has 25 options.</li> <li>If <code>name</code> isn't valid for this command's callback when <code>validate_arg_keys</code> is True.</li> </ul>"},{"location":"reference/#tanjun.commands.slash.SlashCommand.add_role_option","title":"add_role_option","text":"<pre><code>add_role_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None, pass_as_kwarg=True)\n</code></pre> <p>Add a role option to a slash command.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The option's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>default</code> <p>The option's default value.</p> <p>If this is left as no default then this option will be required.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>key</code> <p>Name of the argument this option's value should be passed to.</p> <p>This defaults to the first name provided in <code>name</code> and is no-op if <code>pass_as_kwarg</code> is False.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>pass_as_kwarg</code> <p>Whether or not to pass this option as a keyword argument to the command callback.</p> <p>If False is passed here then <code>default</code> will only decide whether the option is required without the actual value being used.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the option name doesn't fit Discord's requirements.</li> <li>If the option name has uppercase characters.</li> <li>If the option description is over 100 characters in length.</li> <li>If the command already has 25 options.</li> <li>If <code>name</code> isn't valid for this command's callback when <code>validate_arg_keys</code> is True.</li> </ul>"},{"location":"reference/#tanjun.commands.slash.SlashCommand.add_str_option","title":"add_str_option","text":"<pre><code>add_str_option(name, description, /, *, autocomplete=None, choices=None, converters=(), default=tanjun.NO_DEFAULT, key=None, min_length=None, max_length=None, pass_as_kwarg=True, _stack_level=0)\n</code></pre> <p>Add a string option to the slash command.</p> <p>Note</p> <p>As a shorthand, <code>choices</code> also supports passing a list of strings rather than a dict of names to values (each string will used as both the choice's name and value with the names being capitalised).</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The option's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>autocomplete</code> <p>The autocomplete callback for the option.</p> <p>More information on this callback's signature can be found at tanjun.abc.AutocompleteSig and the 2nd positional argument should be of type str.</p> <p> TYPE: <code>typing.Optional[tanjun.AutocompleteSig[str]]</code> DEFAULT: <code>None</code> </p> <code>choices</code> <p>The option's choices.</p> <p>This either a mapping of [option_name, option_value] where both option_name and option_value should be strings of up to 100 characters or a sequence of strings where the string will be used for both the choice's name and value.</p> <p>Passing a sequence of tuples here is deprecated.</p> <p> TYPE: <code>collections.abc.Mapping[str, str], collections.abc.Sequence[str] | None</code> DEFAULT: <code>None</code> </p> <code>converters</code> <p>The option's converters.</p> <p>This may be either one or multiple converter callbacks used to convert the option's value to the final form. If no converters are provided then the raw value will be passed.</p> <p>Only the first converter to pass will be used.</p> <p> TYPE: <code>typing.Union[collections.Sequence[ConverterSig[str]], ConverterSig[str]]</code> DEFAULT: <code>()</code> </p> <code>default</code> <p>The option's default value.</p> <p>If this is left as no default then this option will be required.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>key</code> <p>Name of the argument this option's value should be passed to.</p> <p>This defaults to the first name provided in <code>name</code> and is no-op if <code>pass_as_kwarg</code> is False.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>min_length</code> <p>The minimum length of this string.</p> <p>This must be greater than or equal to 0, and less than or equal to <code>max_length</code> and <code>6000</code>.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>max_length</code> <p>The maximum length of this string.</p> <p>This must be greater then or equal to <code>min_length</code> and 1, and less than or equal to <code>6000</code>.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>pass_as_kwarg</code> <p>Whether or not to pass this option as a keyword argument to the command callback.</p> <p>If False is passed here then <code>default</code> will only decide whether the option is required without the actual value being used and the <code>coverters</code> field will be ignored.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the option name doesn't fit Discord's requirements.</li> <li>If the option name has uppercase characters.</li> <li>If the option description is over 100 characters in length.</li> <li>If the option has more than 25 choices.</li> <li>If the command already has 25 options.</li> <li>If <code>name</code> isn't valid for this command's callback when <code>validate_arg_keys</code> is True.</li> <li>If <code>min_length</code> is greater than <code>max_length</code>.</li> <li>If <code>min_length</code> is less than <code>0</code> or greater than <code>6000</code>.</li> <li>If <code>max_length</code> is less than <code>1</code> or greater than <code>6000</code>.</li> </ul>"},{"location":"reference/#tanjun.commands.slash.SlashCommand.add_user_option","title":"add_user_option","text":"<pre><code>add_user_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None, pass_as_kwarg=True)\n</code></pre> <p>Add a user option to a slash command.</p> <p>Note</p> <p>This may result in hikari.interactions.base_interactions.InteractionMember or hikari.users.User if the user isn't in the current guild or if this command was executed in a DM channel.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The option's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>default</code> <p>The option's default value.</p> <p>If this is left as no default then this option will be required.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>key</code> <p>Name of the argument this option's value should be passed to.</p> <p>This defaults to the first name provided in <code>name</code> and is no-op if <code>pass_as_kwarg</code> is False.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>pass_as_kwarg</code> <p>Whether or not to pass this option as a keyword argument to the command callback.</p> <p>If False is passed here then <code>default</code> will only decide whether the option is required without the actual value being used.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the option name doesn't fit Discord's requirements.</li> <li>If the option name has uppercase characters.</li> <li>If the option description is over 100 characters in length.</li> <li>If the option has more than 25 choices.</li> <li>If the command already has 25 options.</li> <li>If <code>name</code> isn't valid for this command's callback when <code>validate_arg_keys</code> is True.</li> </ul>"},{"location":"reference/#tanjun.commands.slash.SlashCommand.set_float_autocomplete","title":"set_float_autocomplete","text":"<pre><code>set_float_autocomplete(name, callback)\n</code></pre> <p>Set the autocomplete callback for a float option.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name.</p> <p>If localised names were provided for the option then this should be the default name.</p> <p> TYPE: <code>str</code> </p> <code>callback</code> <p>The autocomplete callback for the option.</p> <p>More information on this callback's signature can be found at tanjun.abc.AutocompleteSig and the 2nd positional argument should be of type float.</p> <p>Passing None here will remove the autocomplete callback for the option.</p> <p> TYPE: <code>typing.Optional[tanjun.AutocompleteSig[float]]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>KeyError</code> <p>Raises a key error if the option doesn't exist.</p> <code>TypeError</code> <p>Raises a type error if the option isn't of type <code>float</code>.</p>"},{"location":"reference/#tanjun.commands.slash.SlashCommand.set_int_autocomplete","title":"set_int_autocomplete","text":"<pre><code>set_int_autocomplete(name, callback)\n</code></pre> <p>Set the autocomplete callback for a string option.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name.</p> <p>If localised names were provided for the option then this should be the default name.</p> <p> TYPE: <code>str</code> </p> <code>callback</code> <p>The autocomplete callback for the option.</p> <p>More information on this callback's signature can be found at tanjun.abc.AutocompleteSig and the 2nd positional argument should be of type str.</p> <p>Passing None here will remove the autocomplete callback for the option.</p> <p> TYPE: <code>tanjun.AutocompleteSig[int]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>KeyError</code> <p>Raises a key error if the option doesn't exist.</p> <code>TypeError</code> <p>Raises a type error if the option isn't of type <code>str</code>.</p>"},{"location":"reference/#tanjun.commands.slash.SlashCommand.set_str_autocomplete","title":"set_str_autocomplete","text":"<pre><code>set_str_autocomplete(name, callback)\n</code></pre> <p>Set the autocomplete callback for a str option.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name.</p> <p>If localised names were provided for the option then this should be the default name.</p> <p> TYPE: <code>str</code> </p> <code>callback</code> <p>The autocomplete callback for the option.</p> <p>More information on this callback's signature can be found at tanjun.abc.AutocompleteSig and the 2nd positional argument should be of type str.</p> <p>Passing None here will remove the autocomplete callback for the option.</p> <p> TYPE: <code>tanjun.AutocompleteSig[str]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>KeyError</code> <p>Raises a key error if the option doesn't exist.</p> <code>TypeError</code> <p>Raises a type error if the option isn't of type <code>str</code>.</p>"},{"location":"reference/#tanjun.commands.slash.SlashCommand.with_float_autocomplete","title":"with_float_autocomplete","text":"<pre><code>with_float_autocomplete(name)\n</code></pre> <p>Set the autocomplete callback for a float option through a decorator call.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name.</p> <p>If localised names were provided for the option then this should be the default name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Collections.abc.Callable[[tanjun.abc.AutocompleteSig[float]], tanjun.abc.AutocompleteSig[float]]</code> <p>Decorator callback used to capture the autocomplete callback.</p> <p>More information on the autocomplete signature can be found at tanjun.abc.AutocompleteSig and the 2nd positional argument should be of type float.</p> RAISES DESCRIPTION <code>KeyError</code> <p>Raises a key error if the option doesn't exist.</p> <code>TypeError</code> <p>Raises a type error if the option isn't of type <code>float</code>.</p>"},{"location":"reference/#tanjun.commands.slash.SlashCommand.with_int_autocomplete","title":"with_int_autocomplete","text":"<pre><code>with_int_autocomplete(name)\n</code></pre> <p>Set the autocomplete callback for a integer option through a decorator call.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name.</p> <p>If localised names were provided for the option then this should be the default name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Collections.abc.Callable[[tanjun.abc.AutocompleteSig[int]], tanjun.abc.AutocompleteSig[int]]</code> <p>Decorator callback used to capture the autocomplete callback.</p> <p>More information on the autocomplete signature can be found at tanjun.abc.AutocompleteSig and the 2nd positional argument should be of type int.</p> RAISES DESCRIPTION <code>KeyError</code> <p>Raises a key error if the option doesn't exist.</p> <code>TypeError</code> <p>Raises a type error if the option isn't of type <code>int</code>.</p>"},{"location":"reference/#tanjun.commands.slash.SlashCommand.with_str_autocomplete","title":"with_str_autocomplete","text":"<pre><code>with_str_autocomplete(name)\n</code></pre> <p>Set the autocomplete callback for a string option through a decorator call.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name.</p> <p>If localised names were provided for the option then this should be the default name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Collections.abc.Callable[[tanjun.abc.AutocompleteSig[str]], tanjun.abc.AutocompleteSig[str]]</code> <p>Decorator callback used to capture the autocomplete callback.</p> <p>More information on the autocomplete signature can be found at tanjun.abc.AutocompleteSig and the 2nd positional argument should be of type str.</p> RAISES DESCRIPTION <code>KeyError</code> <p>Raises a key error if the option doesn't exist.</p> <code>TypeError</code> <p>Raises a type error if the option isn't of type <code>str</code>.</p>"},{"location":"reference/#tanjun.SlashCommandGroup","title":"SlashCommandGroup","text":"<p>         Bases: <code>BaseSlashCommand</code>, <code>tanjun.SlashCommandGroup</code></p> <p>Standard implementation of a slash command group.</p> <p>Note</p> <p>Unlike message command groups, slash command groups cannot be callable functions themselves.</p>"},{"location":"reference/#tanjun.commands.slash.SlashCommandGroup.__init__","title":"__init__","text":"<pre><code>__init__(name, description, /, *, default_member_permissions=None, default_to_ephemeral=None, dm_enabled=None, is_global=True)\n</code></pre> <p>Initialise a slash command group.</p> <p>Note</p> <p>Under the standard implementation, <code>is_global</code> is used to determine whether the command should be bulk set by tanjun.Client.declare_global_commands or when <code>declare_global_commands</code> is True</p> <p>Warning</p> <p><code>default_member_permissions</code>, <code>dm_enabled</code> and <code>is_global</code> are ignored for commands groups within another slash command groups.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the command group (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The description of the command group (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>default_member_permissions</code> <p>Member permissions necessary to utilize this command by default.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Union[hikari.Permissions, int, None]</code> DEFAULT: <code>None</code> </p> <code>default_to_ephemeral</code> <p>Whether this command's responses should default to ephemeral unless flags are set to override this.</p> <p>If this is left as None then the default set on the parent command(s), component or client will be in effect.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>dm_enabled</code> <p>Whether this command is enabled in DMs with the bot.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>is_global</code> <p>Whether this command is a global command.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the command name doesn't fit Discord's requirements.</li> <li>If the command name has uppercase characters.</li> <li>If the description is over 100 characters long.</li> </ul>"},{"location":"reference/#tanjun.commands.slash.SlashCommandGroup.add_command","title":"add_command","text":"<pre><code>add_command(command)\n</code></pre> <p>Add a slash command to this group.</p> <p>Warning</p> <p>Command groups are only supported within top-level groups.</p> PARAMETER DESCRIPTION <code>command</code> <p>Command to add to this group.</p> <p> TYPE: <code>tanjun.BaseSlashCommand</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Object of this group to enable chained calls.</p>"},{"location":"reference/#tanjun.commands.slash.SlashCommandGroup.as_sub_command","title":"as_sub_command","text":"<pre><code>as_sub_command(name, description, /, *, always_defer=False, default_to_ephemeral=None, sort_options=True, validate_arg_keys=True)\n</code></pre> <p>Build a tanjun.SlashCommand in this command group by decorating a function.</p> <p>Note</p> <p>If you want your first response to be ephemeral while using <code>always_defer</code>, you must set <code>default_to_ephemeral</code> to <code>True</code>.</p> PARAMETER DESCRIPTION <code>name</code> <p>The command's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The command's description. This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>always_defer</code> <p>Whether the contexts this command is executed with should always be deferred before being passed to the command's callback.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>default_to_ephemeral</code> <p>Whether this command's responses should default to ephemeral unless flags are set to override this.</p> <p>If this is left as None then the default set on the parent command(s), component or client will be in effect.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>sort_options</code> <p>Whether this command should sort its set options based on whether they're required.</p> <p>If this is True then the options are re-sorted to meet the requirement from Discord that required command options be listed before optional ones.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>validate_arg_keys</code> <p>Whether to validate that option keys match the command callback's signature.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.SlashCallbackSig], SlashCommand]</code> <p>The decorator callback used to make a sub-command.</p> <p>This can either wrap a raw command callback or another callable command instance (e.g. tanjun.MenuCommand, tanjun.MessageCommand tanjun.SlashCommand).</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the command name doesn't fit Discord's requirements.</li> <li>If the command name has uppercase characters.</li> <li>If the description is over 100 characters long.</li> </ul>"},{"location":"reference/#tanjun.commands.slash.SlashCommandGroup.make_sub_group","title":"make_sub_group","text":"<pre><code>make_sub_group(name, description, /, *, default_to_ephemeral=None)\n</code></pre> <p>Create a sub-command group in this group.</p> <p>Note</p> <p>Unlike message command groups, slash command groups cannot be callable functions themselves.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the command group (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The description of the command group.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>default_to_ephemeral</code> <p>Whether this command's responses should default to ephemeral unless flags are set to override this.</p> <p>If this is left as None then the default set on the parent command(s), component or client will be in effect.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>SlashCommandGroup</code> <p>The created sub-command group.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the command name doesn't fit Discord's requirements.</li> <li>If the command name has uppercase characters.</li> <li>If the description is over 100 characters long.</li> </ul>"},{"location":"reference/#tanjun.commands.slash.SlashCommandGroup.remove_command","title":"remove_command","text":"<pre><code>remove_command(command)\n</code></pre> <p>Remove a command from this group.</p> PARAMETER DESCRIPTION <code>command</code> <p>Command to remove from this group.</p> <p> TYPE: <code>tanjun.BaseSlashCommand</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Object of this group to enable chained calls.</p>"},{"location":"reference/#tanjun.commands.slash.SlashCommandGroup.with_command","title":"with_command","text":"<pre><code>with_command(command)\n</code></pre> <p>Add a slash command to this group through a decorator call.</p> PARAMETER DESCRIPTION <code>command</code> <p>Command to add to this group.</p> <p> TYPE: <code>tanjun.abc.BaseSlashCommand</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.BaseSlashCommand</code> <p>Command which was added to this group.</p>"},{"location":"reference/#tanjun.TanjunError","title":"TanjunError","text":"<p>         Bases: <code>Exception</code></p> <p>The base class for all errors raised by Tanjun.</p>"},{"location":"reference/#tanjun.TooManyArgumentsError","title":"TooManyArgumentsError","text":"<p>         Bases: <code>ParserError</code></p> <p>Error raised by the parser when too many arguments are found for a parameter.</p>"},{"location":"reference/#tanjun.errors.TooManyArgumentsError.parameter","title":"parameter  <code>class-attribute</code>","text":"<pre><code>parameter: str\n</code></pre> <p>Name of the parameter this error was raised for.</p>"},{"location":"reference/#tanjun.errors.TooManyArgumentsError.__init__","title":"__init__","text":"<pre><code>__init__(message, parameter)\n</code></pre> <p>Initialise a too many arguments error.</p> PARAMETER DESCRIPTION <code>message</code> <p>The error message.</p> <p> TYPE: <code>str</code> </p> <code>parameter</code> <p>The parameter this error was raised for.</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/#tanjun.as_interval","title":"as_interval","text":"<pre><code>as_interval(interval, /, *, fatal_exceptions=(), ignored_exceptions=(), max_runs=None)\n</code></pre> <p>Decorator to create an schedule.</p> <p>Examples:</p> <pre><code>@component.with_schedule\n@tanjun.as_interval(datetime.timedelta(minutes=5))  # This will run every 5 minutes\nasync def interval(client: alluka.Injected[tanjun.abc.Client]) -&gt; None:\n    ...\n</code></pre> <p>This should be loaded into a component using either Component.with_schedule or Component.load_from_scope, and will be started and stopped with the linked tanjun client.</p> PARAMETER DESCRIPTION <code>interval</code> <p>The interval between calls. Passed as a timedelta, or a number of seconds.</p> <p> TYPE: <code>typing.Union[int, float, datetime.timedelta]</code> </p> <code>fatal_exceptions</code> <p>A sequence of exceptions that will cause the schedule to stop if raised by the callback, start callback or stop callback.</p> <p> TYPE: <code>collections.Sequence[type[Exception]]</code> DEFAULT: <code>()</code> </p> <code>ignored_exceptions</code> <p>A sequence of exceptions that should be ignored if raised by the callback, start callback or stop callback.</p> <p> TYPE: <code>collections.Sequence[type[Exception]]</code> DEFAULT: <code>()</code> </p> <code>max_runs</code> <p>The maximum amount of times the schedule runs.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>collections.Callable[[_CallbackSigT], tanjun.schedules.IntervalSchedule[_CallbackSigT]]</code> <p>The decorator used to create the schedule.</p> <p>This should be decorating an asynchronous function which takes no positional arguments, returns None and may use dependency injection.</p>"},{"location":"reference/#tanjun.as_loader","title":"as_loader","text":"<pre><code>as_loader(callback=None, /, *, standard_impl=True)\n</code></pre> <p>Mark a callback as being used to load Tanjun components from a module.</p> <p>Note</p> <p>This is only necessary if you wish to use tanjun.Client.load_modules.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback used to load Tanjun components from a module.</p> <p>This should take one argument of type tanjun.Client (or tanjun.abc.Client if <code>standard_impl</code> is False), return nothing and will be expected to initiate and add utilities such as components to the provided client.</p> <p> TYPE: <code>typing.Union[collections.Callable[[tanjun.Client], None], collections.Callable[[Client], None], None]</code> DEFAULT: <code>None</code> </p> <code>standard_impl</code> <p>Whether this loader should only allow instances of tanjun.Client as opposed to tanjun.abc.Client.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.Client], None]]</code> <p>The decorated load callback.</p>"},{"location":"reference/#tanjun.as_message_command","title":"as_message_command","text":"<pre><code>as_message_command(name, /, *names, validate_arg_keys=True)\n</code></pre> <p>Build a message command from a decorated callback.</p> PARAMETER DESCRIPTION <code>name</code> <p>The command name.</p> <p> TYPE: <code>str</code> </p> <code>*names</code> <p>Other names for the command.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>validate_arg_keys</code> <p>Whether to validate that option keys match the command callback's signature.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MessageCallbackSig], MessageCommand]</code> <p>The decorator callback used to make a tanjun.MessageCommand.</p> <p>This can either wrap a raw command callback or another callable command instance (e.g. tanjun.MenuCommand, tanjun.MessageCommand, tanjun.SlashCommand) and will manage loading the other command into a component when using tanjun.Component.load_from_scope.</p>"},{"location":"reference/#tanjun.as_message_command_group","title":"as_message_command_group","text":"<pre><code>as_message_command_group(name, /, *names, strict=False, validate_arg_keys=True)\n</code></pre> <p>Build a message command group from a decorated callback.</p> PARAMETER DESCRIPTION <code>name</code> <p>The command name.</p> <p> TYPE: <code>str</code> </p> <code>*names</code> <p>Other names for the command.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>strict</code> <p>Whether this command group should only allow commands without spaces in their names.</p> <p>This allows for a more optimised command search pattern to be used and enforces that command names are unique to a single command within the group.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>validate_arg_keys</code> <p>Whether to validate that option keys match the command callback's signature.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MessageCallbackSig], MessageCommand]</code> <p>The decorator callback used to make a tanjun.MessageCommandGroup.</p> <p>This can either wrap a raw command callback or another callable command instance (e.g. tanjun.MenuCommand, tanjun.MessageCommand, tanjun.SlashCommand) and will manage loading the other command into a component when using tanjun.Component.load_from_scope.</p>"},{"location":"reference/#tanjun.as_message_menu","title":"as_message_menu","text":"<pre><code>as_message_menu(name, /, *, always_defer=False, default_member_permissions=None, default_to_ephemeral=None, dm_enabled=None, is_global=True)\n</code></pre> <p>Build a message tanjun.MenuCommand by decorating a function.</p> <p>Note</p> <p>Under the standard implementation, <code>is_global</code> is used to determine whether the command should be bulk set by tanjun.Client.declare_global_commands or when <code>declare_global_commands</code> is True</p> <p>Note</p> <p>If you want your first response to be ephemeral while using <code>always_defer</code>, you must set <code>default_to_ephemeral</code> to <code>True</code>.</p> <p>Examples:</p> <pre><code>@as_message_menu(\"message\")\nasync def message_command(self, ctx: tanjun.abc.MenuContext, message: hikari.Message) -&gt; None:\n    await ctx.respond(\n        embed=hikari.Embed(title=\"Message content\", description=message.content or \"N/A\")\n    )\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>The command's name (supports localisation).</p> <p>This must be between 1 and 32 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>always_defer</code> <p>Whether the contexts this command is executed with should always be deferred before being passed to the command's callback.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>default_member_permissions</code> <p>Member permissions necessary to utilize this command by default.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Union[hikari.Permissions, int, None]</code> DEFAULT: <code>None</code> </p> <code>default_to_ephemeral</code> <p>Whether this command's responses should default to ephemeral unless flags are set to override this.</p> <p>If this is left as None then the default set on the parent command(s), component or client will be in effect.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>dm_enabled</code> <p>Whether this command is enabled in DMs with the bot.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>is_global</code> <p>Whether this command is a global command.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MenuCallbackSig], MenuCommand]</code> <p>The decorator callback used to make a tanjun.MenuCommand.</p> <p>This can either wrap a raw command callback or another callable command instance (e.g. tanjun.MenuCommand, tanjun.MessageCommand, tanjun.SlashCommand) and will manage loading the other command into a component when using tanjun.Component.load_from_scope.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the command name isn't in the length range of 1 to 32.</li> <li>If the command name has uppercase characters.</li> </ul>"},{"location":"reference/#tanjun.as_self_injecting","title":"as_self_injecting","text":"<pre><code>as_self_injecting(client)\n</code></pre> <p>Make a callback self-inecting by linking it to a client through a decorator call.</p> <p>Examples:</p> <pre><code>def make_callback(client: tanjun.Client) -&gt; collections.abc.Callable[[], int]:\n    @tanjun.as_self_injected(client)\n    async def get_int_value(\n        redis: redis.Client = tanjun.inject(type=redis.Client)\n    ) -&gt; int:\n        return int(await redis.get('key'))\n\n    return get_int_value\n</code></pre> PARAMETER DESCRIPTION <code>client</code> <p>The client to use to resolve dependencies.</p> <p> TYPE: <code>tanjun.abc.Client</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[alluka.abc.CallbackSig], alluka.AsyncSelfInjecting]</code> <p>Decorator callback that returns a self-injecting callback.</p>"},{"location":"reference/#tanjun.as_slash_command","title":"as_slash_command","text":"<pre><code>as_slash_command(name, description, /, *, always_defer=False, default_member_permissions=None, default_to_ephemeral=None, dm_enabled=None, is_global=True, sort_options=True, validate_arg_keys=True)\n</code></pre> <p>Build a tanjun.SlashCommand by decorating a function.</p> <p>Note</p> <p>Under the standard implementation, <code>is_global</code> is used to determine whether the command should be bulk set by tanjun.Client.declare_global_commands or when <code>declare_global_commands</code> is True</p> <p>Warning</p> <p><code>default_member_permissions</code>, <code>dm_enabled</code> and <code>is_global</code> are ignored for commands within slash command groups.</p> <p>Note</p> <p>If you want your first response to be ephemeral while using <code>always_defer</code>, you must set <code>default_to_ephemeral</code> to <code>True</code>.</p> <p>Examples:</p> <pre><code>@as_slash_command(\"ping\", \"Get the bot's latency\")\nasync def ping_command(self, ctx: tanjun.abc.SlashContext) -&gt; None:\n    start_time = time.perf_counter()\n    await ctx.rest.fetch_my_user()\n    time_taken = (time.perf_counter() - start_time) * 1_000\n    await ctx.respond(f\"PONG\\n - REST: {time_taken:.0f}mss\")\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>The command's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The command's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>always_defer</code> <p>Whether the contexts this command is executed with should always be deferred before being passed to the command's callback.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>default_member_permissions</code> <p>Member permissions necessary to utilize this command by default.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Union[hikari.Permissions, int, None]</code> DEFAULT: <code>None</code> </p> <code>default_to_ephemeral</code> <p>Whether this command's responses should default to ephemeral unless flags are set to override this.</p> <p>If this is left as None then the default set on the parent command(s), component or client will be in effect.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>dm_enabled</code> <p>Whether this command is enabled in DMs with the bot.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>is_global</code> <p>Whether this command is a global command.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>sort_options</code> <p>Whether this command should sort its set options based on whether they're required.</p> <p>If this is True then the options are re-sorted to meet the requirement from Discord that required command options be listed before optional ones.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>validate_arg_keys</code> <p>Whether to validate that option keys match the command callback's signature.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.SlashCallbackSig], SlashCommand]</code> <p>The decorator callback used to make a tanjun.SlashCommand.</p> <p>This can either wrap a raw command callback or another callable command instance (e.g. tanjun.MenuCommand, tanjun.MessageCommand tanjun.SlashCommand) and will manage loading the other command into a component when using tanjun.Component.load_from_scope.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the command name doesn't fit Discord's requirements.</li> <li>If the command name has uppercase characters.</li> <li>If the description is over 100 characters long.</li> </ul>"},{"location":"reference/#tanjun.as_time_schedule","title":"as_time_schedule","text":"<pre><code>as_time_schedule(*, months=(), weekly=False, days=(), hours=(), minutes=(), seconds=0, fatal_exceptions=(), ignored_exceptions=(), timezone=None)\n</code></pre> <p>Create a time schedule through a decorator call.</p> <p>Examples:</p> <pre><code>@component.with_schedule\n@tanjun.as_time_schedule(  # This will run every week day at 8:00 and 16:00 UTC.\n    minutes=0, hours=[8, 16], days=range(0, 5), weekly=True, timezone=datetime.timezone.utc\n)\nasync def interval(client: alluka.Injected[tanjun.abc.Client]) -&gt; None:\n    ...\n</code></pre> <p>This should be loaded into a component using either Component.with_schedule or Component.load_from_scope, and will be started and stopped with the linked tanjun client.</p> PARAMETER DESCRIPTION <code>months</code> <p>Either one or multiple months the schedule should run on.</p> <p>If this is not specified or an empty sequence then the schedule will run on all months.</p> <p> TYPE: <code>typing.Union[int, collections.Sequence[int]]</code> DEFAULT: <code>()</code> </p> <code>weekly</code> <p>Whether the schedule should run on a weekly basis.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>days</code> <p>Either one or multiple days the schedule should run on.</p> <p>When <code>weekly</code> is True, <code>days</code> will refer to the days of the week (<code>range(7)</code>).</p> <p>Otherwise this will refer to the days of the month (<code>range(32)</code>). For months where less than 31 days exist, numbers which are too large will be ignored.</p> <p>If this is not specified or an empty sequence, then the schedule will run on all days.</p> <p> TYPE: <code>typing.Union[int, collections.Sequence[int]]</code> DEFAULT: <code>()</code> </p> <code>hours</code> <p>Either one or multiple hours the schedule should run on.</p> <p>If this is not specified or an empty sequence then the schedule will run on all hours.</p> <p> TYPE: <code>typing.Union[int, collections.Sequence[int]]</code> DEFAULT: <code>()</code> </p> <code>minutes</code> <p>Either one or multiple minutes the schedule should run on.</p> <p>If this is not specified or an empty sequence then the schedule will run on all minutes.</p> <p> TYPE: <code>typing.Union[int, collections.Sequence[int]]</code> DEFAULT: <code>()</code> </p> <code>seconds</code> <p>Either one or multiple seconds the schedule should run on.</p> <p>Defaults to the start of the minute if not specified or an empty sequence.</p> <p> TYPE: <code>typing.Union[int, collections.Sequence[int]]</code> DEFAULT: <code>0</code> </p> <code>fatal_exceptions</code> <p>A sequence of exceptions that will cause the schedule to stop if raised by the callback, start callback or stop callback.</p> <p> TYPE: <code>collections.Sequence[type[Exception]]</code> DEFAULT: <code>()</code> </p> <code>ignored_exceptions</code> <p>A sequence of exceptions that should be ignored if raised by the callback, start callback or stop callback.</p> <p> TYPE: <code>collections.Sequence[type[Exception]]</code> DEFAULT: <code>()</code> </p> <code>timezone</code> <p>The timezone to use for the schedule.</p> <p>If this is not specified then the system's local timezone will be used.</p> <p> TYPE: <code>typing.Optional[datetime.timezone]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>collections.Callable[[_CallbackSigT], tanjun.schedules.TimeSchedule[_CallbackSigT]]</code> <p>The decorator used to create the schedule.</p> <p>This should be decorating an asynchronous function which takes no positional arguments, returns None and may use dependency injection.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If months has any values outside the range of <code>range(1, 13)</code>.</li> <li>If days has any values outside the range of <code>range(1, 32)</code> when <code>weekly</code> is False or outside the range of <code>range(1, 7)</code> when <code>weekly</code> is True.</li> <li>If hours has any values outside the range of <code>range(0, 24)</code>.</li> <li>If minutes has any values outside the range of <code>range(0, 60)</code>.</li> <li>If seconds has any values outside the range of <code>range(0, 60)</code>.</li> </ul>"},{"location":"reference/#tanjun.as_unloader","title":"as_unloader","text":"<pre><code>as_unloader(callback=None, /, *, standard_impl=True)\n</code></pre> <p>Mark a callback as being used to unload a module's utilities from a client.</p> <p>Note</p> <p>This is the inverse of tanjun.as_loader and is only necessary if you wish to use the tanjun.Client.unload_modules or tanjun.Client.reload_modules.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback used to unload Tanjun components from a module.</p> <p>This should take one argument of type tanjun.Client (or tanjun.abc.Client if <code>standard_impl</code> is False), return nothing and will be expected to remove utilities such as components from the provided client.</p> <p> TYPE: <code>typing.Union[collections.Callable[[Client], None], collections.Callable[[tanjun.Client], None], None]</code> DEFAULT: <code>None</code> </p> <code>standard_impl</code> <p>Whether this unloader should only allow instances of tanjun.Client as opposed to tanjun.abc.Client.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.Client], None]]</code> <p>The decorated unload callback.</p>"},{"location":"reference/#tanjun.as_user_menu","title":"as_user_menu","text":"<pre><code>as_user_menu(name, /, *, always_defer=False, default_member_permissions=None, default_to_ephemeral=None, dm_enabled=None, is_global=True)\n</code></pre> <p>Build a user tanjun.MenuCommand by decorating a function.</p> <p>Note</p> <p>Under the standard implementation, <code>is_global</code> is used to determine whether the command should be bulk set by tanjun.Client.declare_global_commands or when <code>declare_global_commands</code> is True</p> <p>Note</p> <p>If you want your first response to be ephemeral while using <code>always_defer</code>, you must set <code>default_to_ephemeral</code> to <code>True</code>.</p> <p>Examples:</p> <pre><code>@as_user_menu(\"user\")\nasync def user_command(\n    self,\n    ctx: tanjun.abc.MenuContext,\n    user: hikari.User | hikari.InteractionMember,\n) -&gt; None:\n    await ctx.respond(f\"Hello {user}\")\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>The command's name (supports localisation).</p> <p>This must be between 1 and 32 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>always_defer</code> <p>Whether the contexts this command is executed with should always be deferred before being passed to the command's callback.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>default_member_permissions</code> <p>Member permissions necessary to utilize this command by default.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Union[hikari.Permissions, int, None]</code> DEFAULT: <code>None</code> </p> <code>default_to_ephemeral</code> <p>Whether this command's responses should default to ephemeral unless flags are set to override this.</p> <p>If this is left as None then the default set on the parent command(s), component or client will be in effect.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>dm_enabled</code> <p>Whether this command is enabled in DMs with the bot.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>is_global</code> <p>Whether this command is a global command.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MenuCallbackSig], MenuCommand]</code> <p>The decorator callback used to make a tanjun.MenuCommand.</p> <p>This can either wrap a raw command callback or another callable command instance (e.g. tanjun.MenuCommand, tanjun.MessageCommand, tanjun.SlashCommand) and will manage loading the other command into a component when using tanjun.Component.load_from_scope.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the command name isn't in the length range of 1 to 32.</li> <li>If the command name has uppercase characters.</li> </ul>"},{"location":"reference/#tanjun.cached_inject","title":"cached_inject","text":"<pre><code>cached_inject(callback, /, *, expire_after=None)\n</code></pre> <p>Inject a callback with caching.</p> <p>This acts like alluka.inject and the result of it should also be assigned to a parameter's default to be used.</p>"},{"location":"reference/#tanjun.cached_inject--example","title":"Example","text":"<pre><code>async def resolve_database(\n    client: tanjun.abc.Client = tanjun.inject(type=tanjun.abc.Client)\n) -&gt; Database:\n    raise NotImplementedError\n\n@tanjun.as_message_command(\"command name\")\nasync def command(\n    ctx: tanjun.abc.Context, db: Database = tanjun.cached_inject(resolve_database)\n) -&gt; None:\n    raise NotImplementedError\n</code></pre> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to inject.</p> <p> TYPE: <code>alluka.abc.CallbackSig[_T]</code> </p> <code>expire_after</code> <p>The amount of time to cache the result for in seconds.</p> <p>Leave this as None to cache for the runtime of the application.</p> <p> TYPE: <code>typing.Union[float, int, datetime.timedelta, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>alluka.InjectedDescriptor[_T]</code> <p>Injector used to resolve the cached callback.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If expire_after is not a valid value. If expire_after is not less than or equal to 0 seconds.</p>"},{"location":"reference/#tanjun.inject_lc","title":"inject_lc","text":"<pre><code>inject_lc(type_)\n</code></pre> <p>Make a LazyConstant injector.</p> <p>This acts like alluka.inject and the result of it should also be assigned to a parameter's default to be used.</p> <p>Note</p> <p>For this to work, a LazyConstant must've been set as a type dependency for the passed <code>type_</code>.</p> PARAMETER DESCRIPTION <code>type_</code> <p>The type of the constant to resolve.</p> <p> TYPE: <code>type[_T]</code> </p> RETURNS DESCRIPTION <code>alluka.InjectedDescriptor[_T]</code> <p>Injector used to resolve the LazyConstant.</p>"},{"location":"reference/#tanjun.inject_lc--example","title":"Example","text":"<pre><code>@component.with_command\n@tanjun.as_message_command\nasync def command(\n    ctx: tanjun.abc.MessageCommand,\n    application: hikari.Application = tanjun.inject_lc(hikari.Application)\n) -&gt; None:\n    raise NotImplementedError\n\n...\n\nasync def resolve_app(\n    client: tanjun.abc.Client = tanjun.inject(type=tanjun.abc.Client)\n) -&gt; hikari.Application:\n    raise NotImplementedError\n\ntanjun.Client.from_gateway_bot(...).set_type_dependency(\n    tanjun.LazyConstant[hikari.Application] = tanjun.LazyConstant(resolve_app)\n)\n</code></pre>"},{"location":"reference/#tanjun.slash_command_group","title":"slash_command_group","text":"<pre><code>slash_command_group(name, description, /, *, default_member_permissions=None, default_to_ephemeral=None, dm_enabled=None, is_global=True)\n</code></pre> <p>Create a slash command group.</p> <p>Note</p> <p>Unlike message command groups, slash command groups cannot be callable functions themselves.</p> <p>Warning</p> <p><code>default_member_permissions</code>, <code>dm_enabled</code> and <code>is_global</code> are ignored for command groups within other slash command groups.</p> <p>Note</p> <p>Under the standard implementation, <code>is_global</code> is used to determine whether the command should be bulk set by tanjun.Client.declare_global_commands or when <code>declare_global_commands</code> is True</p> <p>Examples:</p> <p>Sub-commands can be added to the created slash command object through the following decorator based approach:</p> <pre><code>help_group = tanjun.slash_command_group(\"help\", \"get help\")\n\n@tanjun.with_str_slash_option(\"command_name\", \"command name\")\n@help_group.as_sub_command(\"command\", \"Get help with a command\")\nasync def help_command_command(ctx: tanjun.abc.SlashContext, command_name: str) -&gt; None:\n    ...\n\n@help_group.as_sub_command(\"me\", \"help me\")\nasync def help_me_command(ctx: tanjun.abc.SlashContext) -&gt; None:\n    ...\n\ncomponent = tanjun.Component().add_slash_command(help_group)\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>The name of the command group (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The description of the command group (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>default_member_permissions</code> <p>Member permissions necessary to utilize this command by default.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Union[hikari.Permissions, int, None]</code> DEFAULT: <code>None</code> </p> <code>default_to_ephemeral</code> <p>Whether this command's responses should default to ephemeral unless flags are set to override this.</p> <p>If this is left as None then the default set on the parent command(s), component or client will be in effect.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>dm_enabled</code> <p>Whether this command is enabled in DMs with the bot.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>is_global</code> <p>Whether this command is a global command.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>SlashCommandGroup</code> <p>The command group.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the command name doesn't fit Discord's requirements.</li> <li>If the command name has uppercase characters.</li> <li>If the description is over 100 characters long.</li> </ul>"},{"location":"reference/#tanjun.to_bool","title":"to_bool","text":"<pre><code>to_bool(value)\n</code></pre> <p>Convert user string input into a boolean value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to convert.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>The converted value.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the value cannot be converted.</p>"},{"location":"reference/#tanjun.to_color","title":"to_color","text":"<pre><code>to_color(argument)\n</code></pre> <p>Convert user input to a hikari.colors.Color object.</p>"},{"location":"reference/#tanjun.to_datetime","title":"to_datetime","text":"<pre><code>to_datetime(value)\n</code></pre> <p>Parse a datetime from Discord's datetime format.</p> <p>More information on this format can be found at https://discord.com/developers/docs/reference#message-formatting-timestamp-styles</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to parse.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>datetime.datetime</code> <p>The parsed datetime.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the value cannot be parsed.</p>"},{"location":"reference/#tanjun.with_all_checks","title":"with_all_checks","text":"<pre><code>with_all_checks(check, /, *checks, follow_wrapped=False)\n</code></pre> <p>Add a check which will pass if all the provided checks pass through a decorator call.</p> <p>This ensures that the callbacks are run in the order they were supplied in rather than concurrently.</p> PARAMETER DESCRIPTION <code>check</code> <p>The first check callback to combine.</p> <p> TYPE: <code>tanjun.CheckSig[typing.Any]</code> </p> <code>*checks</code> <p>Additional check callbacks to combine.</p> <p> TYPE: <code>tanjun.CheckSig[typing.Any]</code> DEFAULT: <code>()</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.Context], collections.abc.Coroutine[typing.Any, typing.Any, bool]]</code> <p>A check which will pass if all of the provided check callbacks pass.</p>"},{"location":"reference/#tanjun.with_any_checks","title":"with_any_checks","text":"<pre><code>with_any_checks(check, /, *checks, error=None, error_message, follow_wrapped=False, halt_execution=False, suppress=(errors.CommandError, errors.HaltExecution))\n</code></pre> <p>Add a check which'll pass if any of the provided checks pass through a decorator call.</p> <p>This ensures that the callbacks are run in the order they were supplied in rather than concurrently.</p> PARAMETER DESCRIPTION <code>check</code> <p>The first check callback to combine.</p> <p> TYPE: <code>tanjun.CheckSig[typing.Any]</code> </p> <code>*checks</code> <p>Additional check callbacks to combine.</p> <p> TYPE: <code>tanjun.CheckSig[typing.Any]</code> DEFAULT: <code>()</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>This supports localisation and uses the check name <code>\"tanjun.any_check\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>suppress</code> <p>Tuple of the exceptions to suppress when a check fails.</p> <p> TYPE: <code>tuple[type[Exception], ...]</code> DEFAULT: <code>(errors.CommandError, errors.HaltExecution)</code> </p> RETURNS DESCRIPTION <code>collections.Callable[[tanjun.abc.ExecutableCommand], tanjun.abc.ExecutableCommand]</code> <p>A decorator which adds the generated check to a command.</p>"},{"location":"reference/#tanjun.with_argument","title":"with_argument","text":"<pre><code>with_argument(key, /, converters=(), *, default=tanjun.NO_DEFAULT, greedy=False, min_length=None, max_length=None, min_value=None, max_value=None, multi=False)\n</code></pre> <p>Add an argument to a message command through a decorator call.</p> <p>Warning</p> <p>Since order matters for positional arguments, you'll want to keep in mind that decorator execution starts at the decorator closest to the command and goes upwards with this deciding where a positional argument is located in a command's signature.</p> <p>Note</p> <p>If no parser is explicitly set on the command this is decorating before this decorator call then this will set ShlexParser as the parser.</p> <p>Examples:</p> <pre><code>import tanjun\n\n@tanjun.parsing.with_argument(\"command\", converters=int, default=42)\n@tanjun.parsing.with_parser\n@tanjun.component.as_message_command(\"command\")\nasync def command(self, ctx: tanjun.abc.Context, /, argument: int):\n    ...\n</code></pre> PARAMETER DESCRIPTION <code>key</code> <p>The string identifier of this argument (may be used to pass the result of this argument to the command's callback during execution).</p> <p> TYPE: <code>str</code> </p> <code>converters</code> <p>The converter(s) this argument should use to handle values passed to it during parsing.</p> <p>If no converters are provided then the raw string value will be passed.</p> <p>Only the first converter to pass will be used.</p> <p> TYPE: <code>_MaybeIterable[ConverterSig[typing.Any]]</code> DEFAULT: <code>()</code> </p> <code>default</code> <p>The default value of this argument, if left as tanjun.abc.NO_DEFAULT then this will have no default.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>greedy</code> <p>Whether or not this argument should be greedy (meaning that it takes in the remaining argument values).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>min_length</code> <p>Assert that a string argument's length is greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>max_length</code> <p>Assert that a string argument's length is less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>min_value</code> <p>Assert that the parsed value(s) for this argument are greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> <code>max_value</code> <p>Assert that the parsed value(s) for this argument are less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> <p>multi     Whether this argument can be passed multiple times.</p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MessageCommand], tanjun.abc.MessageCommand]</code> <p>Decorator function for the message command this argument is being added to.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>key</code> isn't valid for any of the commands this command's parser is linked to where <code>validate_arg_keys</code> is True.</p>"},{"location":"reference/#tanjun.with_attachment_slash_option","title":"with_attachment_slash_option","text":"<pre><code>with_attachment_slash_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None, pass_as_kwarg=True)\n</code></pre> <p>Add an attachment option to a slash command.</p> <p>For more information on this function's parameters see tanjun.SlashCommand.add_attachment_option.</p> <p>Examples:</p> <pre><code>@with_attachment_slash_option(\"name\", \"A name.\")\n@as_slash_command(\"command\", \"A command\")\nasync def command(self, ctx: tanjun.abc.SlashContext, name: hikari.Attachment) -&gt; None:\n    ...\n</code></pre> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.SlashCommand], tanjun.SlashCommand]</code> <p>Decorator callback which adds the option to the command.</p>"},{"location":"reference/#tanjun.with_author_permission_check","title":"with_author_permission_check","text":"<pre><code>with_author_permission_check(permissions, *, error=None, error_message=\"You don't have the permissions required to use this command\", follow_wrapped=False, halt_execution=False)\n</code></pre> <p>Only let a command run if the author has certain permissions in the current channel.</p> <p>Note</p> <p>This will only pass for commands in DMs if <code>permissions</code> is valid for a DM context (e.g. can't have any moderation permissions)</p> PARAMETER DESCRIPTION <code>permissions</code> <p>The permission(s) required for this command to run.</p> <p> TYPE: <code>typing.Union[hikari.Permissions, int]</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This should take 1 positional argument of type hikari.permissions.Permissions which represents the missing permissions required for this command to run.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[hikari.Permissions], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>Setting this to None will disable the error message allowing the command search to continue.</p> <p>This supports localisation and uses the check name <code>\"tanjun.AuthorPermissionCheck\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>\"You don't have the permissions required to use this command\"</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.ExecutableCommand], tanjun.abc.ExecutableCommand]</code> <p>A command decorator callback which adds the check.</p>"},{"location":"reference/#tanjun.with_bool_slash_option","title":"with_bool_slash_option","text":"<pre><code>with_bool_slash_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None, pass_as_kwarg=True)\n</code></pre> <p>Add a boolean option to a slash command.</p> <p>For information on this function's parameters see tanjun.SlashCommand.add_bool_option.</p> <p>Examples:</p> <pre><code>@with_bool_slash_option(\"flag\", \"Whether this flag should be enabled.\", default=False)\n@as_slash_command(\"command\", \"A command\")\nasync def command(self, ctx: tanjun.abc.SlashContext, flag: bool) -&gt; None:\n    ...\n</code></pre> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.SlashCommand], tanjun.SlashCommand]</code> <p>Decorator callback which adds the option to the command.</p>"},{"location":"reference/#tanjun.with_channel_slash_option","title":"with_channel_slash_option","text":"<pre><code>with_channel_slash_option(name, description, /, *, types=None, default=tanjun.NO_DEFAULT, key=None, pass_as_kwarg=True)\n</code></pre> <p>Add a channel option to a slash command.</p> <p>For information on this function's parameters see tanjun.SlashCommand.add_channel_option.</p> <p>Note</p> <p>This will always result in hikari.interactions.base_interactions.InteractionChannel.</p> <p>Examples:</p> <pre><code>@with_channel_slash_option(\"channel\", \"channel to target.\")\n@as_slash_command(\"command\", \"A command\")\nasync def command(self, ctx: tanjun.abc.SlashContext, channel: hikari.InteractionChannel) -&gt; None:\n    ...\n</code></pre> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.SlashCommand], tanjun.SlashCommand]</code> <p>Decorator callback which adds the option to the command.</p>"},{"location":"reference/#tanjun.with_check","title":"with_check","text":"<pre><code>with_check(check, /, *, follow_wrapped=False)\n</code></pre> <p>Add a generic check to a command.</p> PARAMETER DESCRIPTION <code>check</code> <p>The check to add to this command.</p> <p> TYPE: <code>tanjun.CheckSig[typing.Any]</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.ExecutableCommand], tanjun.abc.ExecutableCommand]</code> <p>A command decorator callback which adds the check.</p>"},{"location":"reference/#tanjun.with_concurrency_limit","title":"with_concurrency_limit","text":"<pre><code>with_concurrency_limit(bucket_id, /, *, error=None, error_message='This resource is currently busy; please try again later.', follow_wrapped=False)\n</code></pre> <p>Add the hooks used to manage a command's concurrency limit through a decorator call.</p> <p>Warning</p> <p>Concurrency limiters will only work if there's a setup injected AbstractConcurrencyLimiter dependency with InMemoryConcurrencyLimiter being usable as a standard in-memory concurrency manager.</p> PARAMETER DESCRIPTION <code>bucket_id</code> <p>The concurrency limit bucket's ID.</p> <p> TYPE: <code>str</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This should two one str argument which is the limiting bucket's ID.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[str], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if this fails to acquire the concurrency limit.</p> <p>This supports localisation and uses the check name <code>\"tanjun.concurrency\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> DEFAULT: <code>'This resource is currently busy; please try again later.'</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.ExecutableCommand], tanjun.abc.ExecutableCommand]</code> <p>A decorator that adds the concurrency limiter hooks to a command.</p>"},{"location":"reference/#tanjun.with_cooldown","title":"with_cooldown","text":"<pre><code>with_cooldown(bucket_id, /, *, error=None, error_message='This command is currently in cooldown. Try again {cooldown}.', follow_wrapped=False, owners_exempt=True)\n</code></pre> <p>Add a pre-execution hook used to manage a command's cooldown through a decorator call.</p> <p>Warning</p> <p>Cooldowns will only work if there's a setup injected AbstractCooldownManager dependency with InMemoryCooldownManager being usable as a standard in-memory cooldown manager.</p> PARAMETER DESCRIPTION <code>bucket_id</code> <p>The cooldown bucket's ID.</p> <p> TYPE: <code>str</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This should two arguments one of type str and datetime.datetime where the first is the limiting bucket's ID and the second is when said bucket can be used again.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[str, datetime.datetime], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>This supports localisation and uses the check name <code>\"tanjun.cooldown\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> DEFAULT: <code>'This command is currently in cooldown. Try again {cooldown}.'</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>owners_exempt</code> <p>Whether owners should be exempt from the cooldown.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.ExecutableCommand], tanjun.abc.ExecutableCommand]</code> <p>A decorator that adds a CooldownPreExecution hook to the command.</p>"},{"location":"reference/#tanjun.with_dm_check","title":"with_dm_check","text":"<pre><code>with_dm_check(command=None, /, *, error=None, error_message='Command can only be used in DMs', follow_wrapped=False, halt_execution=False)\n</code></pre> <p>Only let a command run in a DM channel.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add this check to.</p> <p> TYPE: <code>tanjun.abc.ExecutableCommand | None</code> DEFAULT: <code>None</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>Setting this to None will disable the error message allowing the command search to continue.</p> <p>This supports localisation and uses the check name <code>\"tanjun.DmCheck\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>'Command can only be used in DMs'</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.ExecutableCommand</code> <p>The command this check was added to.</p>"},{"location":"reference/#tanjun.with_float_slash_option","title":"with_float_slash_option","text":"<pre><code>with_float_slash_option(name, description, /, *, always_float=True, autocomplete=None, choices=None, converters=(), default=tanjun.NO_DEFAULT, key=None, min_value=None, max_value=None, pass_as_kwarg=True)\n</code></pre> <p>Add a float option to a slash command.</p> <p>For information on this function's parameters see tanjun.SlashCommand.add_float_option.</p> <p>Examples:</p> <pre><code>@with_float_slash_option(\"float_value\", \"Float value.\")\n@as_slash_command(\"command\", \"A command\")\nasync def command(self, ctx: tanjun.abc.SlashContext, float_value: float) -&gt; None:\n    ...\n</code></pre> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.SlashCommand], tanjun.SlashCommand]</code> <p>Decorator callback which adds the option to the command.</p>"},{"location":"reference/#tanjun.with_greedy_argument","title":"with_greedy_argument","text":"<pre><code>with_greedy_argument(key, /, converters=(), *, default=tanjun.NO_DEFAULT, min_length=None, max_length=None, min_value=None, max_value=None)\n</code></pre> <p>Add a greedy argument to a message command through a decorator call.</p> <p>A greedy argument will consume the remaining positional arguments and pass them through to the converters as one joined string while also requiring that at least one more positional argument is remaining unless a default is set.</p> <p>Warning</p> <p>Since order matters for positional arguments, you'll want to keep in mind that decorator execution starts at the decorator closest to the command and goes upwards with this deciding where a positional argument is located in a command's signature.</p> <p>Note</p> <p>If no parser is explicitly set on the command this is decorating before this decorator call then this will set ShlexParser as the parser.</p> <p>Examples:</p> <pre><code>import tanjun\n\n@tanjun.parsing.with_greedy_argument(\"command\", converters=StringView)\n@tanjun.parsing.with_parser\n@tanjun.component.as_message_command(\"command\")\nasync def command(self, ctx: tanjun.abc.Context, /, argument: StringView):\n    ...\n</code></pre> PARAMETER DESCRIPTION <code>key</code> <p>The string identifier of this argument (may be used to pass the result of this argument to the command's callback during execution).</p> <p> TYPE: <code>str</code> </p> <code>converters</code> <p>The converter(s) this argument should use to handle values passed to it during parsing.</p> <p>If no converters are provided then the raw string value will be passed.</p> <p>Only the first converter to pass will be used.</p> <p> TYPE: <code>_MaybeIterable[ConverterSig[typing.Any]]</code> DEFAULT: <code>()</code> </p> <code>default</code> <p>The default value of this argument, if left as tanjun.abc.NO_DEFAULT then this will have no default.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>min_length</code> <p>Assert that a string argument's length is greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>max_length</code> <p>Assert that a string argument's length is less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>min_value</code> <p>Assert that the parsed value(s) for this argument are greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> <code>max_value</code> <p>Assert that the parsed value(s) for this argument are less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MessageCommand], tanjun.abc.MessageCommand]</code> <p>Decorator function for the message command this argument is being added to.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>key</code> isn't valid for any of the commands this command's parser is linked to where <code>validate_arg_keys</code> is True.</p>"},{"location":"reference/#tanjun.with_guild_check","title":"with_guild_check","text":"<pre><code>with_guild_check(command=None, /, *, error=None, error_message='Command can only be used in guild channels', follow_wrapped=False, halt_execution=False)\n</code></pre> <p>Only let a command run in a guild channel.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add this check to.</p> <p> TYPE: <code>tanjun.abc.ExecutableCommand | None</code> DEFAULT: <code>None</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>Setting this to None will disable the error message allowing the command search to continue.</p> <p>This supports localisation and uses the check name <code>\"tanjun.GuildCheck\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>'Command can only be used in guild channels'</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.ExecutableCommanmd</code> <p>The command this check was added to.</p>"},{"location":"reference/#tanjun.with_int_slash_option","title":"with_int_slash_option","text":"<pre><code>with_int_slash_option(name, description, /, *, autocomplete=None, choices=None, converters=(), default=tanjun.NO_DEFAULT, key=None, min_value=None, max_value=None, pass_as_kwarg=True)\n</code></pre> <p>Add an integer option to a slash command.</p> <p>For information on this function's parameters see tanjun.SlashCommand.add_int_option.</p> <p>Examples:</p> <pre><code>@with_int_slash_option(\"int_value\", \"Int value.\")\n@as_slash_command(\"command\", \"A command\")\nasync def command(self, ctx: tanjun.abc.SlashContext, int_value: int) -&gt; None:\n    ...\n</code></pre> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.SlashCommand], tanjun.SlashCommand]</code> <p>Decorator callback which adds the option to the command.</p>"},{"location":"reference/#tanjun.with_member_slash_option","title":"with_member_slash_option","text":"<pre><code>with_member_slash_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None)\n</code></pre> <p>Add a member option to a slash command.</p> <p>For information on this function's arguments see tanjun.SlashCommand.add_member_option.</p> <p>Note</p> <p>This will always result in hikari.interactions.base_interactions.InteractionMember.</p> <p>Examples:</p> <pre><code>@with_member_slash_option(\"member\", \"member to target.\")\n@as_slash_command(\"command\", \"A command\")\nasync def command(self, ctx: tanjun.abc.SlashContext, member: hikari.InteractionMember) -&gt; None:\n    ...\n</code></pre> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.SlashCommand], tanjun.SlashCommand]</code> <p>Decorator callback which adds the option to the command.</p>"},{"location":"reference/#tanjun.with_mentionable_slash_option","title":"with_mentionable_slash_option","text":"<pre><code>with_mentionable_slash_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None, pass_as_kwarg=True)\n</code></pre> <p>Add a mentionable option to a slash command.</p> <p>For information on this function's arguments see tanjun.SlashCommand.add_mentionable_option.</p> <p>Note</p> <p>This may target roles, guild members or users and results in <code>hikari.User | hikari.InteractionMember | hikari.Role</code>.</p> <p>Examples:</p> <pre><code>@with_mentionable_slash_option(\"mentionable\", \"Mentionable entity to target.\")\n@as_slash_command(\"command\", \"A command\")\nasync def command(self, ctx: tanjun.abc.SlashContext, mentionable: [Role, InteractionMember, User]) -&gt; None:\n    ...\n</code></pre> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.SlashCommand], tanjun.SlashCommand]</code> <p>Decorator callback which adds the option to the command.</p>"},{"location":"reference/#tanjun.with_multi_argument","title":"with_multi_argument","text":"<pre><code>with_multi_argument(key, /, converters=(), *, default=tanjun.NO_DEFAULT, min_length=None, max_length=None, min_value=None, max_value=None)\n</code></pre> <p>Add a multi-argument to a message command through a decorator call.</p> <p>A multi argument will consume the remaining positional arguments and pass them to the converters through multiple calls while also requiring that at least one more positional argument is remaining unless a default is set and passing through the results to the command's callback as a sequence.</p> <p>Warning</p> <p>Since order matters for positional arguments, you'll want to keep in mind that decorator execution starts at the decorator closest to the command and goes upwards with this deciding where a positional argument is located in a command's signature.</p> <p>Note</p> <p>If no parser is explicitly set on the command this is decorating before this decorator call then this will set ShlexParser as the parser.</p> <p>Examples:</p> <pre><code>import tanjun\n\n@tanjun.parsing.with_multi_argument(\"command\", converters=int)\n@tanjun.parsing.with_parser\n@tanjun.component.as_message_command(\"command\")\nasync def command(self, ctx: tanjun.abc.Context, /, argument: collections.abc.Sequence[int]):\n    ...\n</code></pre> PARAMETER DESCRIPTION <code>key</code> <p>The string identifier of this argument (may be used to pass the result of this argument to the command's callback during execution).</p> <p> TYPE: <code>str</code> </p> <code>converters</code> <p>The converter(s) this argument should use to handle values passed to it during parsing.</p> <p>If no converters are provided then the raw string value will be passed.</p> <p>Only the first converter to pass will be used.</p> <p> TYPE: <code>_MaybeIterable[ConverterSig[typing.Any]]</code> DEFAULT: <code>()</code> </p> <code>default</code> <p>The default value of this argument, if left as tanjun.abc.NO_DEFAULT then this will have no default.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>min_length</code> <p>Assert that a string argument's length is greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>max_length</code> <p>Assert that a string argument's length is less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>min_value</code> <p>Assert that the parsed value(s) for this argument are greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> <code>max_value</code> <p>Assert that the parsed value(s) for this argument are less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MessageCommand], tanjun.abc.MessageCommand]</code> <p>Decorator function for the message command this argument is being added to.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>key</code> isn't valid for any of the commands this command's parser is linked to where <code>validate_arg_keys</code> is True.</p>"},{"location":"reference/#tanjun.with_multi_option","title":"with_multi_option","text":"<pre><code>with_multi_option(key, name, /, *names, converters=(), default, empty_value=tanjun.NO_DEFAULT, min_length=None, max_length=None, min_value=None, max_value=None)\n</code></pre> <p>Add an multi-option to a command's parser through a decorator call.</p> <p>A multi option will consume all the values provided for an option and pass them through to the converters as an array of strings while also requiring that at least one value is provided for the option unless a default is set.</p> <p>Note</p> <p>If no parser is explicitly set on the command this is decorating before this decorator call then this will set ShlexParser as the parser.</p> <p>Examples:</p> <pre><code>import tanjun\n\n@tanjun.parsing.with_multi_option(\"command\", converters=int, default=())\n@tanjun.parsing.with_parser\n@tanjun.component.as_message_command(\"command\")\nasync def command(self, ctx: tanjun.abc.Context, /, argument: collections.abc.Sequence[int]):\n    ...\n</code></pre> PARAMETER DESCRIPTION <code>key</code> <p>The string identifier of this option which will be used to pass the result of this argument to the command's callback during execution as a keyword argument.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>The name of this option used for identifying it in the parsed content.</p> <p> TYPE: <code>str</code> </p> <code>*names</code> <p>Other names of this option used for identifying it in the parsed content.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>default</code> <p>The default value of this argument, unlike arguments this is required for options.</p> <p> TYPE: <code>typing.Any</code> </p> <code>converters</code> <p>The converter(s) this argument should use to handle values passed to it during parsing.</p> <p>If no converters are provided then the raw string value will be passed.</p> <p>Only the first converter to pass will be used.</p> <p> TYPE: <code>_MaybeIterable[ConverterSig[typing.Any]]</code> DEFAULT: <code>()</code> </p> <code>empty_value</code> <p>The value to use if this option is provided without a value.</p> <p>If left as tanjun.abc.NO_DEFAULT then this option will error if it's provided without a value.</p> <p>tanjun.abc.NO_PASS is not supported for this.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>min_length</code> <p>Assert that a string argument's length is greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>max_length</code> <p>Assert that a string argument's length is less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>min_value</code> <p>Assert that the parsed value(s) for this option are greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> <code>max_value</code> <p>Assert that the parsed value(s) for this option are less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MessageCommand], tanjun.abc.MessageCommand]</code> <p>Decorator function for the message command this option is being added to.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>key</code> isn't valid for any of the commands this command's parser is linked to where <code>validate_arg_keys</code> is True.</p>"},{"location":"reference/#tanjun.with_nsfw_check","title":"with_nsfw_check","text":"<pre><code>with_nsfw_check(command=None, /, *, error=None, error_message='Command can only be used in NSFW channels', follow_wrapped=False, halt_execution=False)\n</code></pre> <p>Only let a command run in a channel that's marked as nsfw.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add this check to.</p> <p> TYPE: <code>tanjun.abc.ExecutableCommand | None</code> DEFAULT: <code>None</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>Setting this to None will disable the error message allowing the command search to continue.</p> <p>This supports localisation and uses the check name <code>\"tanjun.NsfwCheck\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>'Command can only be used in NSFW channels'</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.ExecutableCommand</code> <p>The command this check was added to.</p>"},{"location":"reference/#tanjun.with_option","title":"with_option","text":"<pre><code>with_option(key, name, /, *names, converters=(), default, empty_value=tanjun.NO_DEFAULT, min_length=None, max_length=None, min_value=None, max_value=None, multi=False)\n</code></pre> <p>Add an option to a message command through a decorator call.</p> <p>Note</p> <p>If no parser is explicitly set on the command this is decorating before this decorator call then this will set ShlexParser as the parser.</p> <p>Examples:</p> <pre><code>import tanjun\n\n@tanjun.parsing.with_option(\"command\", converters=int, default=42)\n@tanjun.parsing.with_parser\n@tanjun.component.as_message_command(\"command\")\nasync def command(self, ctx: tanjun.abc.Context, /, argument: int):\n    ...\n</code></pre> PARAMETER DESCRIPTION <code>key</code> <p>The string identifier of this option which will be used to pass the result of this argument to the command's callback during execution as a keyword argument.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>The name of this option used for identifying it in the parsed content.</p> <p> TYPE: <code>str</code> </p> <code>*names</code> <p>Other names of this option used for identifying it in the parsed content.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>default</code> <p>The default value of this argument, unlike arguments this is required for options.</p> <p> TYPE: <code>typing.Any</code> </p> <code>converters</code> <p>The converter(s) this argument should use to handle values passed to it during parsing.</p> <p>If no converters are provided then the raw string value will be passed.</p> <p>Only the first converter to pass will be used.</p> <p> TYPE: <code>_MaybeIterable[ConverterSig[typing.Any]]</code> DEFAULT: <code>()</code> </p> <code>empty_value</code> <p>The value to use if this option is provided without a value.</p> <p>If left as tanjun.abc.NO_DEFAULT then this option will error if it's provided without a value.</p> <p>tanjun.abc.NO_PASS is not supported for this.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>min_length</code> <p>Assert that a string argument's length is greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>max_length</code> <p>Assert that a string argument's length is less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>min_value</code> <p>Assert that the parsed value(s) for this option are greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> <code>max_value</code> <p>Assert that the parsed value(s) for this option are less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> <code>multi</code> <p>If this option can be provided multiple times.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MessageCommand], tanjun.abc.MessageCommand]</code> <p>Decorator function for the message command this option is being added to.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>key</code> isn't valid for any of the commands this command's parser is linked to where <code>validate_arg_keys</code> is True.</p>"},{"location":"reference/#tanjun.with_own_permission_check","title":"with_own_permission_check","text":"<pre><code>with_own_permission_check(permissions, *, error=None, error_message=\"Bot doesn't have the permissions required to run this command\", follow_wrapped=False, halt_execution=False)\n</code></pre> <p>Only let a command run if we have certain permissions in the current channel.</p> <p>Note</p> <p>This will only pass for commands in DMs if <code>permissions</code> is valid for a DM context (e.g. can't have any moderation permissions)</p> PARAMETER DESCRIPTION <code>permissions</code> <p>The permission(s) required for this command to run.</p> <p> TYPE: <code>typing.Union[hikari.Permissions, int]</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This should take 1 positional argument of type hikari.permissions.Permissions which represents the missing permissions required for this command to run.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[hikari.Permissions], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>Setting this to None will disable the error message allowing the command search to continue.</p> <p>This supports localisation and uses the check name <code>\"tanjun.OwnPermissionCheck\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>\"Bot doesn't have the permissions required to run this command\"</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.ExecutableCommand], tanjun.abc.ExecutableCommand]</code> <p>A command decorator callback which adds the check.</p>"},{"location":"reference/#tanjun.with_owner_check","title":"with_owner_check","text":"<pre><code>with_owner_check(command=None, /, *, error=None, error_message='Only bot owners can use this command', follow_wrapped=False, halt_execution=False)\n</code></pre> <p>Only let a command run if it's being triggered by one of the bot's owners.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add this check to.</p> <p> TYPE: <code>tanjun.abc.ExecutableCommand | None</code> DEFAULT: <code>None</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>Setting this to None will disable the error message allowing the command search to continue.</p> <p>This supports localisation and uses the check name <code>\"tanjun.OwnerCheck\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>'Only bot owners can use this command'</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.ExecutableCommand</code> <p>The command this check was added to.</p>"},{"location":"reference/#tanjun.with_parser","title":"with_parser","text":"<pre><code>with_parser(command)\n</code></pre> <p>Add a shlex parser command parser to a supported command.</p>"},{"location":"reference/#tanjun.with_parser--example","title":"Example","text":"<pre><code>@tanjun.with_argument(\"arg\", converters=int)\n@tanjun.with_parser\n@tanjun.as_message_command(\"hi\")\nasync def hi(ctx: tanjun.MessageContext, arg: int) -&gt; None:\n    ...\n</code></pre> PARAMETER DESCRIPTION <code>command</code> <p>The message command to set the parser on.</p> <p> TYPE: <code>_CommandT</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.MessageCommand</code> <p>The command with the parser set.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the command already has a parser set.</p>"},{"location":"reference/#tanjun.with_role_slash_option","title":"with_role_slash_option","text":"<pre><code>with_role_slash_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None, pass_as_kwarg=True)\n</code></pre> <p>Add a role option to a slash command.</p> <p>For information on this function's parameters see tanjun.SlashCommand.add_role_option.</p> <p>Examples:</p> <pre><code>@with_role_slash_option(\"role\", \"Role to target.\")\n@as_slash_command(\"command\", \"A command\")\nasync def command(self, ctx: tanjun.abc.SlashContext, role: hikari.Role) -&gt; None:\n    ...\n</code></pre> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.SlashCommand], tanjun.SlashCommand]</code> <p>Decorator callback which adds the option to the command.</p>"},{"location":"reference/#tanjun.with_sfw_check","title":"with_sfw_check","text":"<pre><code>with_sfw_check(command=None, /, *, error=None, error_message='Command can only be used in SFW channels', follow_wrapped=False, halt_execution=False)\n</code></pre> <p>Only let a command run in a channel that's marked as sfw.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add this check to.</p> <p> TYPE: <code>tanjun.abc.ExecutableCommand | None</code> DEFAULT: <code>None</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>Setting this to None will disable the error message allowing the command search to continue.</p> <p>This supports localisation and uses the check name <code>\"tanjun.SfwCheck\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>'Command can only be used in SFW channels'</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.ExecutableCommand</code> <p>The command this check was added to.</p>"},{"location":"reference/#tanjun.with_str_slash_option","title":"with_str_slash_option","text":"<pre><code>with_str_slash_option(name, description, /, *, autocomplete=None, choices=None, converters=(), default=tanjun.NO_DEFAULT, key=None, min_length=None, max_length=None, pass_as_kwarg=True)\n</code></pre> <p>Add a string option to a slash command.</p> <p>For more information on this function's parameters see tanjun.commands.SlashCommand.add_str_option.</p> <p>Examples:</p> <pre><code>@with_str_slash_option(\"name\", \"A name.\")\n@as_slash_command(\"command\", \"A command\")\nasync def command(self, ctx: tanjun.abc.SlashContext, name: str) -&gt; None:\n    ...\n</code></pre> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.SlashCommand], tanjun.SlashCommand]</code> <p>Decorator callback which adds the option to the command.</p>"},{"location":"reference/#tanjun.with_user_slash_option","title":"with_user_slash_option","text":"<pre><code>with_user_slash_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None, pass_as_kwarg=True)\n</code></pre> <p>Add a user option to a slash command.</p> <p>For information on this function's parameters see tanjun.SlashCommand.add_user_option.</p> <p>Note</p> <p>This may result in hikari.interactions.base_interactions.InteractionMember or hikari.users.User if the user isn't in the current guild or if this command was executed in a DM channel.</p> <p>Examples:</p> <pre><code>@with_user_slash_option(\"user\", \"user to target.\")\n@as_slash_command(\"command\", \"A command\")\nasync def command(self, ctx: tanjun.abc.SlashContext, user: Union[InteractionMember, User]) -&gt; None:\n    ...\n</code></pre> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.SlashCommand], tanjun.SlashCommand]</code> <p>Decorator callback which adds the option to the command.</p>"},{"location":"reference/abc/","title":"tanjun.abc","text":"<p>Interfaces of the objects and clients used within Tanjun.</p>"},{"location":"reference/abc/#tanjun.abc.AnyCheckSig","title":"AnyCheckSig  <code>module-attribute</code>","text":"<pre><code>AnyCheckSig = _CheckSig['Context', Ellipsis]\n</code></pre> <p>Type hint of a check callback for any command type.</p>"},{"location":"reference/abc/#tanjun.abc.AnyHooks","title":"AnyHooks  <code>module-attribute</code>","text":"<pre><code>AnyHooks = Hooks[Context]\n</code></pre> <p>Execution hooks for any context.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteCallbackSig","title":"AutocompleteCallbackSig  <code>module-attribute</code>","text":"<pre><code>AutocompleteCallbackSig = AutocompleteSig[_AutocompleteValueT]\n</code></pre> <p>Deprecated alias of tanjun.abc.AutocompleteSig.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteSig","title":"AutocompleteSig  <code>module-attribute</code>","text":"<pre><code>AutocompleteSig = _AutocompleteSig[_AutocompleteValueT, Ellipsis]\n</code></pre> <p>Type hint of the signature an autocomplete callback should have.</p> <p>This represents the signature <code>async def (tanjun.abc.AutocompleteContext, int | str | float) -&gt; None</code> where dependency injection is supported.</p>"},{"location":"reference/abc/#tanjun.abc.CheckSig","title":"CheckSig  <code>module-attribute</code>","text":"<pre><code>CheckSig = _CheckSig[_ContextT_contra, Ellipsis]\n</code></pre> <p>Type hint of a generic context check used with Tanjun commands.</p> <p>This may be registered with a command, client or component to add a rule which decides whether it should execute for each context passed to it.</p> <p>This represents the signatures <code>def (tanjun.abc.Context, ...) -&gt; bool | None</code> and <code>async def (tanjun.abc.Context, ...) -&gt; bool | None</code> where dependency injection is  supported.</p> <p>Check callbacks may either return False to indicate that the current command(s) don't match the context (without stopping execution) or raise tanjun.FailedCheck to indicate that command execution should be halted early and marked as not found.</p>"},{"location":"reference/abc/#tanjun.abc.CommandCallbackSig","title":"CommandCallbackSig  <code>module-attribute</code>","text":"<pre><code>CommandCallbackSig = collections.Callable[Ellipsis, _CoroT[None]]\n</code></pre> <p>Deprecated type hint used to represent any command callback.</p>"},{"location":"reference/abc/#tanjun.abc.ErrorHookSig","title":"ErrorHookSig  <code>module-attribute</code>","text":"<pre><code>ErrorHookSig = _ErrorHookSig[_ContextT_contra, Ellipsis]\n</code></pre> <p>Type hint of the callback used as a unexpected command error hook.</p> <p>This will be called whenever an unexpected Exception is raised during the execution stage of a command (ignoring tanjun.ParserError and expected tanjun.TanjunError subclasses).</p> <p>This represents the signatures <code>def (tanjun.abc.Context, Exception, ...) -&gt; bool | None</code> and <code>async def (tanjun.abc.Context, Exception, ...) -&gt; bool | None</code> where dependency injection is supported.</p> <p>True is returned to indicate that the exception should be suppressed and False is returned to indicate that the exception should be re-raised.</p>"},{"location":"reference/abc/#tanjun.abc.HookSig","title":"HookSig  <code>module-attribute</code>","text":"<pre><code>HookSig = _HookSig[_ContextT_contra, Ellipsis]\n</code></pre> <p>Type hint of the callback used as a general command hook.</p> <p>This represents the signatures <code>def (tanjun.abc.Context, ...) -&gt; None</code> and <code>async def (tanjun.abc.Context, ...) -&gt; None</code> where dependency injection is supported.</p>"},{"location":"reference/abc/#tanjun.abc.ListenerCallbackSig","title":"ListenerCallbackSig  <code>module-attribute</code>","text":"<pre><code>ListenerCallbackSig = _ListenerCallbackSig[_EventT, Ellipsis]\n</code></pre> <p>Type hint of a hikari event manager callback.</p> <p>This represents the signature <code>async def (hikari.Event, ...) -&gt; None</code> where dependency injection is supported.</p>"},{"location":"reference/abc/#tanjun.abc.MenuCallbackSig","title":"MenuCallbackSig  <code>module-attribute</code>","text":"<pre><code>MenuCallbackSig = _ManuCallbackSig['MenuContext', _MenuValueT, Ellipsis]\n</code></pre> <p>Type hint of a context menu command callback.</p> <p>This represents the signature <code>async def (tanjun.abc.MenuContext, hikari.Message, ...) -&gt; None</code> or <code>async def (tanjun.abc.MenuContext, hikari.InteractionMember, ...) -&gt;  None</code> where dependency injection is supported.</p>"},{"location":"reference/abc/#tanjun.abc.MenuCommandCallbackSig","title":"MenuCommandCallbackSig  <code>module-attribute</code>","text":"<pre><code>MenuCommandCallbackSig = MenuCallbackSig[_MenuValueT]\n</code></pre> <p>Deprecated alias of tanjun.abc.MenuCallbackSig.</p>"},{"location":"reference/abc/#tanjun.abc.MenuHooks","title":"MenuHooks  <code>module-attribute</code>","text":"<pre><code>MenuHooks = Hooks[MenuContext]\n</code></pre> <p>Execution hooks for menu commands.</p>"},{"location":"reference/abc/#tanjun.abc.MessageCallbackSig","title":"MessageCallbackSig  <code>module-attribute</code>","text":"<pre><code>MessageCallbackSig = _CommandCallbackSig['MessageContext', Ellipsis]\n</code></pre> <p>Type hint of a message command callback.</p> <p>This represents the signature <code>async def (tanjun.abc.MessageContext, ...) -&gt; None</code> where dependency injection is supported.</p>"},{"location":"reference/abc/#tanjun.abc.MessageHooks","title":"MessageHooks  <code>module-attribute</code>","text":"<pre><code>MessageHooks = Hooks[MessageContext]\n</code></pre> <p>Execution hooks for messages commands.</p>"},{"location":"reference/abc/#tanjun.abc.MetaEventSig","title":"MetaEventSig  <code>module-attribute</code>","text":"<pre><code>MetaEventSig = collections.Callable[Ellipsis, typing.Union[_CoroT[None], None]]\n</code></pre> <p>Type hint of a client callback.</p> <p>The positional arguments this is guaranteed depend on the event name its being subscribed to (more information the standard client callbacks can be found at tanjun.abc.ClientCallbackNames) and may be either synchronous or asynchronous but must return None.</p>"},{"location":"reference/abc/#tanjun.abc.NO_DEFAULT","title":"NO_DEFAULT  <code>module-attribute</code>","text":"<pre><code>NO_DEFAULT = _DefaultFlag.NO_DEFAULT\n</code></pre> <p>Singleton used to mark an argument as having no default.</p>"},{"location":"reference/abc/#tanjun.abc.NO_PASS","title":"NO_PASS  <code>module-attribute</code>","text":"<pre><code>NO_PASS = _DefaultFlag.NO_PASS\n</code></pre> <p>Singleton used to mark an argument as being not passed when it isn't provided.</p>"},{"location":"reference/abc/#tanjun.abc.ParserHookSig","title":"ParserHookSig  <code>module-attribute</code>","text":"<pre><code>ParserHookSig = _ParserHookSig[_ContextT_contra, Ellipsis]\n</code></pre> <p>Type hint of the callback used as a command parser error hook.</p> <p>This will be called whenever an parser ParserError is raised during the execution stage of a command.</p> <p>This represents the signatures <code>def (tanjun.abc.Context, tanjun.ParserError, ...) -&gt; None</code> and <code>async def (tanjun.abc.Context, tanjun.ParserError, ...) -&gt; None</code> where dependency injection is supported.</p> <p>Parser errors are always suppressed (unlike general errors).</p>"},{"location":"reference/abc/#tanjun.abc.SlashCallbackSig","title":"SlashCallbackSig  <code>module-attribute</code>","text":"<pre><code>SlashCallbackSig = _CommandCallbackSig['SlashContext', Ellipsis]\n</code></pre> <p>Type hint of a slash command callback.</p> <p>This represents the signature <code>async def (tanjun.abc.SlashContext, ...) -&gt; None</code> where dependency injection is supported.</p>"},{"location":"reference/abc/#tanjun.abc.SlashHooks","title":"SlashHooks  <code>module-attribute</code>","text":"<pre><code>SlashHooks = Hooks[SlashContext]\n</code></pre> <p>Execution hooks for slash commands.</p>"},{"location":"reference/abc/#tanjun.abc.AppCommand","title":"AppCommand","text":"<p>         Bases: <code>ExecutableCommand[_AppCommandContextT]</code></p> <p>Base class for all application command classes.</p>"},{"location":"reference/abc/#tanjun.abc.AppCommand.default_member_permissions","title":"default_member_permissions  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>default_member_permissions: typing.Optional[hikari.Permissions]\n</code></pre> <p>The default guild member permissions required to use this command.</p> <p>Warning</p> <p>This can be overridden by guild staff and does not apply to admins.</p> <p>Warning</p> <p>For commands within command groups the state of this flag is inherited regardless of what it's set as on the child command.</p>"},{"location":"reference/abc/#tanjun.abc.AppCommand.defaults_to_ephemeral","title":"defaults_to_ephemeral  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>defaults_to_ephemeral: typing.Optional[bool]\n</code></pre> <p>Whether contexts executed by this command should default to ephemeral responses.</p> <p>This effects calls to tanjun.abc.SlashContext.create_followup, tanjun.abc.SlashContext.create_initial_response, tanjun.abc.SlashContext.defer and tanjun.abc.SlashContext.respond unless the <code>flags</code> field is provided for the methods which support it.</p> <p>Note</p> <p>If this is None then the default from the parent command(s), component or client is used.</p>"},{"location":"reference/abc/#tanjun.abc.AppCommand.is_dm_enabled","title":"is_dm_enabled  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>is_dm_enabled: typing.Optional[bool]\n</code></pre> <p>Whether this command is enabled in DM contexts.</p> <p>Note</p> <p>If this is None then the default from the parent component or client is used.</p> <p>Warning</p> <p>For commands within command groups the state of this flag is inherited regardless of what it's set as on the child command.</p>"},{"location":"reference/abc/#tanjun.abc.AppCommand.is_global","title":"is_global  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>is_global: bool\n</code></pre> <p>Whether the command should be declared globally or not.</p> <p>Warning</p> <p>For commands within command groups the state of this flag is inherited regardless of what it's set as on the child command.</p>"},{"location":"reference/abc/#tanjun.abc.AppCommand.name","title":"name  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of the command.</p>"},{"location":"reference/abc/#tanjun.abc.AppCommand.tracked_command","title":"tracked_command  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>tracked_command: typing.Optional[hikari.PartialCommand]\n</code></pre> <p>Object of the actual command this object tracks if set.</p>"},{"location":"reference/abc/#tanjun.abc.AppCommand.tracked_command_id","title":"tracked_command_id  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>tracked_command_id: typing.Optional[hikari.Snowflake]\n</code></pre> <p>ID of the actual command this object tracks if set.</p>"},{"location":"reference/abc/#tanjun.abc.AppCommand.type","title":"type  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>type: hikari.CommandType\n</code></pre> <p>The type of this application command.</p>"},{"location":"reference/abc/#tanjun.abc.AppCommand.build","title":"build  <code>abstractmethod</code>","text":"<pre><code>build(*, component=None)\n</code></pre> <p>Get a builder object for this command.</p> PARAMETER DESCRIPTION <code>component</code> <p>The component to inherit config like <code>default_member_permissions</code> and <code>is_dm_enabled</code> from if not explicitly set on the command.</p> <p>This defaults to the command's linked component.</p> <p> TYPE: <code>typing.Optional[Component]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>hikari.api.CommandBuilder</code> <p>A builder object for this command. Use to declare this command on globally or for a specific guild.</p>"},{"location":"reference/abc/#tanjun.abc.AppCommand.set_tracked_command","title":"set_tracked_command  <code>abstractmethod</code>","text":"<pre><code>set_tracked_command(command)\n</code></pre> <p>Set the global command this tracks.</p> PARAMETER DESCRIPTION <code>command</code> <p>Object of the global command this tracks.</p> <p> TYPE: <code>hikari.PartialCommand</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command instance to enable chained calls.</p>"},{"location":"reference/abc/#tanjun.abc.AppCommandContext","title":"AppCommandContext","text":"<p>         Bases: <code>Context</code>, <code>abc.ABC</code></p> <p>Base class for application command contexts.</p>"},{"location":"reference/abc/#tanjun.abc.AppCommandContext.defaults_to_ephemeral","title":"defaults_to_ephemeral  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>defaults_to_ephemeral: bool\n</code></pre> <p>Whether the context is marked as defaulting to ephemeral response.</p> <p>This effects calls to tanjun.abc.SlashContext.create_followup, tanjun.abc.SlashContext.create_initial_response, tanjun.abc.SlashContext.defer and tanjun.abc.SlashContext.respond unless the <code>flags</code> field is provided for the methods which support it.</p>"},{"location":"reference/abc/#tanjun.abc.AppCommandContext.expires_at","title":"expires_at  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>expires_at: datetime.datetime\n</code></pre> <p>When this application command context expires.</p> <p>After this time is reached, the message/response methods on this context will always raise hikari.errors.NotFoundError.</p>"},{"location":"reference/abc/#tanjun.abc.AppCommandContext.has_been_deferred","title":"has_been_deferred  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>has_been_deferred: bool\n</code></pre> <p>Whether the initial response for this context has been deferred.</p> <p>Warning</p> <p>If this is True when tanjun.abc.SlashContext.has_responded is False then tanjun.abc.SlashContext.edit_initial_response will need to be used to create the initial response rather than tanjun.abc.SlashContext.create_initial_response.</p>"},{"location":"reference/abc/#tanjun.abc.AppCommandContext.interaction","title":"interaction  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>interaction: hikari.CommandInteraction\n</code></pre> <p>Interaction this context is for.</p>"},{"location":"reference/abc/#tanjun.abc.AppCommandContext.member","title":"member  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>member: typing.Optional[hikari.InteractionMember]\n</code></pre> <p>Object of the member that triggered this command if this is in a guild.</p>"},{"location":"reference/abc/#tanjun.abc.AppCommandContext.type","title":"type  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>type: hikari.CommandType\n</code></pre> <p>Type of application command this context is for.</p>"},{"location":"reference/abc/#tanjun.abc.AppCommandContext.create_followup","title":"create_followup  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>create_followup(content=hikari.UNDEFINED, *, delete_after=None, ephemeral=False, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED, tts=hikari.UNDEFINED, flags=hikari.UNDEFINED)\n</code></pre> <p>Create a followup response for this context.</p> <p>Warning</p> <p>Calling this on a context which hasn't had an initial response yet will lead to a hikari.errors.NotFoundError being raised.</p> PARAMETER DESCRIPTION <code>content</code> <p>If provided, the message contents. If hikari.undefined.UNDEFINED, then nothing will be sent in the content. Any other value here will be cast to a str.</p> <p>If this is a hikari.embeds.Embed and no <code>embed</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.files.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> <p> TYPE: <code>hikari.UndefinedOr[typing.Any]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>delete_after</code> <p>If provided, the seconds after which the response message should be deleted.</p> <p>Slash command responses can only be deleted within 15 minutes of the command being received.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, float, int, None]</code> DEFAULT: <code>None</code> </p> <code>ephemeral</code> <p>Whether the deferred response should be ephemeral.</p> <p>Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>attachment</code> <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Resourceish]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachments</code> <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Resourceish]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>component</code> <p>If provided, builder object of the component to include in this message.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.api.ComponentBuilder]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>components</code> <p>If provided, a sequence of the component builder objects to include in this message.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.api.ComponentBuilder]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embed</code> <p>If provided, the message embed.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Embed]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embeds</code> <p>If provided, the message embeds.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Embed]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>mentions_everyone</code> <p>If provided, whether the message should parse @everyone/@here mentions.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>user_mentions</code> <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.users.PartialUser derivatives to enforce mentioning specific users.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialUser], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>role_mentions</code> <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialRole], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>tts</code> <p>If provided, whether the message will be sent as a TTS message.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>flags</code> <p>The flags to set for this response.</p> <p>As of writing this can only flag which can be provided is EPHEMERAL, other flags are just ignored.</p> <p> TYPE: <code>typing.Union[hikari.UndefinedType, int, hikari.MessageFlag]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> RETURNS DESCRIPTION <code>hikari.Message</code> <p>The created message object.</p> RAISES DESCRIPTION <code>hikari.NotFoundError</code> <p>If the current interaction is not found or it hasn't had an initial response yet.</p> <code>hikari.BadRequestError</code> <p>This can be raised if the file is too large; if the embed exceeds the defined limits; if the message content is specified only and empty or greater than <code>2000</code> characters; if neither content, file or embeds are specified. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.</p> <code>ValueError</code> <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or `user_mentions.</p> <p>If the interaction will have expired before <code>delete_after</code> is reached.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p>"},{"location":"reference/abc/#tanjun.abc.AppCommandContext.create_initial_response","title":"create_initial_response  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>create_initial_response(content=hikari.UNDEFINED, *, delete_after=None, ephemeral=False, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED, flags=hikari.UNDEFINED, tts=hikari.UNDEFINED)\n</code></pre> <p>Create the initial response for this context.</p> <p>Warning</p> <p>Calling this on a context which already has an initial response will result in this raising a hikari.errors.NotFoundError. This includes if the REST interaction server has already responded to the request and deferrals.</p> PARAMETER DESCRIPTION <code>content</code> <p>The content to edit the last response with.</p> <p>If provided, the message contents. If hikari.undefined.UNDEFINED, then nothing will be sent in the content. Any other value here will be cast to a str.</p> <p>If this is a hikari.embeds.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.files.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> <p> TYPE: <code>hikari.UndefinedOr[typing.Any]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>delete_after</code> <p>If provided, the seconds after which the response message should be deleted.</p> <p>Slash command responses can only be deleted within 15 minutes of the command being received.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, float, int, None]</code> DEFAULT: <code>None</code> </p> <code>ephemeral</code> <p>Whether the deferred response should be ephemeral.</p> <p>Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>content</code> <p>If provided, the message contents. If hikari.undefined.UNDEFINED, then nothing will be sent in the content. Any other value here will be cast to a <code>str</code>.</p> <p>If this is a hikari.embeds.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p> TYPE: <code>hikari.UndefinedOr[typing.Any]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachment</code> <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Resourceish]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachments</code> <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Resourceish]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>component</code> <p>If provided, builder object of the component to include in this message.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.api.ComponentBuilder]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>components</code> <p>If provided, a sequence of the component builder objects to include in this message.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.api.ComponentBuilder]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embed</code> <p>If provided, the message embed.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Embed]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embeds</code> <p>If provided, the message embeds.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Embed]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>flags</code> <p>If provided, the message flags this response should have.</p> <p>As of writing the only message flag which can be set here is hikari.messages.MessageFlag.EPHEMERAL.</p> <p> TYPE: <code>typing.Union[int, hikari.MessageFlag, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>tts</code> <p>If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>mentions_everyone</code> <p>If provided, whether the message should parse @everyone/@here mentions.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>user_mentions</code> <p>If provided, and True, all user mentions will be detected. If provided, and False, all user mentions will be ignored if appearing in the message body.</p> <p>Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.users.PartialUser derivatives to enforce mentioning specific users.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialUser], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>role_mentions</code> <p>If provided, and True, all role mentions will be detected. If provided, and False, all role mentions will be ignored if appearing in the message body.</p> <p>Alternatively this may be a collection of [hikari.snowflakes.Snowflake], or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialRole], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If the interaction will have expired before <code>delete_after</code> is reached.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> <code>hikari.BadRequestError</code> <p>This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds.</p> <code>hikari.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.NotFoundError</code> <p>If the interaction is not found or if the interaction's initial response has already been created.</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/abc/#tanjun.abc.AppCommandContext.create_modal_response","title":"create_modal_response  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>create_modal_response(title, custom_id, /, *, component=hikari.UNDEFINED, components=hikari.UNDEFINED)\n</code></pre> <p>Send a modal as the initial response for this context.</p> <p>Warning</p> <p>This must be called as the first response to a context before any deferring.</p> PARAMETER DESCRIPTION <code>title</code> <p>The title that will show up in the modal.</p> <p> TYPE: <code>str</code> </p> <code>custom_id</code> <p>Developer set custom ID used for identifying interactions with this modal.</p> <p> TYPE: <code>str</code> </p> <code>component</code> <p>A component builder to send in this modal.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.api.ComponentBuilder]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>components</code> <p>A sequence of component builders to send in this modal.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.api.ComponentBuilder]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If both <code>component</code> and <code>components</code> are specified or if none are specified.</p> <code>hikari.BadRequestError</code> <p>When the requests' data is outside Discord's accept ranges/validation.</p> <code>hikari.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.NotFoundError</code> <p>If the interaction is not found or if the interaction's initial response has already been created or deferred.</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/abc/#tanjun.abc.AppCommandContext.defer","title":"defer  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>defer(*, ephemeral=False, flags=hikari.UNDEFINED)\n</code></pre> <p>Defer the initial response for this context.</p> <p>Note</p> <p>The ephemeral state of the first response is decided by whether the deferral is ephemeral.</p> PARAMETER DESCRIPTION <code>ephemeral</code> <p>Whether the deferred response should be ephemeral.</p> <p>Passing True here is a shorthand for including <code>1 &lt;&lt; 64</code> in the passed flags.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>flags</code> <p>The flags to use for the initial response.</p> <p> TYPE: <code>typing.Union[hikari.UndefinedType, int, hikari.MessageFlag]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p>"},{"location":"reference/abc/#tanjun.abc.AppCommandContext.mark_not_found","title":"mark_not_found  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>mark_not_found()\n</code></pre> <p>Mark this context as not found.</p> <p>Dependent on how the client is configured this may lead to a not found response message being sent.</p>"},{"location":"reference/abc/#tanjun.abc.AppCommandContext.set_ephemeral_default","title":"set_ephemeral_default  <code>abstractmethod</code>","text":"<pre><code>set_ephemeral_default(state)\n</code></pre> <p>Set the ephemeral default state for this context.</p> PARAMETER DESCRIPTION <code>state</code> <p>The new ephemeral default state.</p> <p>If this is True then all calls to the response creating methods on this context will default to being ephemeral.</p> <p> TYPE: <code>bool</code> </p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext","title":"AutocompleteContext","text":"<p>         Bases: <code>alluka.Context</code></p> <p>Interface of an autocomplete context.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext.author","title":"author  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>author: hikari.User\n</code></pre> <p>Object of the user who triggered this autocomplete.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext.cache","title":"cache  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>cache: typing.Optional[hikari.api.Cache]\n</code></pre> <p>Hikari cache instance this context's client was initialised with.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext.channel_id","title":"channel_id  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>channel_id: hikari.Snowflake\n</code></pre> <p>ID of the channel this autocomplete was triggered in.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext.client","title":"client  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>client: Client\n</code></pre> <p>Tanjun tanjun.abc.Client implementation this context was spawned by.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext.created_at","title":"created_at  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>created_at: datetime.datetime\n</code></pre> <p>When this context was created.</p> <p>Note</p> <p>This will either refer to a message or integration's creation date.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext.events","title":"events  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>events: typing.Optional[hikari.api.EventManager]\n</code></pre> <p>Object of the event manager this context's client was initialised with.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext.focused","title":"focused  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>focused: hikari.AutocompleteInteractionOption\n</code></pre> <p>The option being autocompleted.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext.guild_id","title":"guild_id  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>guild_id: typing.Optional[hikari.Snowflake]\n</code></pre> <p>ID of the guild this autocomplete was triggered in.</p> <p>Will be None for all DM autocomplete executions.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext.has_responded","title":"has_responded  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>has_responded: bool\n</code></pre> <p>Whether the choices have been set for this autocomplete.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext.interaction","title":"interaction  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>interaction: hikari.AutocompleteInteraction\n</code></pre> <p>Interaction this context is for.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext.member","title":"member  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>member: typing.Optional[hikari.Member]\n</code></pre> <p>Guild member object of this autocomplete's author.</p> <p>Will be None for DM autocomplete executions.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext.options","title":"options  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>options: collections.Mapping[str, hikari.AutocompleteInteractionOption]\n</code></pre> <p>Mapping of option names to the values provided for them.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext.rest","title":"rest  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>rest: hikari.api.RESTClient\n</code></pre> <p>Object of the Hikari REST client this context's client was initialised with.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext.server","title":"server  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>server: typing.Optional[hikari.api.InteractionServer]\n</code></pre> <p>Object of the Hikari interaction server provided for this context's client.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext.shard","title":"shard  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>shard: typing.Optional[hikari.api.GatewayShard]\n</code></pre> <p>Shard that triggered the context.</p> <p>Note</p> <p>This will be None if tanjun.abc.AutocompleteContext.shards is also None.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext.shards","title":"shards  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>shards: typing.Optional[hikari.ShardAware]\n</code></pre> <p>Object of the Hikari shard manager this context's client was initialised with.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext.triggering_name","title":"triggering_name  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>triggering_name: str\n</code></pre> <p>Full command name this autocomplete was triggered for.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext.voice","title":"voice  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>voice: typing.Optional[hikari.api.VoiceComponent]\n</code></pre> <p>Object of the Hikari voice component this context's client was initialised with.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext.fetch_channel","title":"fetch_channel  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>fetch_channel()\n</code></pre> <p>Fetch the channel the context was invoked in.</p> <p>Note</p> <p>This performs an API call. Consider using tanjun.abc.AutocompleteContext.get_channel if you have hikari.api.config.CacheComponents.GUILD_CHANNELS cache component enabled.</p> RETURNS DESCRIPTION <code>hikari.TextableChannel</code> <p>The textable DM or guild channel the context was invoked in.</p> RAISES DESCRIPTION <code>hikari.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.ForbiddenError</code> <p>If you are missing the <code>READ_MESSAGES</code> permission in the channel.</p> <code>hikari.NotFoundError</code> <p>If the channel is not found.</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext.fetch_guild","title":"fetch_guild  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>fetch_guild()\n</code></pre> <p>Fetch the guild the context was invoked in.</p> <p>Note</p> <p>This performs an API call. Consider using tanjun.abc.AutocompleteContext.get_guild if you have hikari.api.config.CacheComponents.GUILDS cache component enabled.</p> RETURNS DESCRIPTION <code>hikari.Guild | None</code> <p>An optional guild the context was invoked in. None will be returned if the context was invoked in a DM channel.</p> RAISES DESCRIPTION <code>hikari.ForbiddenError</code> <p>If you are not part of the guild.</p> <code>hikari.NotFoundError</code> <p>If the guild is not found.</p> <code>hikari.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext.get_channel","title":"get_channel  <code>abstractmethod</code>","text":"<pre><code>get_channel()\n</code></pre> <p>Retrieve the channel the context was invoked in from the cache.</p> <p>Note</p> <p>This method requires the hikari.api.config.CacheComponents.GUILD_CHANNELS cache component.</p> RETURNS DESCRIPTION <code>hikari.TextableGuildChannel | None</code> <p>An optional guild channel the context was invoked in. None will be returned if the channel was not found or if it is DM channel.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext.get_guild","title":"get_guild  <code>abstractmethod</code>","text":"<pre><code>get_guild()\n</code></pre> <p>Fetch the guild that the context was invoked in.</p> <p>Note</p> <p>This method requires hikari.api.config.CacheComponents.GUILDS cache component enabled.</p> RETURNS DESCRIPTION <code>hikari.Guild | None</code> <p>An optional guild the context was invoked in. None will be returned if the guild was not found.</p>"},{"location":"reference/abc/#tanjun.abc.AutocompleteContext.set_choices","title":"set_choices  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>set_choices(choices=Ellipsis, /, **kwargs)\n</code></pre> <p>Set the choices for this autocomplete.</p> <p>Note</p> <p>Only up to (and including) 25 choices may be set for an autocomplete.</p> PARAMETER DESCRIPTION <code>choices</code> <p>Mapping of string option names to their values.</p> <p>The values should match the focused option's relevant type.</p> <p> TYPE: <code>collections.abc.Mapping[str, str | float | int]</code> DEFAULT: <code>Ellipsis</code> </p> <code>**kwargs</code> <p>Keyword arguments mapping string option names to their values.</p> <p>The value should match the focused option's relevant type.</p> <p> TYPE: <code>str | float | int</code> DEFAULT: <code>{}</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the context has already had the choices set for it.</p> <code>ValueError</code> <p>If more than 25 choices are passed.</p>"},{"location":"reference/abc/#tanjun.abc.BaseSlashCommand","title":"BaseSlashCommand","text":"<p>         Bases: <code>AppCommand[SlashContext]</code>, <code>abc.ABC</code></p> <p>Base class for all slash command classes.</p>"},{"location":"reference/abc/#tanjun.abc.BaseSlashCommand.parent","title":"parent  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>parent: typing.Optional[SlashCommandGroup]\n</code></pre> <p>Object of the group this command is in.</p>"},{"location":"reference/abc/#tanjun.abc.BaseSlashCommand.tracked_command","title":"tracked_command  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>tracked_command: typing.Optional[hikari.SlashCommand]\n</code></pre> <p>Object of the actual command this object tracks if set.</p>"},{"location":"reference/abc/#tanjun.abc.BaseSlashCommand.type","title":"type  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>type: typing.Literal[hikari.CommandType.SLASH]\n</code></pre> <p>The type of this command.</p>"},{"location":"reference/abc/#tanjun.abc.BaseSlashCommand.build","title":"build  <code>abstractmethod</code>","text":"<pre><code>build(*, component=None)\n</code></pre> <p>Get a builder object for this command.</p> PARAMETER DESCRIPTION <code>component</code> <p>The component to inherit config like <code>default_member_permissions</code> and <code>is_dm_enabled</code> from if not explicitly set on the command.</p> <p>This defaults to the command's linked component.</p> <p> TYPE: <code>typing.Optional[Component]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>hikari.api.SlashCommandBuilder</code> <p>A builder object for this command. Use to declare this command on globally or for a specific guild.</p>"},{"location":"reference/abc/#tanjun.abc.BaseSlashCommand.copy","title":"copy  <code>abstractmethod</code>","text":"<pre><code>copy(*, parent=None)\n</code></pre> <p>Create a copy of this command.</p> PARAMETER DESCRIPTION <code>parent</code> <p>The parent of the copy.</p> <p> TYPE: <code>typing.Optional[SlashCommandGroup]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The copy.</p>"},{"location":"reference/abc/#tanjun.abc.Client","title":"Client","text":"<p>         Bases: <code>abc.ABC</code></p> <p>Abstract interface of a Tanjun client.</p> <p>This should manage both message and slash command execution based on the provided hikari clients.</p>"},{"location":"reference/abc/#tanjun.abc.Client.cache","title":"cache  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>cache: typing.Optional[hikari.api.Cache]\n</code></pre> <p>Hikari cache instance this command client was initialised with.</p>"},{"location":"reference/abc/#tanjun.abc.Client.components","title":"components  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>components: collections.Collection[Component]\n</code></pre> <p>Collection of the components this command client is using.</p>"},{"location":"reference/abc/#tanjun.abc.Client.default_app_cmd_permissions","title":"default_app_cmd_permissions  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>default_app_cmd_permissions: hikari.Permissions\n</code></pre> <p>Default required guild member permissions for the commands in this client.</p> <p>This may be overridden by tanjun.abc.Component.default_app_cmd_permissions and tanjun.abc.AppCommand.default_member_permissions; this defaults to no required permissions.</p> <p>Warning</p> <p>This may be overridden by guild staff and does not apply to admins.</p>"},{"location":"reference/abc/#tanjun.abc.Client.defaults_to_ephemeral","title":"defaults_to_ephemeral  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>defaults_to_ephemeral: bool\n</code></pre> <p>Whether slash contexts spawned by this client should default to ephemeral responses.</p> <p>This effects calls to tanjun.abc.SlashContext.create_followup, tanjun.abc.SlashContext.create_initial_response, tanjun.abc.SlashContext.defer and tanjun.abc.SlashContext.respond unless the <code>flags</code> field is provided for the methods which support it.</p> <p>This defaults to False.</p> <p>Note</p> <p>This may be overridden by tanjun.abc.AppCommand.defaults_to_ephemeral and tanjun.abc.Component.defaults_to_ephemeral and only effects slash command execution.</p>"},{"location":"reference/abc/#tanjun.abc.Client.dms_enabled_for_app_cmds","title":"dms_enabled_for_app_cmds  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>dms_enabled_for_app_cmds: bool\n</code></pre> <p>Whether application commands in this client should be enabled in DMs by default.</p> <p>This defaults to True.</p> <p>Note</p> <p>This may be overridden by tanjun.abc.AppCommand.is_dm_enabled and tanjun.abc.Component.dms_enabled_for_app_cmds.</p>"},{"location":"reference/abc/#tanjun.abc.Client.events","title":"events  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>events: typing.Optional[hikari.api.EventManager]\n</code></pre> <p>Object of the event manager this client was initialised with.</p> <p>This is used for executing message commands if set.</p>"},{"location":"reference/abc/#tanjun.abc.Client.injector","title":"injector  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>injector: alluka.Client\n</code></pre> <p>The attached alluka dependency injection client.</p>"},{"location":"reference/abc/#tanjun.abc.Client.is_alive","title":"is_alive  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>is_alive: bool\n</code></pre> <p>Whether this client is alive.</p>"},{"location":"reference/abc/#tanjun.abc.Client.is_case_sensitive","title":"is_case_sensitive  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>is_case_sensitive: bool\n</code></pre> <p>Whether this client should treat message command names case sensitive in search.</p>"},{"location":"reference/abc/#tanjun.abc.Client.listeners","title":"listeners  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>listeners: collections.Mapping[type[hikari.Event], collections.Collection[ListenerCallbackSig[typing.Any]]]\n</code></pre> <p>Mapping of event types to the listeners registered in this client.</p>"},{"location":"reference/abc/#tanjun.abc.Client.loop","title":"loop  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>loop: typing.Optional[asyncio.AbstractEventLoop]\n</code></pre> <p>The loop this client is bound to if it's alive.</p>"},{"location":"reference/abc/#tanjun.abc.Client.metadata","title":"metadata  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>metadata: collections.MutableMapping[typing.Any, typing.Any]\n</code></pre> <p>Mutable mapping of the metadata set for this client.</p> <p>Note</p> <p>Any modifications made to this mutable mapping will be preserved by the client.</p>"},{"location":"reference/abc/#tanjun.abc.Client.prefixes","title":"prefixes  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>prefixes: collections.Collection[str]\n</code></pre> <p>Collection of the prefixes set for this client.</p> <p>These are only use during message command execution to match commands to this command client.</p>"},{"location":"reference/abc/#tanjun.abc.Client.rest","title":"rest  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>rest: hikari.api.RESTClient\n</code></pre> <p>Object of the Hikari REST client this client was initialised with.</p>"},{"location":"reference/abc/#tanjun.abc.Client.server","title":"server  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>server: typing.Optional[hikari.api.InteractionServer]\n</code></pre> <p>Object of the Hikari interaction server provided for this client.</p> <p>This is used for executing application commands if set.</p>"},{"location":"reference/abc/#tanjun.abc.Client.shards","title":"shards  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>shards: typing.Optional[hikari.ShardAware]\n</code></pre> <p>Object of the Hikari shard manager this client was initialised with.</p>"},{"location":"reference/abc/#tanjun.abc.Client.voice","title":"voice  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>voice: typing.Optional[hikari.api.VoiceComponent]\n</code></pre> <p>Object of the Hikari voice component this client was initialised with.</p>"},{"location":"reference/abc/#tanjun.abc.Client.add_client_callback","title":"add_client_callback  <code>abstractmethod</code>","text":"<pre><code>add_client_callback(name, /, *callbacks)\n</code></pre> <p>Add a client callback.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name this callback is being registered to.</p> <p>This is case-insensitive.</p> <p> TYPE: <code>typing.Union[str, ClientCallbackNames]</code> </p> <code>*callbacks</code> <p>The callbacks to register.</p> <p>These may be sync or async and must return None. The positional and keyword arguments a callback should expect depend on implementation detail around the <code>name</code> being subscribed to.</p> <p> TYPE: <code>MetaEventSig</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/abc/#tanjun.abc.Client.add_component","title":"add_component  <code>abstractmethod</code>","text":"<pre><code>add_component(component)\n</code></pre> <p>Add a component to this client.</p> PARAMETER DESCRIPTION <code>component</code> <p>The component to move to this client.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to allow chained calls.</p>"},{"location":"reference/abc/#tanjun.abc.Client.add_listener","title":"add_listener  <code>abstractmethod</code>","text":"<pre><code>add_listener(event_type, /, *callbacks)\n</code></pre> <p>Add a listener to the client.</p> PARAMETER DESCRIPTION <code>event_type</code> <p>The event type to add a listener for.</p> <p> TYPE: <code>type[hikari.events.base_events.Event]</code> </p> <code>*callbacks</code> <p>The callbacks to register as a listener.</p> <p>These callbacks must be coroutine functions which returns None and always takes one positional arg of the event type passed for <code>event_type</code> regardless of client implementation detail.</p> <p> TYPE: <code>ListenerCallbackSig[_EventT]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/abc/#tanjun.abc.Client.check_message_name","title":"check_message_name  <code>abstractmethod</code>","text":"<pre><code>check_message_name(name, /, *, case_sensitive=True)\n</code></pre> <p>Check whether a message command name is present in the current client.</p> <p>Note</p> <p>Dependent on implementation this may partial check name against the message command's name based on command_name.startswith(name).</p> PARAMETER DESCRIPTION <code>name</code> <p>The name to match commands against.</p> <p> TYPE: <code>str</code> </p> <code>case_sensitive</code> <p>Whether to match case sensitively.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Iterator[tuple[str, MessageCommand]]</code> <p>Iterator of the matched command names to the matched message command objects.</p>"},{"location":"reference/abc/#tanjun.abc.Client.check_slash_name","title":"check_slash_name  <code>abstractmethod</code>","text":"<pre><code>check_slash_name(name)\n</code></pre> <p>Check whether a slash command name is present in the current client.</p> <p>Note</p> <p>This won't check the commands within command groups.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name to check against.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>collections.abc.Iterator[BaseSlashCommand]</code> <p>Iterator of the matched slash command objects.</p>"},{"location":"reference/abc/#tanjun.abc.Client.clear_application_commands","title":"clear_application_commands  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>clear_application_commands(*, application=None, guild=hikari.UNDEFINED)\n</code></pre> <p>Clear the commands declared either globally or for a specific guild.</p> <p>Note</p> <p>The endpoint this uses has a strict ratelimit which, as of writing, only allows for 2 requests per minute (with that ratelimit either being per-guild if targeting a specific guild otherwise globally).</p> PARAMETER DESCRIPTION <code>application</code> <p>The application to clear commands for.</p> <p>If left as None then this will be inferred from the authorization being used by tanjun.abc.Client.rest.</p> <p> TYPE: <code>typing.Optional[hikari.SnowflakeishOr[hikari.PartialApplication]]</code> DEFAULT: <code>None</code> </p> <code>guild</code> <p>Object or ID of the guild to clear commands for.</p> <p>If left as None global commands will be cleared.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.SnowflakeishOr[hikari.PartialGuild]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p>"},{"location":"reference/abc/#tanjun.abc.Client.declare_application_command","title":"declare_application_command  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>declare_application_command(command, /, command_id=None, *, application=None, guild=hikari.UNDEFINED)\n</code></pre> <p>Declare a single slash command for a bot.</p> <p>Warning</p> <p>Providing <code>command_id</code> when updating a command helps avoid any permissions set for the command being lose (e.g. when changing the command's name).</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to register.</p> <p> TYPE: <code>AppCommand[typing.Any]</code> </p> <code>application</code> <p>The application to register the command with.</p> <p>If left as None then this will be inferred from the authorization being used by tanjun.abc.Client.rest.</p> <p> TYPE: <code>typing.Optional[hikari.SnowflakeishOr[hikari.PartialApplication]]</code> DEFAULT: <code>None</code> </p> <code>command_id</code> <p>ID of the command to update.</p> <p> TYPE: <code>typing.Optional[hikari.Snowflakeish]</code> DEFAULT: <code>None</code> </p> <code>guild</code> <p>Object or ID of the guild to register the command with.</p> <p>If left as None then the command will be registered globally.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.SnowflakeishOr[hikari.PartialGuild]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> RETURNS DESCRIPTION <code>hikari.PartialCommand</code> <p>API representation of the command that was registered.</p>"},{"location":"reference/abc/#tanjun.abc.Client.declare_application_commands","title":"declare_application_commands  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>declare_application_commands(commands, /, command_ids=None, *, application=None, guild=hikari.UNDEFINED, message_ids=None, user_ids=None, force=False)\n</code></pre> <p>Declare a collection of slash commands for a bot.</p> <p>Note</p> <p>The endpoint this uses has a strict ratelimit which, as of writing, only allows for 2 requests per minute (with that ratelimit either being per-guild if targeting a specific guild otherwise globally).</p> PARAMETER DESCRIPTION <code>commands</code> <p>Iterable of the commands objects or builders to register.</p> <p> TYPE: <code>collections.Iterable[typing.Union[AppCommand[typing.Any], hikari.api.CommandBuilder]]</code> </p> <code>command_ids</code> <p>If provided, a mapping of top level command names to IDs of the existing commands to update.</p> <p>This will be used for all application commands but in cases where commands have overlapping names, <code>message_ids</code> and <code>user_ids</code> will take priority over this for their relevant command type.</p> <p>While optional, this can be helpful when updating commands as providing the current IDs will prevent changes such as renames from leading to other state set for commands (e.g. permissions) from being lost.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p> <code>application</code> <p>The application to register the commands with.</p> <p>If left as None then this will be inferred from the authorization being used by tanjun.abc.Client.rest.</p> <p> TYPE: <code>typing.Optional[hikari.SnowflakeishOr[hikari.PartialApplication]]</code> DEFAULT: <code>None</code> </p> <code>guild</code> <p>Object or ID of the guild to register the commands with.</p> <p>If left as None then the commands will be registered globally.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.SnowflakeishOr[hikari.PartialGuild]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>message_ids</code> <p>If provided, a mapping of message context menu command names to the IDs of existing commands to update.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p> <code>user_ids</code> <p>If provided, a mapping of user context menu command names to the IDs of existing commands to update.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p> <code>force</code> <p>Force this to declare the commands regardless of whether or not they match the current state of the declared commands.</p> <p>The default behaviour helps avoid issues with the 2 request per minute (per-guild or globally) ratelimit and the other limit of only 200 application command creates per day (per guild or globally).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>collections.abc.Sequence[hikari.PartialCommand]</code> <p>API representations of the commands which were registered.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If conflicting command names are found (multiple commanbds have the same top-level name).</li> <li>If more than 100 top-level commands are passed.</li> </ul>"},{"location":"reference/abc/#tanjun.abc.Client.declare_global_commands","title":"declare_global_commands  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>declare_global_commands(command_ids=None, *, application=None, guild=hikari.UNDEFINED, message_ids=None, user_ids=None, force=False)\n</code></pre> <p>Set the global application commands for a bot based on the loaded components.</p> <p>Warning</p> <p>This will overwrite any previously set application commands and only targets commands marked as global.</p> <p>Note</p> <p>The endpoint this uses has a strict ratelimit which, as of writing, only allows for 2 requests per minute (with that ratelimit either being per-guild if targeting a specific guild otherwise globally).</p> PARAMETER DESCRIPTION <code>command_ids</code> <p>If provided, a mapping of top level command names to IDs of the existing commands to update.</p> <p>This will be used for all application commands but in cases where commands have overlapping names, <code>message_ids</code> and <code>user_ids</code> will take priority over this for their relevant command type.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p> <code>application</code> <p>Object or ID of the application to set the global commands for.</p> <p>If left as None then this will be inferred from the authorization being used by tanjun.abc.Client.rest.</p> <p> TYPE: <code>typing.Optional[hikari.SnowflakeishOr[hikari.PartialApplication]]</code> DEFAULT: <code>None</code> </p> <code>guild</code> <p>Object or ID of the guild to set the global commands to.</p> <p>If left as None global commands will be set.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.SnowflakeishOr[hikari.PartialGuild]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>message_ids</code> <p>If provided, a mapping of message context menu command names to the IDs of existing commands to update.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p> <code>user_ids</code> <p>If provided, a mapping of user context menu command names to the IDs of existing commands to update.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p> <code>force</code> <p>Force this to declare the commands regardless of whether or not they match the current state of the declared commands.</p> <p>The default behaviour helps avoid issues with the 2 request per minute (per-guild or globally) ratelimit and the other limit of only 200 application command creates per day (per guild or globally).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>collections.abc.Sequence[hikari.commands.PartialCommand]</code> <p>API representations of the set commands.</p>"},{"location":"reference/abc/#tanjun.abc.Client.dispatch_client_callback","title":"dispatch_client_callback  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>dispatch_client_callback(name, /, *args)\n</code></pre> <p>Dispatch a client callback.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the callback to dispatch.</p> <p> TYPE: <code>typing.Union[str, ClientCallbackNames]</code> </p> <code>*args</code> <p>Positional arguments to pass to the callback(s).</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>()</code> </p> RAISES DESCRIPTION <code>KeyError</code> <p>If no callbacks are registered for the given name.</p>"},{"location":"reference/abc/#tanjun.abc.Client.get_callback_override","title":"get_callback_override  <code>abstractmethod</code>","text":"<pre><code>get_callback_override(callback)\n</code></pre> <p>Get the override for a specific injected callback.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The injected callback to get the override for.</p> <p> TYPE: <code>alluka.CallbackSig[_T]</code> </p> RETURNS DESCRIPTION <code>alluka.abc.CallbackSig | None</code> <p>The override if found, else None.</p>"},{"location":"reference/abc/#tanjun.abc.Client.get_client_callbacks","title":"get_client_callbacks  <code>abstractmethod</code>","text":"<pre><code>get_client_callbacks(name)\n</code></pre> <p>Get a collection of the callbacks registered for a specific name.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name to get the callbacks registered for.</p> <p>This is case-insensitive.</p> <p> TYPE: <code>typing.Union[str, ClientCallbackNames]</code> </p> RETURNS DESCRIPTION <code>collections.abc.Collection[MetaEventSig]</code> <p>Collection of the callbacks for the provided name.</p>"},{"location":"reference/abc/#tanjun.abc.Client.get_component_by_name","title":"get_component_by_name  <code>abstractmethod</code>","text":"<pre><code>get_component_by_name(name)\n</code></pre> <p>Get a component from this client by name.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name to get a component by.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Component | None</code> <p>The component instance if found, else None.</p>"},{"location":"reference/abc/#tanjun.abc.Client.get_type_dependency","title":"get_type_dependency  <code>abstractmethod</code>","text":"<pre><code>get_type_dependency(type_)\n</code></pre> <p>Get the implementation for an injected type.</p> PARAMETER DESCRIPTION <code>type_</code> <p>The associated type.</p> <p> TYPE: <code>type[_T]</code> </p> RETURNS DESCRIPTION <code>_T | alluka.abc.Undefined</code> <p>The resolved type if found, else alluka.abc.UNDEFINED.</p>"},{"location":"reference/abc/#tanjun.abc.Client.iter_commands","title":"iter_commands  <code>abstractmethod</code>","text":"<pre><code>iter_commands()\n</code></pre> <p>Iterate over all the commands (both message and slash) registered to this client.</p> RETURNS DESCRIPTION <code>collections.abc.Iterator[ExecutableCommand[Context]]</code> <p>Iterator of all the commands registered to this client.</p>"},{"location":"reference/abc/#tanjun.abc.Client.iter_menu_commands","title":"iter_menu_commands  <code>abstractmethod</code>","text":"<pre><code>iter_menu_commands(*, global_only=False, type=None)\n</code></pre> <p>Iterator over the menu commands registered to this client.</p> PARAMETER DESCRIPTION <code>global_only</code> <p>Whether to only iterate over global menu commands.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>type</code> <p>Menu command type to filter by.</p> <p> TYPE: <code>typing.Optional[hikari.CommandType]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>collections.abc.Iterator[MenuCommand]</code> <p>Iterator of the menu commands registered to this client.</p>"},{"location":"reference/abc/#tanjun.abc.Client.iter_message_commands","title":"iter_message_commands  <code>abstractmethod</code>","text":"<pre><code>iter_message_commands()\n</code></pre> <p>Iterate over all the message commands registered to this client.</p> RETURNS DESCRIPTION <code>collections.abc.Iterator[MessageCommand]</code> <p>Iterator of all the message commands registered to this client.</p>"},{"location":"reference/abc/#tanjun.abc.Client.iter_slash_commands","title":"iter_slash_commands  <code>abstractmethod</code>","text":"<pre><code>iter_slash_commands(*, global_only=False)\n</code></pre> <p>Iterate over all the slash commands registered to this client.</p> PARAMETER DESCRIPTION <code>global_only</code> <p>Whether to only iterate over global slash commands.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>collections.abc.Iterator[BaseSlashCommand]</code> <p>Iterator of the slash commands registered to this client.</p>"},{"location":"reference/abc/#tanjun.abc.Client.load_directory","title":"load_directory  <code>abstractmethod</code>","text":"<pre><code>load_directory(directory, /, *, namespace=None)\n</code></pre> <p>Load entities into this client from the modules in a directory.</p> <p>The same loading rules for tanjun.abc.Client.load_modules mostly apply here but modules with no loaders are quietly ignored.</p> PARAMETER DESCRIPTION <code>directory</code> <p>Name of the directory to load modules from.</p> <p> TYPE: <code>typing.Union[str, pathlib.Path]</code> </p> <code>namespace</code> <p>The python namespace this directory's modules should be imported from, if applicable.</p> <p>This work as <code>{namespace}.{file.name.removesuffix(\".py\")}</code> and will have the same behaviour as when a str is passed to tanjun.abc.Client.load_modules if passed.</p> <p>If left as None then this will have the same behaviour as when a pathlib.Path is passed to tanjun.abc.Client.load_modules.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This client instance to enable chained calls.</p> RAISES DESCRIPTION <code>tanjun.FailedModuleLoad</code> <p>If any of the modules in this directory failed to load.</p> <p>This includes if it failed to import or if one of its loaders raised. The source error can be found at tanjun.FailedModuleLoad.cause.</p> <p>Modules with no loaders are ignored.</p> <code>ModuleNotFoundError</code> <p>If any of the modules aren't found.</p>"},{"location":"reference/abc/#tanjun.abc.Client.load_directory_async","title":"load_directory_async  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>load_directory_async(directory, /, *, namespace=None)\n</code></pre> <p>Asynchronous variant of tanjun.abc.Client.load_directory.</p> <p>Unlike tanjun.abc.Client.load_directory, this method will run blocking code in a background thread.</p> <p>For more information on the behaviour of this method see the documentation for tanjun.abc.Client.load_directory.</p>"},{"location":"reference/abc/#tanjun.abc.Client.load_modules","title":"load_modules  <code>abstractmethod</code>","text":"<pre><code>load_modules(*modules)\n</code></pre> <p>Load entities into this client from modules based on present loaders.</p> <p>Note</p> <p>If an <code>__all__</code> is present in the target module then it will be used to find loaders.</p> <p>Examples:</p> <p>For this to work the target module has to have at least one loader present.</p> <pre><code>@tanjun.as_loader\ndef load_module(client: tanjun.Client) -&gt; None:\n    client.add_component(component.copy())\n</code></pre> <p>or</p> <pre><code>loader = tanjun.Component(name=\"trans component\").load_from_scope().make_loader()\n</code></pre> PARAMETER DESCRIPTION <code>*modules</code> <p>Path(s) of the modules to load from.</p> <p>When str this will be treated as a normal import path which is absolute (<code>\"foo.bar.baz\"</code>). It's worth noting that absolute module paths may be imported from the current location if the top level module is a valid module file or module directory in the current working directory.</p> <p>When pathlib.Path the module will be imported directly from the given path. In this mode any relative imports in the target module will fail to resolve.</p> <p> TYPE: <code>typing.Union[str, pathlib.Path]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This client instance to enable chained calls.</p> RAISES DESCRIPTION <code>tanjun.FailedModuleLoad</code> <p>If the new version of a module failed to load.</p> <p>This includes if it failed to import or if one of its loaders raised. The source error can be found at tanjun.FailedModuleLoad.cause.</p> <code>tanjun.ModuleStateConflict</code> <p>If the module is already loaded.</p> <code>tanjun.ModuleMissingLoaders</code> <p>If no loaders are found in the module.</p> <code>ModuleNotFoundError</code> <p>If the module is not found.</p>"},{"location":"reference/abc/#tanjun.abc.Client.load_modules_async","title":"load_modules_async  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>load_modules_async(*modules)\n</code></pre> <p>Asynchronous variant of tanjun.abc.Client.load_modules.</p> <p>Unlike tanjun.abc.Client.load_modules, this method will run blocking code in a background thread.</p> <p>For more information on the behaviour of this method see the documentation for tanjun.abc.Client.load_modules.</p>"},{"location":"reference/abc/#tanjun.abc.Client.reload_modules","title":"reload_modules  <code>abstractmethod</code>","text":"<pre><code>reload_modules(*modules)\n</code></pre> <p>Reload entities in this client based on the loaders in loaded module(s).</p> <p>Note</p> <p>If an <code>__all__</code> is present in the target module then it will be used to find loaders and unloaders.</p> <p>Examples:</p> <p>For this to work the module has to have at least one ClientLoader which handles loading and one which handles unloading present.</p> PARAMETER DESCRIPTION <code>*modules</code> <p>Paths of one or more module to unload.</p> <p>These should be the same paths which were passed to tanjun.abc.Client.load_modules.</p> <p> TYPE: <code>typing.Union[str, pathlib.Path]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This client instance to enable chained calls.</p> RAISES DESCRIPTION <code>tanjun.FailedModuleLoad</code> <p>If the new version of a module failed to load.</p> <p>This includes if it failed to import or if one of its loaders raised. The source error can be found at tanjun.FailedModuleLoad.cause.</p> <code>tanjun.FailedModuleUnload</code> <p>If the old version of a module failed to unload.</p> <p>This indicates that one of its unloaders raised. The source error can be found at tanjun.FailedModuleUnload.cause.</p> <code>tanjun.ModuleStateConflict</code> <p>If the module hasn't been loaded.</p> <code>tanjun.ModuleMissingLoaders</code> <p>If no loaders are found in the new state of the module.</p> <code>tanjun.ModuleMissingUnloaders</code> <p>If no unloaders are found in the current state of the module.</p> <code>ModuleNotFoundError</code> <p>If the module can no-longer be found at the provided path.</p>"},{"location":"reference/abc/#tanjun.abc.Client.reload_modules_async","title":"reload_modules_async  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>reload_modules_async(*modules)\n</code></pre> <p>Asynchronous variant of tanjun.abc.Client.reload_modules.</p> <p>Unlike tanjun.abc.Client.reload_modules, this method will run blocking code in a background thread.</p> <p>For more information on the behaviour of this method see the documentation for tanjun.abc.Client.reload_modules.</p>"},{"location":"reference/abc/#tanjun.abc.Client.remove_callback_override","title":"remove_callback_override  <code>abstractmethod</code>","text":"<pre><code>remove_callback_override(callback)\n</code></pre> <p>Remove a callback override.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The injected callback to remove the override for.</p> <p> TYPE: <code>alluka.CallbackSig[_T]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to allow chaining.</p> RAISES DESCRIPTION <code>KeyError</code> <p>If no override is found for the callback.</p>"},{"location":"reference/abc/#tanjun.abc.Client.remove_client_callback","title":"remove_client_callback  <code>abstractmethod</code>","text":"<pre><code>remove_client_callback(name, callback)\n</code></pre> <p>Remove a client callback.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name this callback is being registered to.</p> <p>This is case-insensitive.</p> <p> TYPE: <code>typing.Union[str, ClientCallbackNames]</code> </p> <code>callback</code> <p>The callback to remove from the client's callbacks.</p> <p> TYPE: <code>MetaEventSig</code> </p> RAISES DESCRIPTION <code>KeyError</code> <p>If the provided name isn't found.</p> <code>ValueError</code> <p>If the provided callback isn't found.</p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/abc/#tanjun.abc.Client.remove_component","title":"remove_component  <code>abstractmethod</code>","text":"<pre><code>remove_component(component)\n</code></pre> <p>Remove a component from this client.</p> <p>This will unsubscribe any client callbacks, commands and listeners registered in the provided component.</p> PARAMETER DESCRIPTION <code>component</code> <p>The component to remove from this client.</p> <p> TYPE: <code>Component</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the provided component isn't found.</p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to allow chained calls.</p>"},{"location":"reference/abc/#tanjun.abc.Client.remove_component_by_name","title":"remove_component_by_name  <code>abstractmethod</code>","text":"<pre><code>remove_component_by_name(name)\n</code></pre> <p>Remove a component from this client by name.</p> <p>This will unsubscribe any client callbacks, commands and listeners registered in the provided component.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the component to remove from this client.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>KeyError</code> <p>If the provided component name isn't found.</p>"},{"location":"reference/abc/#tanjun.abc.Client.remove_listener","title":"remove_listener  <code>abstractmethod</code>","text":"<pre><code>remove_listener(event_type, callback)\n</code></pre> <p>Remove a listener from the client.</p> PARAMETER DESCRIPTION <code>event_type</code> <p>The event type to remove a listener for.</p> <p> TYPE: <code>type[hikari.events.base_events.Event]</code> </p> <code>callback</code> <p>The callback to remove.</p> <p> TYPE: <code>ListenerCallbackSig[_EventT]</code> </p> RAISES DESCRIPTION <code>KeyError</code> <p>If the provided event type isn't found.</p> <code>ValueError</code> <p>If the provided callback isn't found.</p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/abc/#tanjun.abc.Client.remove_type_dependency","title":"remove_type_dependency  <code>abstractmethod</code>","text":"<pre><code>remove_type_dependency(type_)\n</code></pre> <p>Remove a type dependency.</p> PARAMETER DESCRIPTION <code>type_</code> <p>The associated type.</p> <p> TYPE: <code>type[typing.Any]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to allow chaining.</p> RAISES DESCRIPTION <code>KeyError</code> <p>If <code>type</code> is not registered.</p>"},{"location":"reference/abc/#tanjun.abc.Client.set_callback_override","title":"set_callback_override  <code>abstractmethod</code>","text":"<pre><code>set_callback_override(callback, override)\n</code></pre> <p>Override a specific injected callback.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The injected callback to override.</p> <p> TYPE: <code>alluka.CallbackSig[_T]</code> </p> <code>override</code> <p>The callback to use instead.</p> <p> TYPE: <code>alluka.CallbackSig[_T]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to allow chaining.</p>"},{"location":"reference/abc/#tanjun.abc.Client.set_metadata","title":"set_metadata  <code>abstractmethod</code>","text":"<pre><code>set_metadata(key, value)\n</code></pre> <p>Set a field in the client's metadata.</p> PARAMETER DESCRIPTION <code>key</code> <p>Metadata key to set.</p> <p> TYPE: <code>typing.Any</code> </p> <code>value</code> <p>Metadata value to set.</p> <p> TYPE: <code>typing.Any</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/abc/#tanjun.abc.Client.set_type_dependency","title":"set_type_dependency  <code>abstractmethod</code>","text":"<pre><code>set_type_dependency(type_, value)\n</code></pre> <p>Set a callback to be called to resolve a injected type.</p> PARAMETER DESCRIPTION <code>type_</code> <p>The type of the dependency to add an implementation for.</p> <p> TYPE: <code>type[_T]</code> </p> <code>value</code> <p>The value of the dependency.</p> <p> TYPE: <code>_T</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to allow chaining.</p>"},{"location":"reference/abc/#tanjun.abc.Client.unload_modules","title":"unload_modules  <code>abstractmethod</code>","text":"<pre><code>unload_modules(*modules)\n</code></pre> <p>Unload entities from this client based on unloaders in one or more modules.</p> <p>Note</p> <p>If an <code>__all__</code> is present in the target module then it will be used to find unloaders.</p> <p>Examples:</p> <p>For this to work the module has to have at least one unloading enabled tanjun.abc.ClientLoader present.</p> <pre><code>@tanjun.as_unloader\ndef unload_component(client: tanjun.Client) -&gt; None:\n    client.remove_component_by_name(component.name)\n</code></pre> <p>or</p> <pre><code># make_loader's returned ClientLoader handles both loading and unloading.\nloader = tanjun.Component(name=\"trans component\").load_from_scope().make_loader()\n</code></pre> PARAMETER DESCRIPTION <code>*modules</code> <p>Path of one or more modules to unload.</p> <p>These should be the same path(s) which were passed to tanjun.abc.Client.load_modules.</p> <p> TYPE: <code>typing.Union[str, pathlib.Path]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This client instance to enable chained calls.</p> RAISES DESCRIPTION <code>tanjun.ModuleStateConflict</code> <p>If the module hasn't been loaded.</p> <code>tanjun.ModuleMissingUnloaders</code> <p>If no unloaders are found in the module.</p> <code>tanjun.FailedModuleUnload</code> <p>If the old version of a module failed to unload.</p> <p>This indicates that one of its unloaders raised. The source error can be found at tanjun.FailedModuleUnload.cause.</p>"},{"location":"reference/abc/#tanjun.abc.Client.with_client_callback","title":"with_client_callback  <code>abstractmethod</code>","text":"<pre><code>with_client_callback(name)\n</code></pre> <p>Add a client callback through a decorator call.</p> <p>Examples:</p> <pre><code>client = tanjun.Client.from_rest_bot(bot)\n\n@client.with_client_callback(\"closed\")\nasync def on_close() -&gt; None:\n    raise NotImplementedError\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>The name this callback is being registered to.</p> <p>This is case-insensitive.</p> <p> TYPE: <code>typing.Union[str, ClientCallbackNames]</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[MetaEventSig], MetaEventSig]</code> <p>Decorator callback used to register the client callback.</p> <p>This may be sync or async and must return None. The positional and keyword arguments a callback should expect depend on implementation detail around the <code>name</code> being subscribed to.</p>"},{"location":"reference/abc/#tanjun.abc.Client.with_listener","title":"with_listener  <code>abstractmethod</code>","text":"<pre><code>with_listener(*event_types)\n</code></pre> <p>Add an event listener to this client through a decorator call.</p> <p>Examples:</p> <pre><code>client = tanjun.Client.from_gateway_bot(bot)\n\n@client.with_listener(hikari.MessageCreateEvent)\nasync def on_message_create(event: hikari.MessageCreateEvent) -&gt; None:\n    raise NotImplementedError\n</code></pre> PARAMETER DESCRIPTION <code>*event_types</code> <p>One or more event types to listen for.</p> <p>If none are provided then the event type(s) will be inferred from the callback's type-hints.</p> <p> TYPE: <code>type[hikari.Event]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[ListenerCallbackSig], ListenerCallbackSig]</code> <p>Decorator callback used to register the event callback.</p> <p>The callback must be a coroutine function which returns None and always takes at least one positional arg of type hikari.events.base_events.Event regardless of client implementation detail.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If nothing was passed for <code>event_types</code> and no subclasses of hikari.events.base_events.Event are found in the type-hint for the callback's first argument.</p>"},{"location":"reference/abc/#tanjun.abc.ClientCallbackNames","title":"ClientCallbackNames","text":"<p>         Bases: <code>str</code>, <code>enum.Enum</code></p> <p>Enum of the standard client callback names.</p> <p>These should be dispatched by all tanjun.abc.Client implementations.</p>"},{"location":"reference/abc/#tanjun.abc.ClientCallbackNames.CLOSED","title":"CLOSED  <code>class-attribute</code>","text":"<pre><code>CLOSED = 'closed'\n</code></pre> <p>Called when the client has finished closing.</p> <p>No positional arguments are provided for this event.</p>"},{"location":"reference/abc/#tanjun.abc.ClientCallbackNames.CLOSING","title":"CLOSING  <code>class-attribute</code>","text":"<pre><code>CLOSING = 'closing'\n</code></pre> <p>Called when the client is initially instructed to close.</p> <p>No positional arguments are provided for this event.</p>"},{"location":"reference/abc/#tanjun.abc.ClientCallbackNames.COMPONENT_ADDED","title":"COMPONENT_ADDED  <code>class-attribute</code>","text":"<pre><code>COMPONENT_ADDED = 'component_added'\n</code></pre> <p>Called when a component is added to an active client.</p> <p>Warning</p> <p>This event isn't dispatched for components which were registered while the client is inactive.</p> <p>The first positional argument is the tanjun.abc.Component being added.</p>"},{"location":"reference/abc/#tanjun.abc.ClientCallbackNames.COMPONENT_REMOVED","title":"COMPONENT_REMOVED  <code>class-attribute</code>","text":"<pre><code>COMPONENT_REMOVED = 'component_removed'\n</code></pre> <p>Called when a component is added to an active client.</p> <p>Warning</p> <p>This event isn't dispatched for components which were removed while the client is inactive.</p> <p>The first positional argument is the tanjun.abc.Component being removed.</p>"},{"location":"reference/abc/#tanjun.abc.ClientCallbackNames.MENU_COMMAND_NOT_FOUND","title":"MENU_COMMAND_NOT_FOUND  <code>class-attribute</code>","text":"<pre><code>MENU_COMMAND_NOT_FOUND = 'menu_command_not_found'\n</code></pre> <p>Called when a menu command is not found.</p> <p>tanjun.abc.MenuContext is provided as the first positional argument.</p>"},{"location":"reference/abc/#tanjun.abc.ClientCallbackNames.MESSAGE_COMMAND_NOT_FOUND","title":"MESSAGE_COMMAND_NOT_FOUND  <code>class-attribute</code>","text":"<pre><code>MESSAGE_COMMAND_NOT_FOUND = 'message_command_not_found'\n</code></pre> <p>Called when a message command is not found.</p> <p>tanjun.abc.MessageContext is provided as the first positional argument.</p>"},{"location":"reference/abc/#tanjun.abc.ClientCallbackNames.SLASH_COMMAND_NOT_FOUND","title":"SLASH_COMMAND_NOT_FOUND  <code>class-attribute</code>","text":"<pre><code>SLASH_COMMAND_NOT_FOUND = 'slash_command_not_found'\n</code></pre> <p>Called when a slash command is not found.</p> <p>tanjun.abc.SlashContext is provided as the first positional argument.</p>"},{"location":"reference/abc/#tanjun.abc.ClientCallbackNames.STARTED","title":"STARTED  <code>class-attribute</code>","text":"<pre><code>STARTED = 'started'\n</code></pre> <p>Called when the client has finished starting.</p> <p>No positional arguments are provided for this event.</p>"},{"location":"reference/abc/#tanjun.abc.ClientCallbackNames.STARTING","title":"STARTING  <code>class-attribute</code>","text":"<pre><code>STARTING = 'starting'\n</code></pre> <p>Called when the client is initially instructed to start.</p> <p>No positional arguments are provided for this event.</p>"},{"location":"reference/abc/#tanjun.abc.ClientLoader","title":"ClientLoader","text":"<p>         Bases: <code>abc.ABC</code></p> <p>Interface of logic used to load and unload components into a generic client.</p>"},{"location":"reference/abc/#tanjun.abc.ClientLoader.has_load","title":"has_load  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>has_load: bool\n</code></pre> <p>Whether this loader will load anything.</p>"},{"location":"reference/abc/#tanjun.abc.ClientLoader.has_unload","title":"has_unload  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>has_unload: bool\n</code></pre> <p>Whether this loader will unload anything.</p>"},{"location":"reference/abc/#tanjun.abc.ClientLoader.load","title":"load  <code>abstractmethod</code>","text":"<pre><code>load(client)\n</code></pre> <p>Load logic into a client instance.</p> PARAMETER DESCRIPTION <code>client</code> <p>The client to load commands and listeners for.</p> <p> TYPE: <code>Client</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether anything was loaded.</p>"},{"location":"reference/abc/#tanjun.abc.ClientLoader.unload","title":"unload  <code>abstractmethod</code>","text":"<pre><code>unload(client)\n</code></pre> <p>Unload logic from a client instance.</p> PARAMETER DESCRIPTION <code>client</code> <p>The client to unload commands and listeners from.</p> <p> TYPE: <code>Client</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether anything was unloaded.</p>"},{"location":"reference/abc/#tanjun.abc.Component","title":"Component","text":"<p>         Bases: <code>abc.ABC</code></p> <p>Standard interface of a Tanjun component.</p> <p>This is a collection of message and application commands, and listeners with logic for command search + execution and loading the listeners into a tanjun client.</p>"},{"location":"reference/abc/#tanjun.abc.Component.client","title":"client  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>client: typing.Optional[Client]\n</code></pre> <p>Tanjun client this component is bound to.</p>"},{"location":"reference/abc/#tanjun.abc.Component.default_app_cmd_permissions","title":"default_app_cmd_permissions  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>default_app_cmd_permissions: typing.Optional[hikari.Permissions]\n</code></pre> <p>Default required guild member permissions for the commands in this component.</p> <p>This may be overridden by tanjun.abc.AppCommand.default_member_permissions and if this is None then the default from the parent client is used.</p> <p>Warning</p> <p>This may be overridden by guild staff and does not apply to admins.</p>"},{"location":"reference/abc/#tanjun.abc.Component.defaults_to_ephemeral","title":"defaults_to_ephemeral  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>defaults_to_ephemeral: typing.Optional[bool]\n</code></pre> <p>Whether slash contexts executed in this component should default to ephemeral responses.</p> <p>This effects calls to tanjun.abc.SlashContext.create_followup, tanjun.abc.SlashContext.create_initial_response, tanjun.abc.SlashContext.defer and tanjun.abc.SlashContext.respond unless the <code>flags</code> field is provided for the methods which support it.</p> <p>Note</p> <p>This may be overridden by tanjun.abc.AppCommand.defaults_to_ephemeral and only effects slash command execution; if this is None then the default from the parent client is used.</p>"},{"location":"reference/abc/#tanjun.abc.Component.dms_enabled_for_app_cmds","title":"dms_enabled_for_app_cmds  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>dms_enabled_for_app_cmds: typing.Optional[bool]\n</code></pre> <p>Whether application commands in this component should be enabled in DMs.</p> <p>Note</p> <p>This may be overridden by tanjun.abc.AppCommand.is_dm_enabled and if both that and this are None then the default from the parent client is used.</p>"},{"location":"reference/abc/#tanjun.abc.Component.is_case_sensitive","title":"is_case_sensitive  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>is_case_sensitive: typing.Optional[bool]\n</code></pre> <p>Whether this component should treat message command names case sensitive in search.</p> <p>If this is <code>None</code> then the client's case sensitivity will be used.</p>"},{"location":"reference/abc/#tanjun.abc.Component.listeners","title":"listeners  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>listeners: collections.Mapping[type[hikari.Event], collections.Collection[ListenerCallbackSig[typing.Any]]]\n</code></pre> <p>Mapping of event types to the listeners registered for them in this component.</p>"},{"location":"reference/abc/#tanjun.abc.Component.loop","title":"loop  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>loop: typing.Optional[asyncio.AbstractEventLoop]\n</code></pre> <p>The asyncio loop this client is bound to if it has been opened.</p>"},{"location":"reference/abc/#tanjun.abc.Component.menu_commands","title":"menu_commands  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>menu_commands: collections.Collection[MenuCommand[typing.Any, typing.Any]]\n</code></pre> <p>Collection of the menu commands in this component.</p>"},{"location":"reference/abc/#tanjun.abc.Component.message_commands","title":"message_commands  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>message_commands: collections.Collection[MessageCommand[typing.Any]]\n</code></pre> <p>Collection of the message commands in this component.</p>"},{"location":"reference/abc/#tanjun.abc.Component.metadata","title":"metadata  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>metadata: collections.MutableMapping[typing.Any, typing.Any]\n</code></pre> <p>Mutable mapping of the metadata set for this component.</p> <p>Note</p> <p>Any modifications made to this mutable mapping will be preserved by the component.</p>"},{"location":"reference/abc/#tanjun.abc.Component.name","title":"name  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>name: str\n</code></pre> <p>Component's unique identifier.</p> <p>Note</p> <p>This will be preserved between copies of a component.</p>"},{"location":"reference/abc/#tanjun.abc.Component.slash_commands","title":"slash_commands  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>slash_commands: collections.Collection[BaseSlashCommand]\n</code></pre> <p>Collection of the slash commands in this component.</p>"},{"location":"reference/abc/#tanjun.abc.Component.add_listener","title":"add_listener  <code>abstractmethod</code>","text":"<pre><code>add_listener(event, /, *callbacks)\n</code></pre> <p>Add a listener to this component.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to listen for.</p> <p> TYPE: <code>type[hikari.events.base_events.Event]</code> </p> <code>*callbacks</code> <p>The callbacks to add.</p> <p> TYPE: <code>ListenerCallbackSig[_EventT]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The component to enable chained calls.</p>"},{"location":"reference/abc/#tanjun.abc.Component.add_menu_command","title":"add_menu_command  <code>abstractmethod</code>","text":"<pre><code>add_menu_command(command)\n</code></pre> <p>Add a menu command to this component.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add.</p> <p> TYPE: <code>MenuCommand[typing.Any, typing.Any]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The component to enable chained calls.</p>"},{"location":"reference/abc/#tanjun.abc.Component.add_message_command","title":"add_message_command  <code>abstractmethod</code>","text":"<pre><code>add_message_command(command)\n</code></pre> <p>Add a message command to this component.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add.</p> <p> TYPE: <code>MessageCommand[typing.Any]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The component to enable chained calls.</p>"},{"location":"reference/abc/#tanjun.abc.Component.add_slash_command","title":"add_slash_command  <code>abstractmethod</code>","text":"<pre><code>add_slash_command(command)\n</code></pre> <p>Add a slash command to this component.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add.</p> <p> TYPE: <code>BaseSlashCommand</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The component to enable chained calls.</p>"},{"location":"reference/abc/#tanjun.abc.Component.check_message_name","title":"check_message_name  <code>abstractmethod</code>","text":"<pre><code>check_message_name(name, /, *, case_sensitive=True)\n</code></pre> <p>Check whether a name matches any of this component's registered message commands.</p> <p>Note</p> <p>This only checks for name matches against the top level command and will not account for sub-commands.</p> <p>Note</p> <p>Dependent on implementation detail this may partial check name against command names using name.startswith(command_name), hence why it also returns the name a command was matched by.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name to check for command matches.</p> <p> TYPE: <code>str</code> </p> <code>case_sensitive</code> <p>Whether to perform a case-sensitive match.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Iterator[tuple[str, MessageCommand[typing.Any]]]</code> <p>Iterator of tuples of command name matches to the relevant message command objects.</p>"},{"location":"reference/abc/#tanjun.abc.Component.check_slash_name","title":"check_slash_name  <code>abstractmethod</code>","text":"<pre><code>check_slash_name(name)\n</code></pre> <p>Check whether a name matches any of this component's registered slash commands.</p> <p>Note</p> <p>This won't check for sub-commands and will expect <code>name</code> to simply be the top level command name.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name to check for command matches.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>collections.abc.Iterator[BaseSlashCommand]</code> <p>An iterator of the matching slash commands.</p>"},{"location":"reference/abc/#tanjun.abc.Component.close","title":"close  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>close(*, unbind=False)\n</code></pre> <p>Close the component.</p> PARAMETER DESCRIPTION <code>unbind</code> <p>Whether to unbind from the client after this is closed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the component isn't running.</p>"},{"location":"reference/abc/#tanjun.abc.Component.execute_autocomplete","title":"execute_autocomplete  <code>abstractmethod</code>","text":"<pre><code>execute_autocomplete(ctx)\n</code></pre> <p>Execute an autocomplete context.</p> <p>Note</p> <p>Unlike the other execute methods, this shouldn't be expected to raise tanjun.HaltExecution nor tanjun.CommandError.</p> PARAMETER DESCRIPTION <code>ctx</code> <p>The context to execute.</p> <p> TYPE: <code>AutocompleteContext</code> </p> RETURNS DESCRIPTION <code>collections.abc.Coroutine[typing.Any, typing.Any, None] | None</code> <p>Coroutine used to wait for the command execution to finish.</p> <p>This may be awaited or left to run as a background task.</p> <p>If this is None then the client should carry on its search for a component with a matching autocomplete.</p>"},{"location":"reference/abc/#tanjun.abc.Component.execute_menu","title":"execute_menu  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>execute_menu(ctx, /, *, hooks=None)\n</code></pre> <p>Execute a menu context.</p> PARAMETER DESCRIPTION <code>ctx</code> <p>The context to execute.</p> <p> TYPE: <code>MenuContext</code> </p> <code>hooks</code> <p>Set of hooks to include in this command execution.</p> <p> TYPE: <code>typing.Optional[collections.MutableSet[MenuHooks]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>collections.abc.Coroutine[typing.Any, typing.Any, None] | None</code> <p>Coroutine used to wait for the command execution to finish.</p> <p>This may be awaited or left to run as a background task.</p> <p>If this is None then the client should carry on its search for a component with a matching command.</p> RAISES DESCRIPTION <code>tanjun.CommandError</code> <p>To end the command's execution with an error response message.</p> <code>tanjun.HaltExecution</code> <p>To indicate that the client should stop searching for commands to execute with the current context.</p>"},{"location":"reference/abc/#tanjun.abc.Component.execute_message","title":"execute_message  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>execute_message(ctx, /, *, hooks=None)\n</code></pre> <p>Execute a message context.</p> PARAMETER DESCRIPTION <code>ctx</code> <p>The context to execute.</p> <p> TYPE: <code>MessageContext</code> </p> <code>hooks</code> <p>Set of hooks to include in this command execution.</p> <p> TYPE: <code>typing.Optional[collections.MutableSet[MessageHooks]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether a message command was executed in this component with the provided context.</p> <p>If False then the client should carry on its search for a component with a matching command.</p> RAISES DESCRIPTION <code>tanjun.CommandError</code> <p>To end the command's execution with an error response message.</p> <code>tanjun.HaltExecution</code> <p>To indicate that the client should stop searching for commands to execute with the current context.</p>"},{"location":"reference/abc/#tanjun.abc.Component.execute_slash","title":"execute_slash  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>execute_slash(ctx, /, *, hooks=None)\n</code></pre> <p>Execute a slash context.</p> PARAMETER DESCRIPTION <code>ctx</code> <p>The context to execute.</p> <p> TYPE: <code>SlashContext</code> </p> <code>hooks</code> <p>Set of hooks to include in this command execution.</p> <p> TYPE: <code>typing.Optional[collections.MutableSet[SlashHooks]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>collections.abc.Coroutine[typing.Any, typing.Any, None] | None</code> <p>Coroutine used to wait for the command execution to finish.</p> <p>This may be awaited or left to run as a background task.</p> <p>If this is None then the client should carry on its search for a component with a matching command.</p> RAISES DESCRIPTION <code>tanjun.CommandError</code> <p>To end the command's execution with an error response message.</p> <code>tanjun.HaltExecution</code> <p>To indicate that the client should stop searching for commands to execute with the current context.</p>"},{"location":"reference/abc/#tanjun.abc.Component.open","title":"open  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>open()\n</code></pre> <p>Start the component.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the component is already open. If the component isn't bound to a client.</p>"},{"location":"reference/abc/#tanjun.abc.Component.remove_listener","title":"remove_listener  <code>abstractmethod</code>","text":"<pre><code>remove_listener(event, listener)\n</code></pre> <p>Remove a listener from this component.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to listen for.</p> <p> TYPE: <code>type[hikari.events.base_events.Event]</code> </p> <code>listener</code> <p>The listener to remove.</p> <p> TYPE: <code>ListenerCallbackSig[_EventT]</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the listener is not registered for the provided event.</p> RETURNS DESCRIPTION <code>Self</code> <p>The component to enable chained calls.</p>"},{"location":"reference/abc/#tanjun.abc.Component.remove_menu_command","title":"remove_menu_command  <code>abstractmethod</code>","text":"<pre><code>remove_menu_command(command)\n</code></pre> <p>Remove a menu command from this component.</p> PARAMETER DESCRIPTION <code>command</code> <p>Object of the menu command to remove.</p> <p> TYPE: <code>MenuCommand[typing.Any, typing.Any]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The component to enable chained calls.</p>"},{"location":"reference/abc/#tanjun.abc.Component.remove_message_command","title":"remove_message_command  <code>abstractmethod</code>","text":"<pre><code>remove_message_command(command)\n</code></pre> <p>Remove a message command from this component.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to remove.</p> <p> TYPE: <code>MessageCommand[typing.Any]</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the provided command isn't found.</p> RETURNS DESCRIPTION <code>Self</code> <p>The component to enable chained calls.</p>"},{"location":"reference/abc/#tanjun.abc.Component.remove_slash_command","title":"remove_slash_command  <code>abstractmethod</code>","text":"<pre><code>remove_slash_command(command)\n</code></pre> <p>Remove a slash command from this component.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to remove.</p> <p> TYPE: <code>BaseSlashCommand</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the provided command isn't found.</p> RETURNS DESCRIPTION <code>Self</code> <p>The component to enable chained calls.</p>"},{"location":"reference/abc/#tanjun.abc.Component.set_metadata","title":"set_metadata  <code>abstractmethod</code>","text":"<pre><code>set_metadata(key, value)\n</code></pre> <p>Set a field in the component's metadata.</p> PARAMETER DESCRIPTION <code>key</code> <p>Metadata key to set.</p> <p> TYPE: <code>typing.Any</code> </p> <code>value</code> <p>Metadata value to set.</p> <p> TYPE: <code>typing.Any</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The component instance to enable chained calls.</p>"},{"location":"reference/abc/#tanjun.abc.Component.with_listener","title":"with_listener  <code>abstractmethod</code>","text":"<pre><code>with_listener(*event_types)\n</code></pre> <p>Add a listener to this component through a decorator call.</p> PARAMETER DESCRIPTION <code>*event_types</code> <p>One or more event types to listen for.</p> <p>If none are provided then the event type(s) will be inferred from the callback's type-hints.</p> <p> TYPE: <code>type[hikari.Event]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[ListenerCallbackSig], ListenerCallbackSig]</code> <p>Decorator callback which takes listener to add.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If nothing was passed for <code>event_types</code> and no subclasses of hikari.events.base_events.Event are found in the type-hint for the callback's first argument.</p>"},{"location":"reference/abc/#tanjun.abc.Component.with_menu_command","title":"with_menu_command  <code>abstractmethod</code>","text":"<pre><code>with_menu_command(command=None, /, *, copy=False)\n</code></pre> <p>Add a menu command to this component through a decorator call.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add.</p> <p> TYPE: <code>MenuCommand</code> DEFAULT: <code>None</code> </p> <code>copy</code> <p>Whether to copy the command before adding it.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>MenuCommand</code> <p>The added command.</p>"},{"location":"reference/abc/#tanjun.abc.Component.with_message_command","title":"with_message_command  <code>abstractmethod</code>","text":"<pre><code>with_message_command(command=None, /, *, copy=False)\n</code></pre> <p>Add a message command to this component through a decorator call.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add.</p> <p> TYPE: <code>MessageCommand</code> DEFAULT: <code>None</code> </p> <code>copy</code> <p>Whether to copy the command before adding it.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>MessageCommand</code> <p>The added command.</p>"},{"location":"reference/abc/#tanjun.abc.Component.with_slash_command","title":"with_slash_command  <code>abstractmethod</code>","text":"<pre><code>with_slash_command(command=None, /, *, copy=False)\n</code></pre> <p>Add a slash command to this component through a decorator call.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add.</p> <p> TYPE: <code>BaseSlashCommand</code> DEFAULT: <code>None</code> </p> <code>copy</code> <p>Whether to copy the command before adding it.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>BaseSlashCommand</code> <p>The added command.</p>"},{"location":"reference/abc/#tanjun.abc.Context","title":"Context","text":"<p>         Bases: <code>alluka.Context</code></p> <p>Interface for the context of a command execution.</p>"},{"location":"reference/abc/#tanjun.abc.Context.author","title":"author  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>author: hikari.User\n</code></pre> <p>Object of the user who triggered this command.</p>"},{"location":"reference/abc/#tanjun.abc.Context.cache","title":"cache  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>cache: typing.Optional[hikari.api.Cache]\n</code></pre> <p>Hikari cache instance this context's command client was initialised with.</p>"},{"location":"reference/abc/#tanjun.abc.Context.channel_id","title":"channel_id  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>channel_id: hikari.Snowflake\n</code></pre> <p>ID of the channel this command was triggered in.</p>"},{"location":"reference/abc/#tanjun.abc.Context.client","title":"client  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>client: Client\n</code></pre> <p>Tanjun tanjun.abc.Client implementation this context was spawned by.</p>"},{"location":"reference/abc/#tanjun.abc.Context.command","title":"command  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>command: typing.Optional[ExecutableCommand[Self]]\n</code></pre> <p>Object of the command this context is bound to.</p> <p>Note</p> <p>This will only be None before this has been bound to a specific command but never during command execution.</p>"},{"location":"reference/abc/#tanjun.abc.Context.component","title":"component  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>component: typing.Optional[Component]\n</code></pre> <p>Object of the tanjun.abc.Component this context is bound to.</p> <p>Note</p> <p>This will only be None before this has been bound to a specific command but never during command execution nor checks.</p>"},{"location":"reference/abc/#tanjun.abc.Context.created_at","title":"created_at  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>created_at: datetime.datetime\n</code></pre> <p>When this context was created.</p>"},{"location":"reference/abc/#tanjun.abc.Context.events","title":"events  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>events: typing.Optional[hikari.api.EventManager]\n</code></pre> <p>Object of the event manager this context's client was initialised with.</p>"},{"location":"reference/abc/#tanjun.abc.Context.guild_id","title":"guild_id  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>guild_id: typing.Optional[hikari.Snowflake]\n</code></pre> <p>ID of the guild this command was executed in.</p> <p>Will be None for all DM command executions.</p>"},{"location":"reference/abc/#tanjun.abc.Context.has_responded","title":"has_responded  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>has_responded: bool\n</code></pre> <p>Whether an initial response has been made for this context.</p>"},{"location":"reference/abc/#tanjun.abc.Context.is_human","title":"is_human  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>is_human: bool\n</code></pre> <p>Whether this command execution was triggered by a human.</p> <p>Will be False for bot and webhook triggered commands.</p>"},{"location":"reference/abc/#tanjun.abc.Context.member","title":"member  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>member: typing.Optional[hikari.Member]\n</code></pre> <p>Guild member object of this command's author.</p> <p>Will be None for DM command executions.</p>"},{"location":"reference/abc/#tanjun.abc.Context.rest","title":"rest  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>rest: hikari.api.RESTClient\n</code></pre> <p>Object of the Hikari REST client this context's client was initialised with.</p>"},{"location":"reference/abc/#tanjun.abc.Context.server","title":"server  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>server: typing.Optional[hikari.api.InteractionServer]\n</code></pre> <p>Object of the Hikari interaction server provided for this context's client.</p>"},{"location":"reference/abc/#tanjun.abc.Context.shard","title":"shard  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>shard: typing.Optional[hikari.api.GatewayShard]\n</code></pre> <p>Shard that triggered the context.</p> <p>Note</p> <p>This will be None if tanjun.abc.Context.shards is also None.</p>"},{"location":"reference/abc/#tanjun.abc.Context.shards","title":"shards  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>shards: typing.Optional[hikari.ShardAware]\n</code></pre> <p>Object of the Hikari shard manager this context's client was initialised with.</p>"},{"location":"reference/abc/#tanjun.abc.Context.triggering_name","title":"triggering_name  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>triggering_name: str\n</code></pre> <p>Command name this execution was triggered with.</p>"},{"location":"reference/abc/#tanjun.abc.Context.voice","title":"voice  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>voice: typing.Optional[hikari.api.VoiceComponent]\n</code></pre> <p>Object of the Hikari voice component this context's client was initialised with.</p>"},{"location":"reference/abc/#tanjun.abc.Context.delete_initial_response","title":"delete_initial_response  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>delete_initial_response()\n</code></pre> <p>Delete the initial response after invoking this context.</p> RAISES DESCRIPTION <code>LookupError, hikari.NotFoundError</code> <p>The last context has no initial response.</p>"},{"location":"reference/abc/#tanjun.abc.Context.delete_last_response","title":"delete_last_response  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>delete_last_response()\n</code></pre> <p>Delete the last response after invoking this context.</p> RAISES DESCRIPTION <code>LookupError, hikari.NotFoundError</code> <p>The last context has no responses.</p>"},{"location":"reference/abc/#tanjun.abc.Context.edit_initial_response","title":"edit_initial_response  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>edit_initial_response(content=hikari.UNDEFINED, *, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Edit the initial response for this context.</p> PARAMETER DESCRIPTION <code>content</code> <p>The content to edit the initial response with.</p> <p>If provided, the message contents. If hikari.undefined.UNDEFINED, then nothing will be sent in the content. Any other value here will be cast to a str.</p> <p>If this is a hikari.embeds.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.files.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> <p> TYPE: <code>hikari.UndefinedOr[typing.Any]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>delete_after</code> <p>If provided, the seconds after which the response message should be deleted.</p> <p>Slash command responses can only be deleted within 15 minutes of the command being received.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, float, int, None]</code> DEFAULT: <code>None</code> </p> <code>attachment</code> <p>A singular attachment to edit the initial response with.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[hikari.Resourceish]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachments</code> <p>A sequence of attachments to edit the initial response with.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[collections.Sequence[hikari.Resourceish]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>component</code> <p>If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[hikari.api.ComponentBuilder]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>components</code> <p>If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[collections.Sequence[hikari.api.ComponentBuilder]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embed</code> <p>An embed to replace the initial response with.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[hikari.Embed]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embeds</code> <p>A sequence of embeds to replace the initial response with.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[collections.Sequence[hikari.Embed]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>mentions_everyone</code> <p>If provided, whether the message should parse @everyone/@here mentions.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>user_mentions</code> <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.users.PartialUser derivatives to enforce mentioning specific users.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialUser], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>role_mentions</code> <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialRole], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> RETURNS DESCRIPTION <code>hikari.Message</code> <p>The message that has been edited.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If <code>delete_after</code> would be more than 15 minutes after the slash command was called.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> <code>hikari.BadRequestError</code> <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> <code>hikari.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.ForbiddenError</code> <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> <code>hikari.NotFoundError</code> <p>If the channel is not found.</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/abc/#tanjun.abc.Context.edit_last_response","title":"edit_last_response  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>edit_last_response(content=hikari.UNDEFINED, *, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Edit the last response for this context.</p> PARAMETER DESCRIPTION <code>content</code> <p>The content to edit the last response with.</p> <p>If provided, the message contents. If hikari.undefined.UNDEFINED, then nothing will be sent in the content. Any other value here will be cast to a str.</p> <p>If this is a hikari.embeds.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.files.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> <p> TYPE: <code>hikari.UndefinedOr[typing.Any]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>delete_after</code> <p>If provided, the seconds after which the response message should be deleted.</p> <p>Slash command responses can only be deleted within 15 minutes of the command being received.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, float, int, None]</code> DEFAULT: <code>None</code> </p> <code>attachment</code> <p>A singular attachment to edit the last response with.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[hikari.Resourceish]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachments</code> <p>A sequence of attachments to edit the last response with.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[collections.Sequence[hikari.Resourceish]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>component</code> <p>If provided, builder object of the component to set for this message. This component will replace any previously set components and passing None will remove all components.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[hikari.api.ComponentBuilder]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>components</code> <p>If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing None or an empty sequence will remove all components.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[collections.Sequence[hikari.api.ComponentBuilder]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embed</code> <p>An embed to replace the last response with.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[hikari.Embed]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embeds</code> <p>A sequence of embeds to replace the last response with.</p> <p> TYPE: <code>hikari.UndefinedNoneOr[collections.Sequence[hikari.Embed]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>mentions_everyone</code> <p>If provided, whether the message should parse @everyone/@here mentions.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>user_mentions</code> <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.users.PartialUser derivatives to enforce mentioning specific users.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialUser], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>role_mentions</code> <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialRole], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> RETURNS DESCRIPTION <code>hikari.Message</code> <p>The message that has been edited.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If <code>delete_after</code> would be more than 15 minutes after the slash command was called.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> <code>hikari.BadRequestError</code> <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> <code>hikari.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.ForbiddenError</code> <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> <code>hikari.NotFoundError</code> <p>If the channel is not found.</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/abc/#tanjun.abc.Context.fetch_channel","title":"fetch_channel  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>fetch_channel()\n</code></pre> <p>Fetch the channel the context was invoked in.</p> <p>Note</p> <p>This performs an API call. Consider using tanjun.abc.Context.get_channel if you have hikari.api.config.CacheComponents.GUILD_CHANNELS cache component enabled.</p> RETURNS DESCRIPTION <code>hikari.TextableChannel</code> <p>The textable DM or guild channel the context was invoked in.</p> RAISES DESCRIPTION <code>hikari.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.ForbiddenError</code> <p>If you are missing the <code>READ_MESSAGES</code> permission in the channel.</p> <code>hikari.NotFoundError</code> <p>If the channel is not found.</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/abc/#tanjun.abc.Context.fetch_guild","title":"fetch_guild  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>fetch_guild()\n</code></pre> <p>Fetch the guild the context was invoked in.</p> <p>Note</p> <p>This performs an API call. Consider using tanjun.abc.Context.get_guild if you have hikari.api.config.CacheComponents.GUILDS cache component enabled.</p> RETURNS DESCRIPTION <code>hikari.Guild | None</code> <p>An optional guild the context was invoked in. None will be returned if the context was invoked in a DM channel.</p> RAISES DESCRIPTION <code>hikari.ForbiddenError</code> <p>If you are not part of the guild.</p> <code>hikari.NotFoundError</code> <p>If the guild is not found.</p> <code>hikari.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/abc/#tanjun.abc.Context.fetch_initial_response","title":"fetch_initial_response  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>fetch_initial_response()\n</code></pre> <p>Fetch the initial response for this context.</p> RAISES DESCRIPTION <code>LookupError, hikari.NotFoundError</code> <p>The response was not found.</p>"},{"location":"reference/abc/#tanjun.abc.Context.fetch_last_response","title":"fetch_last_response  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>fetch_last_response()\n</code></pre> <p>Fetch the last response for this context.</p> RAISES DESCRIPTION <code>LookupError, hikari.NotFoundError</code> <p>The response was not found.</p>"},{"location":"reference/abc/#tanjun.abc.Context.get_channel","title":"get_channel  <code>abstractmethod</code>","text":"<pre><code>get_channel()\n</code></pre> <p>Retrieve the channel the context was invoked in from the cache.</p> <p>Note</p> <p>This method requires the hikari.api.config.CacheComponents.GUILD_CHANNELS cache component.</p> RETURNS DESCRIPTION <code>hikari.TextableGuildChannel | None</code> <p>An optional guild channel the context was invoked in. None will be returned if the channel was not found or if it is DM channel.</p>"},{"location":"reference/abc/#tanjun.abc.Context.get_guild","title":"get_guild  <code>abstractmethod</code>","text":"<pre><code>get_guild()\n</code></pre> <p>Fetch the guild that the context was invoked in.</p> <p>Note</p> <p>This method requires hikari.api.config.CacheComponents.GUILDS cache component enabled.</p> RETURNS DESCRIPTION <code>hikari.Guild | None</code> <p>An optional guild the context was invoked in. None will be returned if the guild was not found.</p>"},{"location":"reference/abc/#tanjun.abc.Context.respond","title":"respond  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>respond(content=hikari.UNDEFINED, *, ensure_result=False, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Respond to this context.</p> PARAMETER DESCRIPTION <code>content</code> <p>The content to respond with.</p> <p>If provided, the message contents. If hikari.undefined.UNDEFINED, then nothing will be sent in the content. Any other value here will be cast to a str.</p> <p>If this is a hikari.embeds.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.files.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> <p> TYPE: <code>hikari.UndefinedOr[typing.Any]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>ensure_result</code> <p>Ensure that this call will always return a message object.</p> <p>If True then this will always return hikari.messages.Message, otherwise this will return <code>hikari.Message | None</code>.</p> <p>It's worth noting that, under certain scenarios within the slash command flow, this may lead to an extre request being made.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>delete_after</code> <p>If provided, the seconds after which the response message should be deleted.</p> <p>Slash command responses can only be deleted within 15 minutes of the command being received.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, float, int, None]</code> DEFAULT: <code>None</code> </p> <code>attachment</code> <p>If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Resourceish]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachments</code> <p>If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Resourceish]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>component</code> <p>If provided, builder object of the component to include in this response.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.api.ComponentBuilder]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>components</code> <p>If provided, a sequence of the component builder objects to include in this response.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.api.ComponentBuilder]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embed</code> <p>An embed to respond with.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Embed]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embeds</code> <p>A sequence of embeds to respond with.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Embed]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>mentions_everyone</code> <p>If provided, whether the message should parse @everyone/@here mentions.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>user_mentions</code> <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.users.PartialUser derivatives to enforce mentioning specific users.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialUser], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>role_mentions</code> <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialRole], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> RETURNS DESCRIPTION <code>hikari.Message | None</code> <p>The message that has been created if it was immedieatly available or <code>ensure_result</code> was set to True, else None.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If <code>delete_after</code> would be more than 15 minutes after the slash command was called.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed.</p> <code>hikari.BadRequestError</code> <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> <code>hikari.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.ForbiddenError</code> <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> <code>hikari.NotFoundError</code> <p>If the channel is not found.</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/abc/#tanjun.abc.ExecutableCommand","title":"ExecutableCommand","text":"<p>         Bases: <code>abc.ABC</code>, <code>typing.Generic[_ContextT_co]</code></p> <p>Base class for all commands that can be executed.</p>"},{"location":"reference/abc/#tanjun.abc.ExecutableCommand.checks","title":"checks  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>checks: collections.Collection[CheckSig[_ContextT_co]]\n</code></pre> <p>Collection of checks that must be met before the command can be executed.</p>"},{"location":"reference/abc/#tanjun.abc.ExecutableCommand.component","title":"component  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>component: typing.Optional[Component]\n</code></pre> <p>Component that the command is registered with.</p>"},{"location":"reference/abc/#tanjun.abc.ExecutableCommand.hooks","title":"hooks  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>hooks: typing.Optional[Hooks[_ContextT_co]]\n</code></pre> <p>Hooks that are triggered when the command is executed.</p>"},{"location":"reference/abc/#tanjun.abc.ExecutableCommand.metadata","title":"metadata  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>metadata: collections.MutableMapping[typing.Any, typing.Any]\n</code></pre> <p>Mutable mapping of metadata set for this command.</p> <p>Note</p> <p>Any modifications made to this mutable mapping will be preserved by the command.</p>"},{"location":"reference/abc/#tanjun.abc.ExecutableCommand.add_check","title":"add_check  <code>abstractmethod</code>","text":"<pre><code>add_check(*checks)\n</code></pre> <p>Add a check to the command.</p> PARAMETER DESCRIPTION <code>*checks</code> <p>The checks to add.</p> <p> TYPE: <code>CheckSig[_ContextT_co]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This command to enable chained calls</p>"},{"location":"reference/abc/#tanjun.abc.ExecutableCommand.copy","title":"copy  <code>abstractmethod</code>","text":"<pre><code>copy()\n</code></pre> <p>Create a copy of this command.</p> RETURNS DESCRIPTION <code>Self</code> <p>A copy of this command.</p>"},{"location":"reference/abc/#tanjun.abc.ExecutableCommand.remove_check","title":"remove_check  <code>abstractmethod</code>","text":"<pre><code>remove_check(check)\n</code></pre> <p>Remove a check from the command.</p> PARAMETER DESCRIPTION <code>check</code> <p>The check to remove.</p> <p> TYPE: <code>CheckSig[_ContextT_co]</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the provided check isn't found.</p> RETURNS DESCRIPTION <code>Self</code> <p>This command to enable chained calls</p>"},{"location":"reference/abc/#tanjun.abc.ExecutableCommand.set_hooks","title":"set_hooks  <code>abstractmethod</code>","text":"<pre><code>set_hooks(hooks)\n</code></pre> <p>Set the hooks that are triggered when the command is executed.</p> PARAMETER DESCRIPTION <code>hooks</code> <p>The hooks that are triggered when the command is executed.</p> <p> TYPE: <code>Hooks[Context] | None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This command to enable chained calls</p>"},{"location":"reference/abc/#tanjun.abc.ExecutableCommand.set_metadata","title":"set_metadata  <code>abstractmethod</code>","text":"<pre><code>set_metadata(key, value)\n</code></pre> <p>Set a field in the command's metadata.</p> PARAMETER DESCRIPTION <code>key</code> <p>Metadata key to set.</p> <p> TYPE: <code>typing.Any</code> </p> <code>value</code> <p>Metadata value to set.</p> <p> TYPE: <code>typing.Any</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command instance to enable chained calls.</p>"},{"location":"reference/abc/#tanjun.abc.Hooks","title":"Hooks","text":"<p>         Bases: <code>abc.ABC</code>, <code>typing.Generic[_ContextT_contra]</code></p> <p>Interface of a collection of callbacks called during set stage of command execution.</p>"},{"location":"reference/abc/#tanjun.abc.Hooks.add_on_error","title":"add_on_error  <code>abstractmethod</code>","text":"<pre><code>add_on_error(callback)\n</code></pre> <p>Add an error callback to this hook object.</p> <p>Note</p> <p>This won't be called for expected tanjun.TanjunError derived errors.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to add to this hook.</p> <p>This callback should take two positional arguments (of type tanjun.abc.Context and Exception) and may be either synchronous or asynchronous.</p> <p>Returning True indicates that the error should be suppressed, False that it should be re-raised and None that no decision has been made. This will be accounted for along with the decisions other error hooks make by majority rule.</p> <p> TYPE: <code>ErrorHookSig[_ContextT_contra]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The hook object to enable method chaining.</p>"},{"location":"reference/abc/#tanjun.abc.Hooks.add_on_parser_error","title":"add_on_parser_error  <code>abstractmethod</code>","text":"<pre><code>add_on_parser_error(callback)\n</code></pre> <p>Add a parser error callback to this hook object.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to add to this hook.</p> <p>This callback should take two positional arguments (of type tanjun.abc.Context and tanjun.ParserError), return None and may be either synchronous or asynchronous.</p> <p>It's worth noting that this unlike general error handlers, this will always suppress the error.</p> <p> TYPE: <code>ParserHookSig[_ContextT_contra]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The hook object to enable method chaining.</p>"},{"location":"reference/abc/#tanjun.abc.Hooks.add_on_success","title":"add_on_success  <code>abstractmethod</code>","text":"<pre><code>add_on_success(callback)\n</code></pre> <p>Add a success callback to this hook object.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to add to this hook.</p> <p>This callback should take one positional argument (of type tanjun.abc.Context), return None and may be either synchronous or asynchronous.</p> <p> TYPE: <code>HookSig[_ContextT_contra]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The hook object to enable method chaining.</p>"},{"location":"reference/abc/#tanjun.abc.Hooks.add_post_execution","title":"add_post_execution  <code>abstractmethod</code>","text":"<pre><code>add_post_execution(callback)\n</code></pre> <p>Add a post-execution callback to this hook object.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to add to this hook.</p> <p>This callback should take one positional argument (of type tanjun.abc.Context), return None and may be either synchronous or asynchronous.</p> <p> TYPE: <code>HookSig[_ContextT_contra]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The hook object to enable method chaining.</p>"},{"location":"reference/abc/#tanjun.abc.Hooks.add_pre_execution","title":"add_pre_execution  <code>abstractmethod</code>","text":"<pre><code>add_pre_execution(callback)\n</code></pre> <p>Add a pre-execution callback for this hook object.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to add to this hook.</p> <p>This callback should take one positional argument (of type tanjun.abc.Context), return None and may be either synchronous or asynchronous.</p> <p> TYPE: <code>HookSig[_ContextT_contra]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The hook object to enable method chaining.</p>"},{"location":"reference/abc/#tanjun.abc.Hooks.with_on_error","title":"with_on_error  <code>abstractmethod</code>","text":"<pre><code>with_on_error(callback)\n</code></pre> <p>Add an error callback to this hook object through a decorator call.</p> <p>Note</p> <p>This won't be called for expected tanjun.TanjunError derived errors.</p> <p>Examples:</p> <pre><code>hooks = AnyHooks()\n\n@hooks.with_on_error\nasync def on_error(ctx: tanjun.abc.Context, error: Exception) -&gt; bool:\n    if isinstance(error, SomeExpectedType):\n        await ctx.respond(\"You dun goofed\")\n        return True  # Indicating that it should be suppressed.\n\n    await ctx.respond(f\"An error occurred: {error}\")\n    return False  # Indicating that it should be re-raised\n</code></pre> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to add to this hook.</p> <p>This callback should take two positional arguments (of type tanjun.abc.Context and Exception) and may be either synchronous or asynchronous.</p> <p>Returning True indicates that the error should be suppressed, False that it should be re-raised and None that no decision has been made. This will be accounted for along with the decisions other error hooks make by majority rule.</p> <p> TYPE: <code>tanjun.abc.ErrorHookSig</code> </p> RETURNS DESCRIPTION <code>ErrorHookSig</code> <p>The hook callback which was added.</p>"},{"location":"reference/abc/#tanjun.abc.Hooks.with_on_parser_error","title":"with_on_parser_error  <code>abstractmethod</code>","text":"<pre><code>with_on_parser_error(callback)\n</code></pre> <p>Add a parser error callback to this hook object through a decorator call.</p> <p>Examples:</p> <pre><code>hooks = AnyHooks()\n\n@hooks.with_on_parser_error\nasync def on_parser_error(ctx: tanjun.abc.Context, error: tanjun.ParserError) -&gt; None:\n    await ctx.respond(f\"You gave invalid input: {error}\")\n</code></pre> PARAMETER DESCRIPTION <code>callback</code> <p>The parser error callback to add to this hook.</p> <p>This callback should take two positional arguments (of type tanjun.abc.Context and tanjun.ParserError), return None and may be either synchronous or asynchronous.</p> <p> TYPE: <code>tanjun.abc.ParserHookSig</code> </p> RETURNS DESCRIPTION <code>HookSig</code> <p>The callback which was added.</p>"},{"location":"reference/abc/#tanjun.abc.Hooks.with_on_success","title":"with_on_success  <code>abstractmethod</code>","text":"<pre><code>with_on_success(callback)\n</code></pre> <p>Add a success callback to this hook object through a decorator call.</p> <p>Examples:</p> <pre><code>hooks = AnyHooks()\n\n@hooks.with_on_success\nasync def on_success(ctx: tanjun.abc.Context) -&gt; None:\n    await ctx.respond(\"You did something\")\n</code></pre> PARAMETER DESCRIPTION <code>callback</code> <p>The success callback to add to this hook.</p> <p>This callback should take one positional argument (of type tanjun.abc.Context), return None and may be either synchronous or asynchronous.</p> <p> TYPE: <code>tanjun.abc.HookSig</code> </p> RETURNS DESCRIPTION <code>HookSig</code> <p>The success callback which was added.</p>"},{"location":"reference/abc/#tanjun.abc.Hooks.with_post_execution","title":"with_post_execution  <code>abstractmethod</code>","text":"<pre><code>with_post_execution(callback)\n</code></pre> <p>Add a post-execution callback to this hook object through a decorator call.</p> <p>Examples:</p> <pre><code>hooks = AnyHooks()\n\n@hooks.with_post_execution\nasync def post_execution(ctx: tanjun.abc.Context) -&gt; None:\n    await ctx.respond(\"You did something\")\n</code></pre> PARAMETER DESCRIPTION <code>callback</code> <p>The post-execution callback to add to this hook.</p> <p>This callback should take one positional argument (of type tanjun.abc.Context), return None and may be either synchronous or asynchronous.</p> <p> TYPE: <code>tanjun.abc.HookSig</code> </p> RETURNS DESCRIPTION <code>HookSig</code> <p>The post-execution callback which was seaddedt.</p>"},{"location":"reference/abc/#tanjun.abc.Hooks.with_pre_execution","title":"with_pre_execution  <code>abstractmethod</code>","text":"<pre><code>with_pre_execution(callback)\n</code></pre> <p>Add a pre-execution callback to this hook object through a decorator call.</p> <p>Examples:</p> <pre><code>hooks = AnyHooks()\n\n@hooks.with_pre_execution\nasync def pre_execution(ctx: tanjun.abc.Context) -&gt; None:\n    await ctx.respond(\"You did something\")\n</code></pre> PARAMETER DESCRIPTION <code>callback</code> <p>The pre-execution callback to add to this hook.</p> <p>This callback should take one positional argument (of type tanjun.abc.Context), return None and may be either synchronous or asynchronous.</p> <p> TYPE: <code>tanjun.abc.HookSig</code> </p> RETURNS DESCRIPTION <code>HookSig</code> <p>The pre-execution callback which was added.</p>"},{"location":"reference/abc/#tanjun.abc.MenuCommand","title":"MenuCommand","text":"<p>         Bases: <code>AppCommand[MenuContext]</code>, <code>typing.Generic[_MenuCallbackSigT, _MenuTypeT]</code></p> <p>A contextmenu command.</p>"},{"location":"reference/abc/#tanjun.abc.MenuCommand.callback","title":"callback  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>callback: _MenuCallbackSigT\n</code></pre> <p>Callback which is called during execution.</p>"},{"location":"reference/abc/#tanjun.abc.MenuCommand.tracked_command","title":"tracked_command  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>tracked_command: typing.Optional[hikari.ContextMenuCommand]\n</code></pre> <p>Object of the actual command this object tracks if set.</p>"},{"location":"reference/abc/#tanjun.abc.MenuCommand.type","title":"type  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>type: _MenuTypeT\n</code></pre> <p>The menu type(s) this is for.</p>"},{"location":"reference/abc/#tanjun.abc.MenuCommand.build","title":"build  <code>abstractmethod</code>","text":"<pre><code>build(*, component=None)\n</code></pre> <p>Get a builder object for this command.</p> PARAMETER DESCRIPTION <code>component</code> <p>The component to inherit config like <code>default_member_permissions</code> and <code>is_dm_enabled</code> from if not explicitly set on the command.</p> <p>This defaults to the command's linked component.</p> <p> TYPE: <code>typing.Optional[Component]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>hikari.api.ContextMenuCommandBuilder</code> <p>A builder object for this command. Use to declare this command on globally or for a specific guild.</p>"},{"location":"reference/abc/#tanjun.abc.MenuContext","title":"MenuContext","text":"<p>         Bases: <code>AppCommandContext</code>, <code>abc.ABC</code></p> <p>Interface of a menu command context.</p>"},{"location":"reference/abc/#tanjun.abc.MenuContext.command","title":"command  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>command: typing.Optional[MenuCommand[typing.Any, typing.Any]]\n</code></pre> <p>Command that was invoked.</p> <p>Note</p> <p>This should always be set during command check execution and command hook execution but isn't guaranteed for client callbacks nor component/client checks.</p>"},{"location":"reference/abc/#tanjun.abc.MenuContext.target","title":"target  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>target: typing.Union[hikari.InteractionMember, hikari.User, hikari.Message]\n</code></pre> <p>Object of the entity this menu targets.</p>"},{"location":"reference/abc/#tanjun.abc.MenuContext.target_id","title":"target_id  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>target_id: hikari.Snowflake\n</code></pre> <p>ID of the entity this menu command context targets.</p>"},{"location":"reference/abc/#tanjun.abc.MenuContext.type","title":"type  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>type: typing.Literal[hikari.CommandType.MESSAGE, hikari.CommandType.USER]\n</code></pre> <p>The type of context menu this context is for.</p>"},{"location":"reference/abc/#tanjun.abc.MenuContext.resolve_to_member","title":"resolve_to_member  <code>abstractmethod</code>","text":"<pre><code>resolve_to_member(*, default=Ellipsis)\n</code></pre> <p>Resolve a user context menu context to a member object.</p> RETURNS DESCRIPTION <code>hikari.Member</code> <p>The resolved member.</p> RAISES DESCRIPTION <code>TypeError</code> <p>If the context is not a user menu context.</p> <code>LookupError</code> <p>If the member was not found for this user menu context.</p> <p>This will happen if this was executed in a DM or the target user isn't in the current guild.</p>"},{"location":"reference/abc/#tanjun.abc.MenuContext.resolve_to_message","title":"resolve_to_message  <code>abstractmethod</code>","text":"<pre><code>resolve_to_message()\n</code></pre> <p>Resolve a message context menu to a message object.</p> RETURNS DESCRIPTION <code>hikari.Message</code> <p>The resolved message.</p> RAISES DESCRIPTION <code>TypeEror</code> <code>if the context is not for a message menu.</code>"},{"location":"reference/abc/#tanjun.abc.MenuContext.resolve_to_user","title":"resolve_to_user  <code>abstractmethod</code>","text":"<pre><code>resolve_to_user()\n</code></pre> <p>Resolve a user context menu context to a user object.</p> RETURNS DESCRIPTION <code>hikari.User | hikari.Member</code> <p>The resolved user.</p> RAISES DESCRIPTION <code>TypeError</code> <p>If the context is not a user menu context.</p>"},{"location":"reference/abc/#tanjun.abc.MenuContext.set_command","title":"set_command  <code>abstractmethod</code>","text":"<pre><code>set_command(command)\n</code></pre> <p>Set the command for this context.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command this context is for.</p> <p> TYPE: <code>typing.Optional[MenuCommand[typing.Any, typing.Any]]</code> </p>"},{"location":"reference/abc/#tanjun.abc.MessageCommand","title":"MessageCommand","text":"<p>         Bases: <code>ExecutableCommand[MessageContext]</code>, <code>abc.ABC</code>, <code>typing.Generic[_MessageCallbackSigT]</code></p> <p>Standard interface of a message command.</p>"},{"location":"reference/abc/#tanjun.abc.MessageCommand.callback","title":"callback  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>callback: _MessageCallbackSigT\n</code></pre> <p>Callback which is called during execution.</p> <p>Note</p> <p>For command groups, this is called when none of the inner-commands matches the message.</p>"},{"location":"reference/abc/#tanjun.abc.MessageCommand.names","title":"names  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>names: collections.Collection[str]\n</code></pre> <p>Collection of this command's names.</p>"},{"location":"reference/abc/#tanjun.abc.MessageCommand.parent","title":"parent  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>parent: typing.Optional[MessageCommandGroup[typing.Any]]\n</code></pre> <p>Parent group of this command if applicable.</p>"},{"location":"reference/abc/#tanjun.abc.MessageCommand.parser","title":"parser  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>parser: typing.Optional[MessageParser]\n</code></pre> <p>Parser for this command.</p>"},{"location":"reference/abc/#tanjun.abc.MessageCommand.copy","title":"copy  <code>abstractmethod</code>","text":"<pre><code>copy(*, parent=None)\n</code></pre> <p>Create a copy of this command.</p> PARAMETER DESCRIPTION <code>parent</code> <p>The parent of the copy.</p> <p> TYPE: <code>typing.Optional[MessageCommandGroup[typing.Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The copy.</p>"},{"location":"reference/abc/#tanjun.abc.MessageCommand.set_parent","title":"set_parent  <code>abstractmethod</code>","text":"<pre><code>set_parent(parent)\n</code></pre> <p>Set the parent of this command.</p> PARAMETER DESCRIPTION <code>parent</code> <p>The parent of this command.</p> <p> TYPE: <code>typing.Optional[MessageCommandGroup[typing.Any]]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command instance to enable chained calls.</p>"},{"location":"reference/abc/#tanjun.abc.MessageCommand.set_parser","title":"set_parser  <code>abstractmethod</code>","text":"<pre><code>set_parser(parser)\n</code></pre> <p>Set the for this message command.</p> PARAMETER DESCRIPTION <code>parser</code> <p>The parser to set.</p> <p> TYPE: <code>MessageParser</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command instance to enable chained calls.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If this parser's option keys aren't valid for this command when <code>validate_arg_keys</code> is True.</p>"},{"location":"reference/abc/#tanjun.abc.MessageCommandGroup","title":"MessageCommandGroup","text":"<p>         Bases: <code>MessageCommand[_MessageCallbackSigT]</code>, <code>abc.ABC</code></p> <p>Standard interface of a message command group.</p>"},{"location":"reference/abc/#tanjun.abc.MessageCommandGroup.commands","title":"commands  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>commands: collections.Collection[MessageCommand[typing.Any]]\n</code></pre> <p>Collection of the commands in this group.</p> <p>Note</p> <p>This may include command groups.</p>"},{"location":"reference/abc/#tanjun.abc.MessageCommandGroup.add_command","title":"add_command  <code>abstractmethod</code>","text":"<pre><code>add_command(command)\n</code></pre> <p>Add a command to this group.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add.</p> <p> TYPE: <code>MessageCommand[typing.Any]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The group instance to enable chained calls.</p>"},{"location":"reference/abc/#tanjun.abc.MessageCommandGroup.remove_command","title":"remove_command  <code>abstractmethod</code>","text":"<pre><code>remove_command(command)\n</code></pre> <p>Remove a command from this group.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to remove.</p> <p> TYPE: <code>MessageCommand[typing.Any]</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the provided command isn't found.</p> RETURNS DESCRIPTION <code>Self</code> <p>The group instance to enable chained calls.</p>"},{"location":"reference/abc/#tanjun.abc.MessageCommandGroup.with_command","title":"with_command  <code>abstractmethod</code>","text":"<pre><code>with_command(command)\n</code></pre> <p>Add a command to this group through a decorator call.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add.</p> <p> TYPE: <code>MessageCommand</code> </p> RETURNS DESCRIPTION <code>MessageCommand</code> <p>The added command.</p>"},{"location":"reference/abc/#tanjun.abc.MessageContext","title":"MessageContext","text":"<p>         Bases: <code>Context</code>, <code>abc.ABC</code></p> <p>Interface of a message command specific context.</p>"},{"location":"reference/abc/#tanjun.abc.MessageContext.command","title":"command  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>command: typing.Optional[MessageCommand[typing.Any]]\n</code></pre> <p>Command that was invoked.</p> <p>Note</p> <p>This is always set during command, command check and parser converter execution but isn't guaranteed during client callback nor client/component check execution.</p>"},{"location":"reference/abc/#tanjun.abc.MessageContext.content","title":"content  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>content: str\n</code></pre> <p>Content of the context's message minus the triggering name and prefix.</p>"},{"location":"reference/abc/#tanjun.abc.MessageContext.message","title":"message  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>message: hikari.Message\n</code></pre> <p>Message that triggered the context.</p>"},{"location":"reference/abc/#tanjun.abc.MessageContext.triggering_prefix","title":"triggering_prefix  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>triggering_prefix: str\n</code></pre> <p>Prefix that triggered the context.</p>"},{"location":"reference/abc/#tanjun.abc.MessageContext.respond","title":"respond  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>respond(content=hikari.UNDEFINED, *, ensure_result=True, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, sticker=hikari.UNDEFINED, stickers=hikari.UNDEFINED, tts=hikari.UNDEFINED, reply=False, mentions_everyone=hikari.UNDEFINED, mentions_reply=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Respond to this context.</p> PARAMETER DESCRIPTION <code>content</code> <p>The content to respond with.</p> <p>If provided, the message contents. If hikari.undefined.UNDEFINED, then nothing will be sent in the content. Any other value here will be cast to a str.</p> <p>If this is a hikari.embeds.Embed and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a hikari.files.Resource, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</p> <p> TYPE: <code>hikari.UndefinedOr[typing.Any]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>ensure_result</code> <p>Ensure this method call will return a message object.</p> <p>This does nothing for message command contexts as the result w ill always be immedieatly available.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>delete_after</code> <p>If provided, the seconds after which the response message should be deleted.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, float, int, None]</code> DEFAULT: <code>None</code> </p> <code>tts</code> <p>Whether to respond with tts/text to speech or no.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>reply</code> <p>Whether to reply instead of sending the content to the context.</p> <p>Passing True here indicates a reply to tanjun.abc.MessageContext.message.</p> <p> TYPE: <code>typing.Union[bool, hikari.SnowflakeishOr[hikari.PartialMessage], hikari.UndefinedType]</code> DEFAULT: <code>False</code> </p> <code>attachment</code> <p>A singular attachment to respond with.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Resourceish]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachments</code> <p>A sequence of attachments to respond with.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Resourceish]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>component</code> <p>If provided, builder object of the component to include in this message.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.api.ComponentBuilder]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>components</code> <p>If provided, a sequence of the component builder objects to include in this message.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.api.ComponentBuilder]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embed</code> <p>An embed to respond with.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Embed]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embeds</code> <p>A sequence of embeds to respond with.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Embed]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>sticker</code> <p>If provided, the object or ID of a sticker to send on the message.</p> <p>As of writing, bots can only send custom stickers from the current guild.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.SnowflakeishOr[hikari.PartialSticker]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>stickers</code> <p>If provided, a sequence of the objects and IDs of up to 3 stickers to send on the message.</p> <p>As of writing, bots can only send custom stickers from the current guild.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.SnowflakeishSequence[hikari.PartialSticker]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>mentions_everyone</code> <p>If provided, whether the message should parse @everyone/@here mentions.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>user_mentions</code> <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.users.PartialUser derivatives to enforce mentioning specific users.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialUser], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>role_mentions</code> <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialRole], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> RETURNS DESCRIPTION <code>hikari.Message</code> <p>The message that has been created.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.</p> <p>If the interaction will have expired before <code>delete_after</code> is reached.</p> <p>If both <code>attachment</code> and <code>attachments</code> are passed or both <code>component</code> and <code>components</code> are passed or both <code>embed</code> and <code>embeds</code> are passed or both <code>sticker</code> and <code>stickers</code> are passed.</p> <code>hikari.BadRequestError</code> <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; if <code>reply</code> is not found or not in the same channel as <code>channel</code>; too many components.</p> <code>hikari.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.ForbiddenError</code> <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> <code>hikari.NotFoundError</code> <p>If the channel is not found.</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/abc/#tanjun.abc.MessageParser","title":"MessageParser","text":"<p>         Bases: <code>abc.ABC</code></p> <p>Base class for a message parser.</p>"},{"location":"reference/abc/#tanjun.abc.MessageParser.copy","title":"copy  <code>abstractmethod</code>","text":"<pre><code>copy()\n</code></pre> <p>Copy the parser.</p> RETURNS DESCRIPTION <code>Self</code> <p>A copy of the parser.</p>"},{"location":"reference/abc/#tanjun.abc.MessageParser.parse","title":"parse  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>parse(ctx)\n</code></pre> <p>Parse a message context.</p> <p>Warning</p> <p>This relies on the prefix and command name(s) having been removed from tanjun.abc.MessageContext.content.</p> PARAMETER DESCRIPTION <code>ctx</code> <p>The message context to parse.</p> <p> TYPE: <code>MessageContext</code> </p> RETURNS DESCRIPTION <code>dict[str, typing.Any]</code> <p>Dictionary of argument names to the parsed values for them.</p> RAISES DESCRIPTION <code>tanjun.ParserError</code> <p>If the message could not be parsed.</p>"},{"location":"reference/abc/#tanjun.abc.MessageParser.validate_arg_keys","title":"validate_arg_keys  <code>abstractmethod</code>","text":"<pre><code>validate_arg_keys(callback_name, names)\n</code></pre> <p>Validate that callback's keyword arguments are all valid for this parser.</p> PARAMETER DESCRIPTION <code>callback_name</code> <p>The callback's name for use in raised errors.</p> <p> TYPE: <code>str</code> </p> <code>names</code> <p>Key names of the callback's keyword arguments.</p> <p> TYPE: <code>collections.Container[str]</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If any of the parameter keys aren't valid for this parser.</p>"},{"location":"reference/abc/#tanjun.abc.SlashCommand","title":"SlashCommand","text":"<p>         Bases: <code>BaseSlashCommand</code>, <code>abc.ABC</code>, <code>typing.Generic[_SlashCallbackSigT]</code></p> <p>A command that can be executed in a slash context.</p>"},{"location":"reference/abc/#tanjun.abc.SlashCommand.callback","title":"callback  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>callback: _SlashCallbackSigT\n</code></pre> <p>Callback which is called during execution.</p>"},{"location":"reference/abc/#tanjun.abc.SlashCommand.float_autocompletes","title":"float_autocompletes  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>float_autocompletes: collections.Mapping[str, AutocompleteSig[float]]\n</code></pre> <p>Collection of the float option autocompletes.</p>"},{"location":"reference/abc/#tanjun.abc.SlashCommand.int_autocompletes","title":"int_autocompletes  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>int_autocompletes: collections.Mapping[str, AutocompleteSig[int]]\n</code></pre> <p>Collection of the integer option autocompletes.</p>"},{"location":"reference/abc/#tanjun.abc.SlashCommand.str_autocompletes","title":"str_autocompletes  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>str_autocompletes: collections.Mapping[str, AutocompleteSig[str]]\n</code></pre> <p>Collection of the string option autocompletes.</p>"},{"location":"reference/abc/#tanjun.abc.SlashCommandGroup","title":"SlashCommandGroup","text":"<p>         Bases: <code>BaseSlashCommand</code>, <code>abc.ABC</code></p> <p>Standard interface of a slash command group.</p> <p>Note</p> <p>Unlike tanjun.abc.MessageCommandGroup, slash command groups do not have their own callback.</p>"},{"location":"reference/abc/#tanjun.abc.SlashCommandGroup.commands","title":"commands  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>commands: collections.Collection[BaseSlashCommand]\n</code></pre> <p>Collection of the commands in this group.</p>"},{"location":"reference/abc/#tanjun.abc.SlashCommandGroup.add_command","title":"add_command  <code>abstractmethod</code>","text":"<pre><code>add_command(command)\n</code></pre> <p>Add a command to this group.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add.</p> <p> TYPE: <code>BaseSlashCommand</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command group instance to enable chained calls.</p>"},{"location":"reference/abc/#tanjun.abc.SlashCommandGroup.remove_command","title":"remove_command  <code>abstractmethod</code>","text":"<pre><code>remove_command(command)\n</code></pre> <p>Remove a command from this group.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to remove.</p> <p> TYPE: <code>BaseSlashCommand</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the provided command isn't found.</p> RETURNS DESCRIPTION <code>Self</code> <p>The command group instance to enable chained calls.</p>"},{"location":"reference/abc/#tanjun.abc.SlashCommandGroup.with_command","title":"with_command  <code>abstractmethod</code>","text":"<pre><code>with_command(command)\n</code></pre> <p>Add a command to this group through a decorator call.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add.</p> <p> TYPE: <code>_BaseSlashCommandT</code> </p> RETURNS DESCRIPTION <code>BaseSlashCommand</code> <p>The added command.</p>"},{"location":"reference/abc/#tanjun.abc.SlashContext","title":"SlashContext","text":"<p>         Bases: <code>AppCommandContext</code>, <code>abc.ABC</code></p> <p>Interface of a slash command specific context.</p>"},{"location":"reference/abc/#tanjun.abc.SlashContext.command","title":"command  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>command: typing.Optional[BaseSlashCommand]\n</code></pre> <p>Command that was invoked.</p> <p>Note</p> <p>This should always be set during command check execution and command hook execution but isn't guaranteed for client callbacks nor component/client checks.</p>"},{"location":"reference/abc/#tanjun.abc.SlashContext.options","title":"options  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>options: collections.Mapping[str, SlashOption]\n</code></pre> <p>Mapping of option names to the values provided for them.</p>"},{"location":"reference/abc/#tanjun.abc.SlashContext.type","title":"type  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>type: typing.Literal[hikari.CommandType.SLASH]\n</code></pre> <p>Type of application command this context is for.</p>"},{"location":"reference/abc/#tanjun.abc.SlashContext.set_command","title":"set_command  <code>abstractmethod</code>","text":"<pre><code>set_command(command)\n</code></pre> <p>Set the command for this context.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command this context is for.</p> <p> TYPE: <code>typing.Optional[BaseSlashCommand]</code> </p>"},{"location":"reference/abc/#tanjun.abc.SlashOption","title":"SlashOption","text":"<p>         Bases: <code>abc.ABC</code></p> <p>Interface of slash command option with extra logic to help resolve it.</p>"},{"location":"reference/abc/#tanjun.abc.SlashOption.name","title":"name  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of this option.</p>"},{"location":"reference/abc/#tanjun.abc.SlashOption.type","title":"type  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>type: typing.Union[hikari.OptionType, int]\n</code></pre> <p>Type of this option.</p>"},{"location":"reference/abc/#tanjun.abc.SlashOption.value","title":"value  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>value: typing.Union[str, hikari.Snowflake, int, bool, float]\n</code></pre> <p>Value provided for this option.</p> <p>Note</p> <p>For discord entity option types (user, member, channel and role) this will be the entity's ID.</p>"},{"location":"reference/abc/#tanjun.abc.SlashOption.boolean","title":"boolean  <code>abstractmethod</code>","text":"<pre><code>boolean()\n</code></pre> <p>Get the boolean value of this option.</p> RAISES DESCRIPTION <code>TypeError</code> <p>If tanjun.abc.SlashOption.type is not BOOLEAN.</p>"},{"location":"reference/abc/#tanjun.abc.SlashOption.float","title":"float  <code>abstractmethod</code>","text":"<pre><code>float()\n</code></pre> <p>Get the float value of this option.</p> RAISES DESCRIPTION <code>TypeError</code> <p>If tanjun.abc.SlashOption.type is not FLOAT.</p> <code>ValueError</code> <p>If called on the focused option for an autocomplete interaction when it's a malformed (incomplete) float.</p>"},{"location":"reference/abc/#tanjun.abc.SlashOption.integer","title":"integer  <code>abstractmethod</code>","text":"<pre><code>integer()\n</code></pre> <p>Get the integer value of this option.</p> RAISES DESCRIPTION <code>TypeError</code> <p>If tanjun.abc.SlashOption.type is not INTEGER.</p> <code>ValueError</code> <p>If called on the focused option for an autocomplete interaction when it's a malformed (incomplete) integer.</p>"},{"location":"reference/abc/#tanjun.abc.SlashOption.resolve_to_attachment","title":"resolve_to_attachment  <code>abstractmethod</code>","text":"<pre><code>resolve_to_attachment()\n</code></pre> <p>Resolve this option to a channel object.</p> RETURNS DESCRIPTION <code>hikari.Attachment</code> <p>The attachment object.</p> RAISES DESCRIPTION <code>TypeError</code> <p>If the option is not an attachment.</p>"},{"location":"reference/abc/#tanjun.abc.SlashOption.resolve_to_channel","title":"resolve_to_channel  <code>abstractmethod</code>","text":"<pre><code>resolve_to_channel()\n</code></pre> <p>Resolve this option to a channel object.</p> RETURNS DESCRIPTION <code>hikari.InteractionChannel</code> <p>The channel object.</p> RAISES DESCRIPTION <code>TypeError</code> <p>If the option is not a channel.</p>"},{"location":"reference/abc/#tanjun.abc.SlashOption.resolve_to_member","title":"resolve_to_member  <code>abstractmethod</code>","text":"<pre><code>resolve_to_member(*, default=Ellipsis)\n</code></pre> <p>Resolve this option to a member object.</p> PARAMETER DESCRIPTION <code>default</code> <p>The default value to return if this option cannot be resolved.</p> <p>If this is not provided, this method will raise a <code>TypeError</code> if this option cannot be resolved.</p> <p> TYPE: <code>_T</code> DEFAULT: <code>Ellipsis</code> </p> RETURNS DESCRIPTION <code>hikari.InteractionMember | _T</code> <p>The member object or <code>default</code> if it was provided and this option was a user type but had no member.</p> RAISES DESCRIPTION <code>LookupError</code> <p>If no member was found for this option and a <code>default</code> wasn't provided.</p> <p>This includes if the option is a mentionable type which targets a member-less user.</p> <p>This could happen if the user isn't in the current guild or if this command was executed in a DM and this option should still be resolvable to a user.</p> <code>TypeError</code> <p>If the option is not a user option and a <code>default</code> wasn't provided.</p> <p>This includes if the option is a mentionable type but doesn't target a user.</p>"},{"location":"reference/abc/#tanjun.abc.SlashOption.resolve_to_mentionable","title":"resolve_to_mentionable  <code>abstractmethod</code>","text":"<pre><code>resolve_to_mentionable()\n</code></pre> <p>Resolve this option to a mentionable object.</p> RETURNS DESCRIPTION <code>hikari.Role | hikari.User | hikari.Member</code> <p>The mentionable object.</p> RAISES DESCRIPTION <code>TypeError</code> <p>If the option is not a mentionable, user or role type.</p>"},{"location":"reference/abc/#tanjun.abc.SlashOption.resolve_to_role","title":"resolve_to_role  <code>abstractmethod</code>","text":"<pre><code>resolve_to_role()\n</code></pre> <p>Resolve this option to a role object.</p> RETURNS DESCRIPTION <code>hikari.Role</code> <p>The role object.</p> RAISES DESCRIPTION <code>TypeError</code> <p>If the option is not a role.</p> <p>This includes mentionable options which point towards a user.</p>"},{"location":"reference/abc/#tanjun.abc.SlashOption.resolve_to_user","title":"resolve_to_user  <code>abstractmethod</code>","text":"<pre><code>resolve_to_user()\n</code></pre> <p>Resolve this option to a user object.</p> <p>Note</p> <p>This will resolve to a hikari.guilds.Member first if the relevant command was executed within a guild and the option targeted one of the guild's members, otherwise it will resolve to hikari.users.User.</p> <p>It's also worth noting that hikari.Member inherits from hikari.User meaning that the return value of this can always be treated as a user.</p> RETURNS DESCRIPTION <code>hikari.User | hikari.Member</code> <p>The user object.</p> RAISES DESCRIPTION <code>TypeError</code> <p>If the option is not a user.</p> <p>This includes mentionable options which point towards a role.</p>"},{"location":"reference/abc/#tanjun.abc.SlashOption.resolve_value","title":"resolve_value  <code>abstractmethod</code>","text":"<pre><code>resolve_value()\n</code></pre> <p>Resolve this option to an object value.</p> RETURNS DESCRIPTION <code>hikari.Attachment | hikari.InteractionChannel | hikari.InteractionMember | hikari.Role | hikari.User</code> <p>The object value of this option.</p> RAISES DESCRIPTION <code>TypeError</code> <p>If the option isn't resolvable.</p>"},{"location":"reference/abc/#tanjun.abc.SlashOption.snowflake","title":"snowflake  <code>abstractmethod</code>","text":"<pre><code>snowflake()\n</code></pre> <p>Get the ID of this option.</p> RAISES DESCRIPTION <code>TypeError</code> <p>If tanjun.abc.SlashOption.type is not one of CHANNEL, MENTIONABLE, ROLE or USER.</p>"},{"location":"reference/abc/#tanjun.abc.SlashOption.string","title":"string  <code>abstractmethod</code>","text":"<pre><code>string()\n</code></pre> <p>Get the string value of this option.</p> RAISES DESCRIPTION <code>TypeError</code> <p>If tanjun.abc.SlashOption.type is not STRING.</p>"},{"location":"reference/annotations/","title":"tanjun.annotations","text":"<p>Parameter annotation based strategy for declaring slash and message command arguments.</p> <p>Community Resources:</p> <ul> <li>An extended implementation of this which parses callback docstrings to get the   descriptions for slash commands and their options can be found in   https://github.com/FasterSpeeding/Tan-chan.</li> </ul>"},{"location":"reference/annotations/#tanjun.annotations.Attachment","title":"Attachment  <code>module-attribute</code>","text":"<pre><code>Attachment = typing.Annotated[hikari.Attachment, _OptionMarker(hikari.Attachment)]\n</code></pre> <p>An argument which accepts a file.</p> <p>Warning</p> <p>This is currently only supported for slash commands.</p>"},{"location":"reference/annotations/#tanjun.annotations.Bool","title":"Bool  <code>module-attribute</code>","text":"<pre><code>Bool = typing.Annotated[bool, _OptionMarker(bool)]\n</code></pre> <p>An argument which takes a bool-like value.</p>"},{"location":"reference/annotations/#tanjun.annotations.Channel","title":"Channel  <code>module-attribute</code>","text":"<pre><code>Channel = typing.Annotated[hikari.PartialChannel, _OptionMarker(hikari.PartialChannel)]\n</code></pre> <p>An argument which takes a channel.</p> <p>hikari.InteractionChannel will be passed for options typed as this when being called as a slash command.</p>"},{"location":"reference/annotations/#tanjun.annotations.Color","title":"Color  <code>module-attribute</code>","text":"<pre><code>Color = typing.Annotated[hikari.Color, Converted(conversion.to_color)]\n</code></pre> <p>An argument which takes a color.</p>"},{"location":"reference/annotations/#tanjun.annotations.Colour","title":"Colour  <code>module-attribute</code>","text":"<pre><code>Colour = Color\n</code></pre> <p>An argument which takes a colour.</p>"},{"location":"reference/annotations/#tanjun.annotations.Datetime","title":"Datetime  <code>module-attribute</code>","text":"<pre><code>Datetime = typing.Annotated[datetime.datetime, Converted(conversion.to_datetime)]\n</code></pre> <p>An argument which takes a datetime.</p>"},{"location":"reference/annotations/#tanjun.annotations.Float","title":"Float  <code>module-attribute</code>","text":"<pre><code>Float = typing.Annotated[float, _OptionMarker(float)]\n</code></pre> <p>An argument which takes a floating point number.</p>"},{"location":"reference/annotations/#tanjun.annotations.Int","title":"Int  <code>module-attribute</code>","text":"<pre><code>Int = typing.Annotated[int, _OptionMarker(int)]\n</code></pre> <p>An argument which takes an integer.</p>"},{"location":"reference/annotations/#tanjun.annotations.InteractionChannel","title":"InteractionChannel  <code>module-attribute</code>","text":"<pre><code>InteractionChannel = typing.Annotated[hikari.InteractionChannel, _OptionMarker(hikari.InteractionChannel)]\n</code></pre> <p>An argument which takes a channel with interaction specific metadata.</p> <p>Warning</p> <p>This is only supported for slash commands and will not work for message commands (unlike annotations.Channel).</p>"},{"location":"reference/annotations/#tanjun.annotations.InteractionMember","title":"InteractionMember  <code>module-attribute</code>","text":"<pre><code>InteractionMember = typing.Annotated[hikari.InteractionMember, _OptionMarker(hikari.InteractionMember)]\n</code></pre> <p>An argument which takes a guild member with interaction specific metadata.</p> <p>Warning</p> <p>This is only supported for slash commands and will not work for message commands (unlike annotations.Member).</p>"},{"location":"reference/annotations/#tanjun.annotations.Member","title":"Member  <code>module-attribute</code>","text":"<pre><code>Member = typing.Annotated[hikari.Member, _OptionMarker(hikari.Member)]\n</code></pre> <p>An argument which takes a guild member.</p> <p>hikari.InteractionMember will be passed for options typed as this when being called as a slash command.</p>"},{"location":"reference/annotations/#tanjun.annotations.Mentionable","title":"Mentionable  <code>module-attribute</code>","text":"<pre><code>Mentionable = typing.Annotated[typing.Union[hikari.User, hikari.Role], _OptionMarker(_MentionableUnion)]\n</code></pre> <p>An argument which takes a user or role.</p>"},{"location":"reference/annotations/#tanjun.annotations.Role","title":"Role  <code>module-attribute</code>","text":"<pre><code>Role = typing.Annotated[hikari.Role, _OptionMarker(hikari.Role)]\n</code></pre> <p>An argument which takes a role.</p>"},{"location":"reference/annotations/#tanjun.annotations.Snowflake","title":"Snowflake  <code>module-attribute</code>","text":"<pre><code>Snowflake = typing.Annotated[hikari.Snowflake, Converted(conversion.parse_snowflake)]\n</code></pre> <p>An argument which takes a snowflake.</p>"},{"location":"reference/annotations/#tanjun.annotations.Str","title":"Str  <code>module-attribute</code>","text":"<pre><code>Str = typing.Annotated[str, _OptionMarker(str)]\n</code></pre> <p>An argument which takes string input.</p>"},{"location":"reference/annotations/#tanjun.annotations.User","title":"User  <code>module-attribute</code>","text":"<pre><code>User = typing.Annotated[hikari.User, _OptionMarker(hikari.User)]\n</code></pre> <p>An argument which takes a user.</p>"},{"location":"reference/annotations/#tanjun.annotations.Choices","title":"Choices","text":"<p>         Bases: <code>_ConfigIdentifier</code></p> <p>Assign up to 25 choices for a slash command option.</p> <p>Warning</p> <p>This is currently ignored for message commands and is only valid for string, integer and float options.</p> <p>Examples:</p> <pre><code>@with_annotated_args\n@tanjun.as_slash_command(\"beep\", \"meow\")\nasync def command(\n    ctx: tanjun.abc.Context,\n    location: Annotated[Int, \"where do you live?\", Choices(\"London\", \"Paradise\", \"Nowhere\")],\n) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/annotations/#tanjun.annotations.Choices.choices","title":"choices  <code>property</code>","text":"<pre><code>choices: collections.Mapping[str, _ChoiceUnion]\n</code></pre> <p>Mapping of up to 25 choices for the slash command option.</p>"},{"location":"reference/annotations/#tanjun.annotations.Choices.__init__","title":"__init__","text":"<pre><code>__init__(mapping=(), /, **kwargs)\n</code></pre> <p>Create a choices instance.</p> PARAMETER DESCRIPTION <code>mapping</code> <p>Either a mapping of names to the choices values or a sequence of <code>tuple[name, value]</code> or a sequence of choice values.</p> <p> TYPE: <code>typing.Union[collections.Mapping[str, _ChoiceT], collections.Sequence[tuple[str, _ChoiceT]], collections.Sequence[_ChoiceT]]</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Choice values.</p> <p> TYPE: <code>_ChoiceT</code> DEFAULT: <code>{}</code> </p>"},{"location":"reference/annotations/#tanjun.annotations.Converted","title":"Converted","text":"<p>         Bases: <code>_ConfigIdentifier</code></p> <p>Marked an argument as type Str with converters.</p> <p>Examples:</p> <pre><code>@with_annotated_args\n@tanjun.as_slash_command(\"beep\", \"boop\")\nasync def command(\n    ctx: tanjun.abc.SlashContext,\n    argument: Annotated[OtherType, Converted(callback, other_callback), \"description\"]\n    other_argument: Annotated[Converted[callback, other_callback], \"description\"],\n) -&gt; None:\n    raise NotImplementedError\n</code></pre> <p>Where <code>Converted[...]</code> follows the same semantics as Converted's <code>__init__</code>.</p>"},{"location":"reference/annotations/#tanjun.annotations.Converted.converters","title":"converters  <code>property</code>","text":"<pre><code>converters: collections.Sequence[_ConverterSig[typing.Any]]\n</code></pre> <p>A sequence of the converters.</p>"},{"location":"reference/annotations/#tanjun.annotations.Converted.__init__","title":"__init__","text":"<pre><code>__init__(converter, /, *other_converters)\n</code></pre> <p>Create a converted instance.</p> PARAMETER DESCRIPTION <code>converter</code> <p>The first converter this argument should use to handle values passed to it during parsing.</p> <p>Only the first converter to pass will be used.</p> <p> TYPE: <code>collections.abc.Callable[[str, ...], collections.Coroutine[Any, Any, Any] | Any]</code> </p> <code>*other_converters</code> <p>Other first converter(s) this argument should use to handle values passed to it during parsing.</p> <p>Only the first converter to pass will be used.</p> <p> TYPE: <code>collections.abc.Callable[[str, ...], collections.Coroutine[Any, Any, Any] | Any]</code> DEFAULT: <code>()</code> </p>"},{"location":"reference/annotations/#tanjun.annotations.Default","title":"Default","text":"<p>         Bases: <code>_ConfigIdentifier</code></p> <p>Explicitly configure an argument's default.</p> <p>Examples:</p> <pre><code>@with_annotated_args\n@tanjun.as_slash_command(\"name\", \"description\")\nasync def command(\n    ctx: tanjun.abc.Context,\n    argument: Annotated[Str, Default(\"\"), \"description\"],\n    other_argument: Annotated[Default[Str, \"\"], \"description\"],\n) -&gt; None:\n    raise NotImplementedError\n</code></pre> <pre><code>@with_annotated_args\n@tanjun.as_slash_command(\"name\", \"description\")\nasync def command(\n    ctx: tanjun.abc.Context,\n    required_argument: Annotated[Default[Str], \"description\"] = \"yeet\",\n    other_required: Annotated[Int, Default(), \"description\"] = 123,\n) -&gt; None:\n    raise NotImplementedError\n</code></pre> <p>Passing an empty Default allows you to mark an argument that's optional in the signature as being a required option.</p>"},{"location":"reference/annotations/#tanjun.annotations.Default.default","title":"default  <code>property</code>","text":"<pre><code>default: typing.Any\n</code></pre> <p>The option's default.</p> <p>This will override the default in the signature for this parameter.</p>"},{"location":"reference/annotations/#tanjun.annotations.Default.__init__","title":"__init__","text":"<pre><code>__init__(default=tanjun.NO_DEFAULT)\n</code></pre> <p>Initialise a default.</p> PARAMETER DESCRIPTION <code>default</code> <p>The argument's default.</p> <p>If left as tanjun.abc.NO_DEFAULT then the argument will be required regardless of the signature default.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p>"},{"location":"reference/annotations/#tanjun.annotations.Flag","title":"Flag","text":"<p>         Bases: <code>_ConfigIdentifier</code></p> <p>Mark an argument as a flag/option for message command parsing.</p> <p>This indicates that the argument should be specified by name (e.g. <code>--name</code>) rather than positionally for message parsing and doesn't effect slash command options.</p> <p>Examples:</p> <pre><code>@with_annotated_args\n@tanjun.as_message_command(\"message\")\nasync def command(\n    ctx: tanjun.abc.MessageContext,\n    flag_value: Annotated[Bool, Flag(empty_value=True, aliases=(\"-f\",))] = False,\n) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/annotations/#tanjun.annotations.Flag.aliases","title":"aliases  <code>property</code>","text":"<pre><code>aliases: typing.Optional[collections.Sequence[str]]\n</code></pre> <p>The aliases set for this flag.</p> <p>These do not override the flag's name.</p>"},{"location":"reference/annotations/#tanjun.annotations.Flag.default","title":"default  <code>property</code>","text":"<pre><code>default: typing.Any\n</code></pre> <p>The flag's default.</p> <p>If not specified then the default in the signature for this argument will be used.</p>"},{"location":"reference/annotations/#tanjun.annotations.Flag.empty_value","title":"empty_value  <code>property</code>","text":"<pre><code>empty_value: typing.Any\n</code></pre> <p>The value to pass for the argument if the flag is provided without a value.</p> <p>If this is tanjun.abc.NO_DEFAULT then a value will be required for this flag.</p>"},{"location":"reference/annotations/#tanjun.annotations.Flag.__init__","title":"__init__","text":"<pre><code>__init__(*, aliases=None, default=tanjun.NO_DEFAULT, empty_value=tanjun.NO_DEFAULT)\n</code></pre> <p>Create a flag instance.</p> PARAMETER DESCRIPTION <code>aliases</code> <p>Other names the flag may be triggered by.</p> <p>This does not override the argument's name.</p> <p> TYPE: <code>typing.Optional[collections.Sequence[str]]</code> DEFAULT: <code>None</code> </p> <code>empty_value</code> <p>Value to pass for the argument if the flag is provided without a value.</p> <p>If left undefined then an explicit value will always be needed.</p> <p>tanjun.abc.NO_PASS is not supported for this.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p>"},{"location":"reference/annotations/#tanjun.annotations.Greedy","title":"Greedy","text":"<p>         Bases: <code>_ConfigIdentifier</code></p> <p>Mark an argument as \"greedy\" for message command parsing.</p> <p>This means that it'll consume the rest of the positional arguments, can only be applied to one positional argument and is no-op for slash commands and flags.</p> <p>Examples:</p> <pre><code>@with_annotated_args\n@tanjun.as_message_command(\"message\")\nasync def command(\n    ctx: tanjun.abc.MessageContext,\n    greedy_arg: Greedy[Str],\n    other_greedy_arg: Annotated[Str, Greedy()],\n) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/annotations/#tanjun.annotations.Length","title":"Length","text":"<p>         Bases: <code>_ConfigIdentifier</code></p> <p>Define length restraints for a string option.</p> <p>Note</p> <p>Length constraints are applied before conversion for slash commands but after conversion for message commands.</p> <p>Examples:</p> <pre><code>@with_annotated_args\n@tanjun.as_slash_command(\"meow\", \"blam\")\nasync def command(\n    ctx: tanjun.abc.Context,\n    max_and_min: typing.Annotated[Str, Length(123, 321)],\n    max_only: typing.Annotated[Str, Length(123)],\n    generic_max_and_min: typing.Annotated[Length[5, 13], \"meow\"],\n    generic_max_only: typing.Annotated[Length[21], \"meow\"],\n) -&gt; None:\n    raise NotImplementedError\n</code></pre> <p>where <code>Length[...]</code> follows the same semantics as Length's <code>__init__</code>.</p> <pre><code>@with_annotated_args\n@tanjun.as_slash_command(\"meow\", \"description\")\nasync def command(\n    ctx: tanjun.abc.SlashContext,\n    argument: Annotated[Str, range(5, 100), \"description\"],\n    other_argument: Annotated[Str, 4:64, \"description\"],\n) -&gt; None:\n    raise NotImplementedError\n</code></pre> <p>Alternatively, the slice syntax and <code>range</code> may be used to set the length restraints for a string argument (where the start is inclusive and stop is exclusive). These default to a min_length of <code>0</code> if the start isn't specified and ignores any specified step.</p>"},{"location":"reference/annotations/#tanjun.annotations.Length.max_length","title":"max_length  <code>property</code>","text":"<pre><code>max_length: int\n</code></pre> <p>The maximum length of this string option.</p>"},{"location":"reference/annotations/#tanjun.annotations.Length.min_length","title":"min_length  <code>property</code>","text":"<pre><code>min_length: int\n</code></pre> <p>The minimum length of this string option.</p>"},{"location":"reference/annotations/#tanjun.annotations.Length.__init__","title":"__init__","text":"<pre><code>__init__(min_or_max_length, max_length=None)\n</code></pre> <p>Initialise a length constraint.</p> PARAMETER DESCRIPTION <code>min_or_max_length</code> <p>If <code>max_length</code> is left as None then this will be used as the maximum length and the minimum length will be <code>0</code>.</p> <p> TYPE: <code>int</code> </p> <code>max_length</code> <p>The maximum length this string argument can be.</p> <p>If not specified then <code>min_or_max_length</code> will be used as the max length.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/annotations/#tanjun.annotations.Max","title":"Max","text":"<p>         Bases: <code>_ConfigIdentifier</code></p> <p>Inclusive maximum value for a Float or Int argument.</p> <p>Examples:</p> <pre><code>@with_annotated_args\n@tanjun.as_slash_command(\"beep\", \"meow\")\nasync def command(\n    ctx: tanjun.abc.Context,\n    age: Annotated[Int, Max(130), \"How old are you?\"],\n    number: Annotated[Max[130.2], \"description\"],\n) -&gt; None:\n    raise NotImplementedError\n</code></pre> <p>The option's type is inferred from the passed value when using Max as a generic type hint (e.g. <code>Max[18]</code>).</p>"},{"location":"reference/annotations/#tanjun.annotations.Max.value","title":"value  <code>property</code>","text":"<pre><code>value: typing.Union[int, float]\n</code></pre> <p>The maximum allowed value.</p>"},{"location":"reference/annotations/#tanjun.annotations.Max.__init__","title":"__init__","text":"<pre><code>__init__(value)\n</code></pre> <p>Create an argument maximum value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The maximum allowed value allowed for an argument.</p> <p> TYPE: <code>typing.Union[int, float]</code> </p>"},{"location":"reference/annotations/#tanjun.annotations.Min","title":"Min","text":"<p>         Bases: <code>_ConfigIdentifier</code></p> <p>Inclusive minimum value for a Float or Int argument.</p> <p>Examples:</p> <pre><code>@with_annotated_args\n@tanjun.as_slash_command(\"beep\", \"meow\")\nasync def command(\n    ctx: tanjun.abc.Context,\n    age: Annotated[Int, Min(13), \"How old are you?\"],\n    number: Annotated[Min[13.9], \"description\"],\n) -&gt; None:\n    raise NotImplementedError\n</code></pre> <p>The option's type is inferred from the passed value when using Min as a generic type hint (e.g. <code>Min[69.4]</code>).</p>"},{"location":"reference/annotations/#tanjun.annotations.Min.value","title":"value  <code>property</code>","text":"<pre><code>value: typing.Union[int, float]\n</code></pre> <p>The minimum allowed  value.</p>"},{"location":"reference/annotations/#tanjun.annotations.Min.__init__","title":"__init__","text":"<pre><code>__init__(value)\n</code></pre> <p>Create an argument minimum value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The minimum value allowed for an argument.</p> <p> TYPE: <code>typing.Union[int, float]</code> </p>"},{"location":"reference/annotations/#tanjun.annotations.Name","title":"Name","text":"<p>         Bases: <code>_ConfigIdentifier</code></p> <p>Override the inferred name used to declare an option.</p> <p>Examples:</p> <pre><code>@with_annotated_args(follow_wrapped=True)\n@tanjun.as_slash_command(\"meow\", \"nyaa\")\n@tanjun.as_message_command(\"meow\")\nasync def command(\n    ctx: tanjun.abc.Context,\n    resource_type: Annotated[Str, Name(\"type\"), \"The type of resource to get.\"],\n) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/annotations/#tanjun.annotations.Name.message_name","title":"message_name  <code>property</code>","text":"<pre><code>message_name: typing.Optional[str]\n</code></pre> <p>The name to use for this option in message commands.</p>"},{"location":"reference/annotations/#tanjun.annotations.Name.slash_name","title":"slash_name  <code>property</code>","text":"<pre><code>slash_name: typing.Optional[str]\n</code></pre> <p>The name to use for this option in slash commands.</p>"},{"location":"reference/annotations/#tanjun.annotations.Name.__init__","title":"__init__","text":"<pre><code>__init__(both=None, /, *, message=None, slash=None)\n</code></pre> <p>Create an argument name override.</p> PARAMETER DESCRIPTION <code>both</code> <p>If provided, the name to use for this option in message and slash commands.</p> <p>This will be reformatted a bit for message commands (prefixed with <code>--</code> and <code>.replace(\"_\", \"-\")</code>) and is only used for message flag options.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>message</code> <p>The name to use for this option in message commands.</p> <p>This takes priority over <code>both</code>, is not reformatted and only is only used for flag options.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>slash</code> <p>The name to use for this option in slash commands.</p> <p>This takes priority over <code>both</code>.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/annotations/#tanjun.annotations.Positional","title":"Positional","text":"<p>         Bases: <code>_ConfigIdentifier</code></p> <p>Mark an argument as being passed positionally for message command parsing.</p> <p>Arguments will be positional by default (unless it has a default) and this allows for marking positional arguments as optional.</p> <p>This only effects message option parsing.</p> <p>Examples:</p> <pre><code>@with_annotated_args\n@tanjun.as_message_command(\"message\")\nasync def command(\n    ctx: tanjun.abc.MessageContext,\n    positional_arg: Positional[Str] = None,\n    other_positional_arg: Annotated[Str, Positional()] = None,\n) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/annotations/#tanjun.annotations.Ranged","title":"Ranged","text":"<p>         Bases: <code>_ConfigIdentifier</code></p> <p>Declare the range limit for an <code>Int</code> or <code>Float</code> argument.</p> <p>Examples:</p> <pre><code>@with_annotated_args(follow_wrapped=True)\n@tanjun.as_slash_command(\"meow\", \"nyaa\")\n@tanjun.as_message_command(\"meow\")\nasync def command(\n    ctx: tanjun.abc.Context,\n    number_arg: Annotated[Int, Ranged(0, 69), \"description\"],\n    other_number_arg: Annotated[Ranged[13.69, 420.69], \"description\"],\n) -&gt; None:\n    raise NotImplementedError\n</code></pre> <p>The option's type is inferred from whether integers or floats are passed when using Ranged as a generic type hint (e.g. <code>Ranged[123, 666]</code>).</p> <pre><code>@with_annotated_args\n@tanjun.as_slash_command(\"meow\", \"description\")\nasync def command(\n    ctx: tanjun.abc.SlashContext,\n    float_value: Annotated[Float, 1.5:101.5, \"description\"],\n    int_value: Annotated[Int, range(5, 100), \"description\"],\n) -&gt; None:\n    raise NotImplementedError\n</code></pre> <p>Alternatively, the slice syntax and <code>range</code> may be used to set the range for a float or integer argument (where the start is inclusive and stop is exclusive). These default to a min_value of <code>0</code> if the start isn't specified and ignores any specified step.</p>"},{"location":"reference/annotations/#tanjun.annotations.Ranged.max_value","title":"max_value  <code>property</code>","text":"<pre><code>max_value: typing.Union[int, float]\n</code></pre> <p>The maximum allowed value for this argument.</p>"},{"location":"reference/annotations/#tanjun.annotations.Ranged.min_value","title":"min_value  <code>property</code>","text":"<pre><code>min_value: typing.Union[int, float]\n</code></pre> <p>The minimum allowed value for this argument.</p>"},{"location":"reference/annotations/#tanjun.annotations.Ranged.__init__","title":"__init__","text":"<pre><code>__init__(min_value, max_value)\n</code></pre> <p>Create an argument range limit.</p> PARAMETER DESCRIPTION <code>min_value</code> <p>The minimum allowed value for this argument.</p> <p> TYPE: <code>typing.Union[int, float]</code> </p> <code>max_value</code> <p>The maximum allowed value for this argument.</p> <p> TYPE: <code>typing.Union[int, Float]</code> </p>"},{"location":"reference/annotations/#tanjun.annotations.SnowflakeOr","title":"SnowflakeOr","text":"<p>         Bases: <code>_ConfigIdentifier</code></p> <p>Mark an argument as taking an object or its ID.</p> <p>This allows for the argument to be declared as taking the object for slash commands without requiring that the message command equivalent fetch the object each time for the following types:</p> <ul> <li>User</li> <li>Role</li> <li>Member</li> <li>Channel</li> <li>Mentionable</li> </ul> <p>Examples:</p> <pre><code>@with_annotated_args(follow_wrapped=True)\n@tanjun.as_slash_command(\"meow\", \"nyaa\")\n@tanjun.as_message_command(\"meow\")\nasync def command(\n    ctx: tanjun.abc.Context,\n    user: Annotated[User, SnowflakeOr(parse_id=parse_user_id), \"The user to target.\"],\n\n    # The `parse_id` callback is automatically set to the mention format for\n    # the passed type if applicable when using SnowflakeOr as a generic type-hint.\n    role: Annotated[Optional[SnowflakeOr[Role]], \"The role to target.\"] = None,\n) -&gt; None:\n    user_id = hikari.Snowflake(user)\n</code></pre>"},{"location":"reference/annotations/#tanjun.annotations.SnowflakeOr.parse_id","title":"parse_id  <code>property</code>","text":"<pre><code>parse_id: collections.Callable[[str], hikari.Snowflake]\n</code></pre> <p>Callback used to parse this argument's ID.</p>"},{"location":"reference/annotations/#tanjun.annotations.SnowflakeOr.__init__","title":"__init__","text":"<pre><code>__init__(*, parse_id=conversion.parse_snowflake)\n</code></pre> <p>Create a snowflake or argument marker.</p> PARAMETER DESCRIPTION <code>parse_id</code> <p>The function used to parse the argument's ID.</p> <p>This can be used to restrain this to only accepting certain mention formats.</p> <p> TYPE: <code>collections.Callable[[str], hikari.Snowflake]</code> DEFAULT: <code>conversion.parse_snowflake</code> </p>"},{"location":"reference/annotations/#tanjun.annotations.TheseChannels","title":"TheseChannels","text":"<p>         Bases: <code>_ConfigIdentifier</code></p> <p>Restrain the type of channels a channel argument can target.</p>"},{"location":"reference/annotations/#tanjun.annotations.TheseChannels.channel_types","title":"channel_types  <code>property</code>","text":"<pre><code>channel_types: collections.Sequence[_ChannelTypeIsh]\n</code></pre> <p>Sequence of the channel types this is constrained by.</p>"},{"location":"reference/annotations/#tanjun.annotations.TheseChannels.__init__","title":"__init__","text":"<pre><code>__init__(channel_type, /, *other_types)\n</code></pre> <p>Create a channel argument restraint.</p> PARAMETER DESCRIPTION <code>channel_type</code> <p>A channel type to restrain this argument by.</p> <p> TYPE: <code>_ChannelTypeIsh</code> </p> <code>*other_types</code> <p>Other channel types to restrain this argument by.</p> <p> TYPE: <code>_ChannelTypeIsh</code> DEFAULT: <code>()</code> </p>"},{"location":"reference/annotations/#tanjun.annotations.parse_annotated_args","title":"parse_annotated_args","text":"<pre><code>parse_annotated_args(command, /, *, descriptions=None, follow_wrapped=False)\n</code></pre> <p>Set a command's arguments based on its signature.</p> <p>For more information on how this works see tanjun.annotations.with_annotated_args which acts as the decorator equivalent of this. The only difference is function allows passing a mapping of argument descriptions.</p> PARAMETER DESCRIPTION <code>command</code> <p>The message or slash command to set the arguments for.</p> <p> TYPE: <code>typing.Union[slash.SlashCommand[typing.Any], message.MessageCommand[typing.Any]]</code> </p> <code>descriptions</code> <p>Mapping of descriptions to use for this command's slash command options.</p> <p>If an option isn't included here then this will default back to getting the description from its annotation.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, str]]</code> DEFAULT: <code>None</code> </p> <code>follow_wrapped</code> <p>Whether this should also set the arguments on any other command objects this wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"reference/annotations/#tanjun.annotations.with_annotated_args","title":"with_annotated_args","text":"<pre><code>with_annotated_args(command=None, /, *, follow_wrapped=False)\n</code></pre> <p>Set a command's arguments based on its signature.</p> <p>To declare arguments you will have to do one of two things:</p> <ol> <li> <p>Using any of the following types as an argument's type-hint (this may be as the     first argument to typing.Annotated) will mark it as a command argument:</p> <ul> <li>tanjun.annotations.Attachment*</li> <li>tanjun.annotations.Bool</li> <li>tanjun.annotations.Channel</li> <li>tanjun.annotations.InteractionChannel*</li> <li>tanjun.annotations.Color/tanjun.annotations.Colour</li> <li>tanjun.annotations.Datetime</li> <li>tanjun.annotations.Float</li> <li>tanjun.annotations.Int</li> <li>tanjun.annotations.Member</li> <li>tanjun.annotations.InteractionMember*</li> <li>tanjun.annotations.Mentionable</li> <li>tanjun.annotations.Role</li> <li>tanjun.annotations.Snowflake</li> <li>tanjun.annotations.Str</li> <li>tanjun.annotations.User</li> </ul> <p>* These types are specific to slash commands and will raise an exception     when set for a message command's parameter which has no real default.</p> <pre><code>@tanjun.with_annotated_args(follow_wrapped=True)\n@tanjun.as_message_command(\"name\")\n@tanjun.as_slash_command(\"name\", \"description\")\nasync def command(\n    ctx: tanjun.abc.SlashContext,\n\n    # Here the option's description is passed as a string to Annotated:\n    # this is necessary for slash commands but ignored for message commands.\n    name: Annotated[Str, \"The character's name\"],\n\n    # `= False` declares this field as optional, with it defaulting to `False`\n    # if not specified.\n    lawyer: Annotated[Bool, \"Whether they're a lawyer\"] = False,\n) -&gt; None:\n    raise NotImplementedError\n</code></pre> </li> <li> <p>By assigning tanjun.annotations.Converted...</p> <p>Either as one of the other arguments to typing.Annotated</p> <pre><code>@tanjun.with_annotated_args(follow_wrapped=True)\n@tanjun.as_message_command(\"e\")\n@tanjun.as_slash_command(\"e\", \"description\")\nasync def command(\n    ctx: tanjun.abc.SlashContext,\n    value: Annotated[OtherType, Converted(parse_value), \"description\"],\n) -&gt; None:\n    raise NotImplementedError\n</code></pre> <p>or as the type hint</p> <pre><code>@tanjun.with_annotated_args(follow_wrapped=True)\n@tanjun.as_message_command(\"e\")\n@tanjun.as_slash_command(\"e\", \"description\")\nasync def command(\n    ctx: tanjun.abc.SlashContext,\n    value: Annotated[Converted[CustomType.from_str], \"description\"],\n) -&gt; None:\n    raise NotImplementedError\n</code></pre> </li> </ol> <p>It should be noted that wrapping in typing.Annotated isn't necessary for message commands options as they don't have descriptions.</p> <pre><code>async def message_command(\n    ctx: tanjun.abc.MessageContext,\n    name: Str,\n    converted: Converted[Type.from_str],\n    enable: typing.Optional[Bool] = None,\n) -&gt; None:\n    raise NotImplementedError\n</code></pre> <p>A typing.TypedDict can be used to declare multiple options by typing the passed <code>**kwargs</code> dict as it using typing.Unpack. These options can be marked as optional using typing.NotRequired, <code>total=False</code> or Default.</p> <pre><code>class CommandOptions(typing.TypedDict):\n    argument: Annotated[Str, \"A required string argument\"]\n    other: NotRequired[Annotated[Bool, \"An optional string argument\"]]\n\n@tanjun.with_annotated_args(follow_wrapped=True)\n@tanjun.as_message_command(\"name\")\n@tanjun.as_slash_command(\"name\", \"description\")\nasync def command(\n    ctx: tanjun.abc.Context, **kwargs: Unpack[CommandOptions],\n) -&gt; None:\n    raise NotImplementedError\n</code></pre> PARAMETER DESCRIPTION <code>command</code> <p>The message or slash command to set the arguments for.</p> <p> TYPE: <code>tanjun.SlashCommand | tanjun.MessageCommand</code> DEFAULT: <code>None</code> </p> <code>follow_wrapped</code> <p>Whether this should also set the arguments on any other command objects this wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tanjun.SlashCommand | tanjun.MessageCommand</code> <p>The command object to enable using this as a decorator.</p>"},{"location":"reference/checks/","title":"tanjun.checks","text":"<p>A collection of common standard checks designed for Tanjun commands.</p>"},{"location":"reference/checks/#tanjun.checks.AuthorPermissionCheck","title":"AuthorPermissionCheck","text":"<p>         Bases: <code>_Check</code></p> <p>Standard author permission check callback registered by tanjun.with_author_permission_check.</p> <p>This check will only pass if the current author has the specified permission.</p>"},{"location":"reference/checks/#tanjun.checks.AuthorPermissionCheck.__init__","title":"__init__","text":"<pre><code>__init__(permissions, /, *, error=None, error_message=\"You don't have the permissions required to use this command\", halt_execution=False)\n</code></pre> <p>Initialise an author permission check.</p> PARAMETER DESCRIPTION <code>permissions</code> <p>The permission(s) required for this command to run.</p> <p> TYPE: <code>typing.Union[hikari.Permissions, int]</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This should take 1 positional argument of type hikari.permissions.Permissions which represents the missing permissions required for this command to run.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[hikari.Permissions], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>Setting this to None will disable the error message allowing the command search to continue.</p> <p>This supports localisation and uses the check name <code>\"tanjun.AuthorPermissionCheck\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>\"You don't have the permissions required to use this command\"</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"reference/checks/#tanjun.checks.DmCheck","title":"DmCheck","text":"<p>         Bases: <code>_Check</code></p> <p>Standard DM check callback registered by tanjun.with_dm_check.</p> <p>This check will only pass if the current channel is a DM channel.</p>"},{"location":"reference/checks/#tanjun.checks.DmCheck.__init__","title":"__init__","text":"<pre><code>__init__(*, error=None, error_message='Command can only be used in DMs', halt_execution=False)\n</code></pre> <p>Initialise a DM check.</p> PARAMETER DESCRIPTION <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>Setting this to None will disable the error message allowing the command search to continue.</p> <p>This supports localisation and uses the check name <code>\"tanjun.DmCheck\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>'Command can only be used in DMs'</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"reference/checks/#tanjun.checks.GuildCheck","title":"GuildCheck","text":"<p>         Bases: <code>_Check</code></p> <p>Standard guild check callback registered by tanjun.with_guild_check.</p> <p>This check will only pass if the current channel is in a guild.</p>"},{"location":"reference/checks/#tanjun.checks.GuildCheck.__init__","title":"__init__","text":"<pre><code>__init__(*, error=None, error_message='Command can only be used in guild channels', halt_execution=False)\n</code></pre> <p>Initialise a guild check.</p> PARAMETER DESCRIPTION <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>Setting this to None will disable the error message allowing the command search to continue.</p> <p>This supports localisation and uses the check name <code>\"tanjun.GuildCheck\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>'Command can only be used in guild channels'</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"reference/checks/#tanjun.checks.NsfwCheck","title":"NsfwCheck","text":"<p>         Bases: <code>_Check</code></p> <p>Standard NSFW check callback registered by tanjun.with_nsfw_check.</p> <p>This check will only pass if the current channel is NSFW.</p>"},{"location":"reference/checks/#tanjun.checks.NsfwCheck.__init__","title":"__init__","text":"<pre><code>__init__(*, error=None, error_message='Command can only be used in NSFW channels', halt_execution=False)\n</code></pre> <p>Initialise a NSFW check.</p> PARAMETER DESCRIPTION <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>Setting this to None will disable the error message allowing the command search to continue.</p> <p>This supports localisation and uses the check name <code>\"tanjun.NsfwCheck\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>'Command can only be used in NSFW channels'</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"reference/checks/#tanjun.checks.OwnPermissionCheck","title":"OwnPermissionCheck","text":"<p>         Bases: <code>_Check</code></p> <p>Standard own permission check callback registered by tanjun.with_own_permission_check.</p> <p>This check will only pass if the current bot user has the specified permission.</p>"},{"location":"reference/checks/#tanjun.checks.OwnPermissionCheck.__init__","title":"__init__","text":"<pre><code>__init__(permissions, /, *, error=None, error_message=\"Bot doesn't have the permissions required to run this command\", halt_execution=False)\n</code></pre> <p>Initialise a own permission check.</p> PARAMETER DESCRIPTION <code>permissions</code> <p>The permission(s) required for this command to run.</p> <p> TYPE: <code>typing.Union[hikari.Permissions, int]</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This should take 1 positional argument of type hikari.permissions.Permissions which represents the missing permissions required for this command to run.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[hikari.Permissions], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>Setting this to None will disable the error message allowing the command search to continue.</p> <p>This supports localisation and uses the check name <code>\"tanjun.OwnPermissionCheck\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>\"Bot doesn't have the permissions required to run this command\"</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"reference/checks/#tanjun.checks.OwnerCheck","title":"OwnerCheck","text":"<p>         Bases: <code>_Check</code></p> <p>Standard owner check callback registered by tanjun.with_owner_check.</p> <p>This check will only pass if the author of the command is a bot owner.</p>"},{"location":"reference/checks/#tanjun.checks.OwnerCheck.__init__","title":"__init__","text":"<pre><code>__init__(*, error=None, error_message='Only bot owners can use this command', halt_execution=False)\n</code></pre> <p>Initialise an owner check.</p> PARAMETER DESCRIPTION <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>Setting this to None will disable the error message allowing the command search to continue.</p> <p>This supports localisation and uses the check name <code>\"tanjun.OwnerCheck\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>'Only bot owners can use this command'</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"reference/checks/#tanjun.checks.SfwCheck","title":"SfwCheck","text":"<p>         Bases: <code>_Check</code></p> <p>Standard SFW check callback registered by tanjun.with_sfw_check.</p> <p>This check will only pass if the current channel is SFW.</p>"},{"location":"reference/checks/#tanjun.checks.SfwCheck.__init__","title":"__init__","text":"<pre><code>__init__(*, error=None, error_message='Command can only be used in SFW channels', halt_execution=False)\n</code></pre> <p>Initialise a SFW check.</p> PARAMETER DESCRIPTION <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>Setting this to None will disable the error message allowing the command search to continue.</p> <p>This supports localisation and uses the check name <code>\"tanjun.SfwCheck\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>'Command can only be used in SFW channels'</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"reference/checks/#tanjun.checks.all_checks","title":"all_checks","text":"<pre><code>all_checks(check, /, *checks)\n</code></pre> <p>Combine multiple check callbacks into a check which will only pass if all the callbacks pass.</p> <p>This ensures that the callbacks are run in the order they were supplied in rather than concurrently.</p> PARAMETER DESCRIPTION <code>check</code> <p>The first check callback to combine.</p> <p> TYPE: <code>tanjun.CheckSig[_ContextT]</code> </p> <code>*checks</code> <p>Additional check callbacks to combine.</p> <p> TYPE: <code>tanjun.CheckSig[_ContextT]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.Context], collections.abc.Coroutine[typing.Any, typing.Any, bool]]</code> <p>A check which will pass if all of the provided check callbacks pass.</p>"},{"location":"reference/checks/#tanjun.checks.any_checks","title":"any_checks","text":"<pre><code>any_checks(check, /, *checks, error=None, error_message, halt_execution=False, suppress=(errors.CommandError, errors.HaltExecution))\n</code></pre> <p>Combine multiple checks into a check which'll pass if any of the callbacks pass.</p> <p>This ensures that the callbacks are run in the order they were supplied in rather than concurrently.</p> PARAMETER DESCRIPTION <code>check</code> <p>The first check callback to combine.</p> <p> TYPE: <code>tanjun.CheckSig[_ContextT]</code> </p> <code>*checks</code> <p>Additional check callbacks to combine.</p> <p> TYPE: <code>tanjun.CheckSig[_ContextT]</code> DEFAULT: <code>()</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>This supports localisation and uses the check name <code>\"tanjun.any_check\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>suppress</code> <p>Tuple of the exceptions to suppress when a check fails.</p> <p> TYPE: <code>tuple[type[Exception], ...]</code> DEFAULT: <code>(errors.CommandError, errors.HaltExecution)</code> </p> RETURNS DESCRIPTION <code>collections.Callable[[tanjun.abc.ExecutableCommand], tanjun.abc.ExecutableCommand]</code> <p>A decorator which adds the generated check to a command.</p>"},{"location":"reference/checks/#tanjun.checks.with_all_checks","title":"with_all_checks","text":"<pre><code>with_all_checks(check, /, *checks, follow_wrapped=False)\n</code></pre> <p>Add a check which will pass if all the provided checks pass through a decorator call.</p> <p>This ensures that the callbacks are run in the order they were supplied in rather than concurrently.</p> PARAMETER DESCRIPTION <code>check</code> <p>The first check callback to combine.</p> <p> TYPE: <code>tanjun.CheckSig[typing.Any]</code> </p> <code>*checks</code> <p>Additional check callbacks to combine.</p> <p> TYPE: <code>tanjun.CheckSig[typing.Any]</code> DEFAULT: <code>()</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.Context], collections.abc.Coroutine[typing.Any, typing.Any, bool]]</code> <p>A check which will pass if all of the provided check callbacks pass.</p>"},{"location":"reference/checks/#tanjun.checks.with_any_checks","title":"with_any_checks","text":"<pre><code>with_any_checks(check, /, *checks, error=None, error_message, follow_wrapped=False, halt_execution=False, suppress=(errors.CommandError, errors.HaltExecution))\n</code></pre> <p>Add a check which'll pass if any of the provided checks pass through a decorator call.</p> <p>This ensures that the callbacks are run in the order they were supplied in rather than concurrently.</p> PARAMETER DESCRIPTION <code>check</code> <p>The first check callback to combine.</p> <p> TYPE: <code>tanjun.CheckSig[typing.Any]</code> </p> <code>*checks</code> <p>Additional check callbacks to combine.</p> <p> TYPE: <code>tanjun.CheckSig[typing.Any]</code> DEFAULT: <code>()</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>This supports localisation and uses the check name <code>\"tanjun.any_check\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>suppress</code> <p>Tuple of the exceptions to suppress when a check fails.</p> <p> TYPE: <code>tuple[type[Exception], ...]</code> DEFAULT: <code>(errors.CommandError, errors.HaltExecution)</code> </p> RETURNS DESCRIPTION <code>collections.Callable[[tanjun.abc.ExecutableCommand], tanjun.abc.ExecutableCommand]</code> <p>A decorator which adds the generated check to a command.</p>"},{"location":"reference/checks/#tanjun.checks.with_author_permission_check","title":"with_author_permission_check","text":"<pre><code>with_author_permission_check(permissions, *, error=None, error_message=\"You don't have the permissions required to use this command\", follow_wrapped=False, halt_execution=False)\n</code></pre> <p>Only let a command run if the author has certain permissions in the current channel.</p> <p>Note</p> <p>This will only pass for commands in DMs if <code>permissions</code> is valid for a DM context (e.g. can't have any moderation permissions)</p> PARAMETER DESCRIPTION <code>permissions</code> <p>The permission(s) required for this command to run.</p> <p> TYPE: <code>typing.Union[hikari.Permissions, int]</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This should take 1 positional argument of type hikari.permissions.Permissions which represents the missing permissions required for this command to run.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[hikari.Permissions], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>Setting this to None will disable the error message allowing the command search to continue.</p> <p>This supports localisation and uses the check name <code>\"tanjun.AuthorPermissionCheck\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>\"You don't have the permissions required to use this command\"</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.ExecutableCommand], tanjun.abc.ExecutableCommand]</code> <p>A command decorator callback which adds the check.</p>"},{"location":"reference/checks/#tanjun.checks.with_check","title":"with_check","text":"<pre><code>with_check(check, /, *, follow_wrapped=False)\n</code></pre> <p>Add a generic check to a command.</p> PARAMETER DESCRIPTION <code>check</code> <p>The check to add to this command.</p> <p> TYPE: <code>tanjun.CheckSig[typing.Any]</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.ExecutableCommand], tanjun.abc.ExecutableCommand]</code> <p>A command decorator callback which adds the check.</p>"},{"location":"reference/checks/#tanjun.checks.with_dm_check","title":"with_dm_check","text":"<pre><code>with_dm_check(command=None, /, *, error=None, error_message='Command can only be used in DMs', follow_wrapped=False, halt_execution=False)\n</code></pre> <p>Only let a command run in a DM channel.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add this check to.</p> <p> TYPE: <code>tanjun.abc.ExecutableCommand | None</code> DEFAULT: <code>None</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>Setting this to None will disable the error message allowing the command search to continue.</p> <p>This supports localisation and uses the check name <code>\"tanjun.DmCheck\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>'Command can only be used in DMs'</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.ExecutableCommand</code> <p>The command this check was added to.</p>"},{"location":"reference/checks/#tanjun.checks.with_guild_check","title":"with_guild_check","text":"<pre><code>with_guild_check(command=None, /, *, error=None, error_message='Command can only be used in guild channels', follow_wrapped=False, halt_execution=False)\n</code></pre> <p>Only let a command run in a guild channel.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add this check to.</p> <p> TYPE: <code>tanjun.abc.ExecutableCommand | None</code> DEFAULT: <code>None</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>Setting this to None will disable the error message allowing the command search to continue.</p> <p>This supports localisation and uses the check name <code>\"tanjun.GuildCheck\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>'Command can only be used in guild channels'</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.ExecutableCommanmd</code> <p>The command this check was added to.</p>"},{"location":"reference/checks/#tanjun.checks.with_nsfw_check","title":"with_nsfw_check","text":"<pre><code>with_nsfw_check(command=None, /, *, error=None, error_message='Command can only be used in NSFW channels', follow_wrapped=False, halt_execution=False)\n</code></pre> <p>Only let a command run in a channel that's marked as nsfw.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add this check to.</p> <p> TYPE: <code>tanjun.abc.ExecutableCommand | None</code> DEFAULT: <code>None</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>Setting this to None will disable the error message allowing the command search to continue.</p> <p>This supports localisation and uses the check name <code>\"tanjun.NsfwCheck\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>'Command can only be used in NSFW channels'</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.ExecutableCommand</code> <p>The command this check was added to.</p>"},{"location":"reference/checks/#tanjun.checks.with_own_permission_check","title":"with_own_permission_check","text":"<pre><code>with_own_permission_check(permissions, *, error=None, error_message=\"Bot doesn't have the permissions required to run this command\", follow_wrapped=False, halt_execution=False)\n</code></pre> <p>Only let a command run if we have certain permissions in the current channel.</p> <p>Note</p> <p>This will only pass for commands in DMs if <code>permissions</code> is valid for a DM context (e.g. can't have any moderation permissions)</p> PARAMETER DESCRIPTION <code>permissions</code> <p>The permission(s) required for this command to run.</p> <p> TYPE: <code>typing.Union[hikari.Permissions, int]</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This should take 1 positional argument of type hikari.permissions.Permissions which represents the missing permissions required for this command to run.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[hikari.Permissions], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>Setting this to None will disable the error message allowing the command search to continue.</p> <p>This supports localisation and uses the check name <code>\"tanjun.OwnPermissionCheck\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>\"Bot doesn't have the permissions required to run this command\"</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.ExecutableCommand], tanjun.abc.ExecutableCommand]</code> <p>A command decorator callback which adds the check.</p>"},{"location":"reference/checks/#tanjun.checks.with_owner_check","title":"with_owner_check","text":"<pre><code>with_owner_check(command=None, /, *, error=None, error_message='Only bot owners can use this command', follow_wrapped=False, halt_execution=False)\n</code></pre> <p>Only let a command run if it's being triggered by one of the bot's owners.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add this check to.</p> <p> TYPE: <code>tanjun.abc.ExecutableCommand | None</code> DEFAULT: <code>None</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>Setting this to None will disable the error message allowing the command search to continue.</p> <p>This supports localisation and uses the check name <code>\"tanjun.OwnerCheck\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>'Only bot owners can use this command'</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.ExecutableCommand</code> <p>The command this check was added to.</p>"},{"location":"reference/checks/#tanjun.checks.with_sfw_check","title":"with_sfw_check","text":"<pre><code>with_sfw_check(command=None, /, *, error=None, error_message='Command can only be used in SFW channels', follow_wrapped=False, halt_execution=False)\n</code></pre> <p>Only let a command run in a channel that's marked as sfw.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add this check to.</p> <p> TYPE: <code>tanjun.abc.ExecutableCommand | None</code> DEFAULT: <code>None</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>Setting this to None will disable the error message allowing the command search to continue.</p> <p>This supports localisation and uses the check name <code>\"tanjun.SfwCheck\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str], None]</code> DEFAULT: <code>'Command can only be used in SFW channels'</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>halt_execution</code> <p>Whether this check should raise tanjun.HaltExecution to end the execution search when it fails instead of returning False.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.ExecutableCommand</code> <p>The command this check was added to.</p>"},{"location":"reference/clients/","title":"tanjun.clients","text":"<p>Standard Tanjun client.</p>"},{"location":"reference/clients/#tanjun.clients.ClientCallbackNames","title":"ClientCallbackNames  <code>module-attribute</code>","text":"<pre><code>ClientCallbackNames = tanjun.ClientCallbackNames\n</code></pre> <p>Alias of tanjun.abc.ClientCallbackNames.</p>"},{"location":"reference/clients/#tanjun.clients.PrefixGetterSig","title":"PrefixGetterSig  <code>module-attribute</code>","text":"<pre><code>PrefixGetterSig = _PrefixGetterSig[Ellipsis]\n</code></pre> <p>Type hint of a callable used to get the prefix(es) for a specific guild.</p> <p>This represents the callback <code>async def (tanjun.abc.MessageContext, ...) -&gt; collections.Iterable[str]</code> where dependency injection is supported.</p>"},{"location":"reference/clients/#tanjun.clients.Client","title":"Client","text":"<p>         Bases: <code>tanjun.Client</code></p> <p>Tanjun's standard tanjun.abc.Client implementation.</p> <p>This implementation supports dependency injection for checks, command callbacks, prefix getters and event listeners. For more information on how this works see alluka.</p> <p>When manually managing the lifetime of the client the linked rest app or bot must always be started before the Tanjun client.</p> <p>Note</p> <p>By default this client includes a parser error handling hook which will by overwritten if you call tanjun.Client.set_hooks.</p>"},{"location":"reference/clients/#tanjun.clients.Client.checks","title":"checks  <code>property</code>","text":"<pre><code>checks: collections.Collection[tanjun.AnyCheckSig]\n</code></pre> <p>Collection of the level tanjun.abc.Context checks registered to this client.</p> <p>Note</p> <p>These may be taking advantage of the standard dependency injection.</p>"},{"location":"reference/clients/#tanjun.clients.Client.hooks","title":"hooks  <code>property</code>","text":"<pre><code>hooks: typing.Optional[tanjun.AnyHooks]\n</code></pre> <p>Top level tanjun.abc.AnyHooks set for this client.</p> <p>These are called during both message, menu and slash command execution.</p>"},{"location":"reference/clients/#tanjun.clients.Client.interaction_accepts","title":"interaction_accepts  <code>property</code>","text":"<pre><code>interaction_accepts: InteractionAcceptsEnum\n</code></pre> <p>The types of interactions this client is executing.</p>"},{"location":"reference/clients/#tanjun.clients.Client.is_human_only","title":"is_human_only  <code>property</code>","text":"<pre><code>is_human_only: bool\n</code></pre> <p>Whether this client is only executing for non-bot/webhook users messages.</p>"},{"location":"reference/clients/#tanjun.clients.Client.menu_hooks","title":"menu_hooks  <code>property</code>","text":"<pre><code>menu_hooks: typing.Optional[tanjun.MenuHooks]\n</code></pre> <p>Top level tanjun.abc.MenuHooks set for this client.</p> <p>These are only called during menu command execution.</p>"},{"location":"reference/clients/#tanjun.clients.Client.message_accepts","title":"message_accepts  <code>property</code>","text":"<pre><code>message_accepts: MessageAcceptsEnum\n</code></pre> <p>Type of message create events this command client accepts for execution.</p>"},{"location":"reference/clients/#tanjun.clients.Client.message_hooks","title":"message_hooks  <code>property</code>","text":"<pre><code>message_hooks: typing.Optional[tanjun.MessageHooks]\n</code></pre> <p>Top level tanjun.abc.MessageHooks set for this client.</p> <p>These are only called during message command execution.</p>"},{"location":"reference/clients/#tanjun.clients.Client.prefix_getter","title":"prefix_getter  <code>property</code>","text":"<pre><code>prefix_getter: typing.Optional[PrefixGetterSig]\n</code></pre> <p>Prefix getter method set for this client.</p> <p>For more information on this callback's signature see tanjun.clients.PrefixGetterSig.</p>"},{"location":"reference/clients/#tanjun.clients.Client.prefixes","title":"prefixes  <code>property</code>","text":"<pre><code>prefixes: collections.Collection[str]\n</code></pre> <p>Collection of the standard prefixes set for this client.</p>"},{"location":"reference/clients/#tanjun.clients.Client.slash_hooks","title":"slash_hooks  <code>property</code>","text":"<pre><code>slash_hooks: typing.Optional[tanjun.SlashHooks]\n</code></pre> <p>Top level tanjun.abc.SlashHooks set for this client.</p> <p>These are only called during slash command execution.</p>"},{"location":"reference/clients/#tanjun.clients.Client.__init__","title":"__init__","text":"<pre><code>__init__(rest, *, cache=None, events=None, server=None, shards=None, voice=None, event_managed=False, injector=None, mention_prefix=False, set_global_commands=False, declare_global_commands=False, command_ids=None, message_ids=None, user_ids=None, _stack_level=0)\n</code></pre> <p>Initialise a Tanjun client.</p> <p>Note</p> <p>For a quicker way to initiate this client around a standard bot aware client, see tanjun.Client.from_gateway_bot and tanjun.Client.from_rest_bot.</p> PARAMETER DESCRIPTION <code>rest</code> <p>The Hikari REST client this will use.</p> <p> TYPE: <code>hikari.api.RESTClient</code> </p> <code>cache</code> <p>The Hikari cache client this will use if applicable.</p> <p> TYPE: <code>typing.Optional[hikari.api.Cache]</code> DEFAULT: <code>None</code> </p> <code>events</code> <p>The Hikari event manager client this will use if applicable.</p> <p>This is necessary for message command dispatch and will also be necessary for interaction command dispatch if <code>server</code> isn't provided.</p> <p> TYPE: <code>typing.Optional[hikari.api.EventManager]</code> DEFAULT: <code>None</code> </p> <code>server</code> <p>The Hikari interaction server client this will use if applicable.</p> <p>This is used for interaction command dispatch if interaction events aren't being received from the event manager.</p> <p> TYPE: <code>typing.Optional[hikari.api.InteractionServer]</code> DEFAULT: <code>None</code> </p> <code>shards</code> <p>The Hikari shard aware client this will use if applicable.</p> <p> TYPE: <code>typing.Optional[hikari.ShardAware]</code> DEFAULT: <code>None</code> </p> <code>voice</code> <p>The Hikari voice component this will use if applicable.</p> <p> TYPE: <code>typing.Optional[hikari.api.VoiceComponent]</code> DEFAULT: <code>None</code> </p> <code>event_managed</code> <p>Whether or not this client is managed by the event manager.</p> <p>An event managed client will be automatically started and closed based on Hikari's lifetime events.</p> <p>This can only be passed as True if <code>events</code> is also provided.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>injector</code> <p>The alluka client this should use for dependency injection.</p> <p>If not provided then the client will initialise its own DI client.</p> <p> TYPE: <code>typing.Optional[alluka.abc.Client]</code> DEFAULT: <code>None</code> </p> <code>mention_prefix</code> <p>Whether or not mention prefixes should be automatically set when this client is first started.</p> <p>It should be noted that this only applies to message commands.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>declare_global_commands</code> <p>Whether or not to automatically set global slash commands when this client is first started.</p> <p>If one or more guild objects/IDs are passed here then the registered global commands will be set on the specified guild(s) at startup rather than globally.</p> <p>The endpoint this uses has a strict ratelimit which, as of writing, only allows for 2 requests per minute (with that ratelimit either being per-guild if targeting a specific guild otherwise globally).</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialGuild], hikari.SnowflakeishOr[hikari.PartialGuild], bool]</code> DEFAULT: <code>False</code> </p> <code>command_ids</code> <p>If provided, a mapping of top level command names to IDs of the existing commands to update.</p> <p>This will be used for all application commands but in cases where commands have overlapping names, <code>message_ids</code> and <code>user_ids</code> will take priority over this for their relevant command type.</p> <p>This field is complementary to <code>declare_global_commands</code> and, while it isn't necessarily required, this will in some situations help avoid permissions which were previously set for a command from being lost after a rename.</p> <p>This currently isn't supported when multiple guild IDs are passed for <code>declare_global_commands</code>.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p> <code>message_ids</code> <p>If provided, a mapping of message context menu command names to the IDs of existing commands to update.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p> <code>user_ids</code> <p>If provided, a mapping of user context menu command names to the IDs of existing commands to update.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises for the following reasons:</p> <ul> <li>If <code>event_managed</code> is <code>True</code> when <code>event_manager</code> is <code>None</code>.</li> <li>If <code>command_ids</code> is passed when multiple guild ids are provided for <code>declare_global_commands</code>.</li> <li>If <code>command_ids</code> is passed when <code>declare_global_commands</code> is <code>False</code>.</li> </ul>"},{"location":"reference/clients/#tanjun.clients.Client.add_check","title":"add_check","text":"<pre><code>add_check(*checks)\n</code></pre> <p>Add a generic check to this client.</p> <p>This will be applied to both message and slash command execution.</p> PARAMETER DESCRIPTION <code>*checks</code> <p>The checks to add. These may be either synchronous or asynchronous and must take one positional argument of type tanjun.abc.Context with dependency injection being supported for its keyword arguments.</p> <p> TYPE: <code>tanjun.AnyCheckSig</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/clients/#tanjun.clients.Client.add_component","title":"add_component","text":"<pre><code>add_component(component)\n</code></pre> <p>Add a component to this client.</p> PARAMETER DESCRIPTION <code>component</code> <p>The component to move to this client.</p> <p> TYPE: <code>tanjun.Component</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to allow chained calls.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the component's name is already registered.</p>"},{"location":"reference/clients/#tanjun.clients.Client.add_prefix","title":"add_prefix","text":"<pre><code>add_prefix(prefixes)\n</code></pre> <p>Add a prefix used to filter message command calls.</p> <p>This will be matched against the first character(s) in a message's content to determine whether the message command search stage of execution should be initiated.</p> PARAMETER DESCRIPTION <code>prefixes</code> <p>Either a single string or an iterable of strings to be used as prefixes.</p> <p> TYPE: <code>typing.Union[collections.Iterable[str], str]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/clients/#tanjun.clients.Client.close","title":"close  <code>async</code>","text":"<pre><code>close(*, deregister_listeners=True)\n</code></pre> <p>Close the client.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the client isn't running.</p>"},{"location":"reference/clients/#tanjun.clients.Client.fetch_rest_application_id","title":"fetch_rest_application_id  <code>async</code>","text":"<pre><code>fetch_rest_application_id()\n</code></pre> <p>Fetch the ID of the application this client is linked to.</p> RETURNS DESCRIPTION <code>hikari.Snowflake</code> <p>The application ID of the application this client is linked to.</p>"},{"location":"reference/clients/#tanjun.clients.Client.from_gateway_bot","title":"from_gateway_bot  <code>classmethod</code>","text":"<pre><code>from_gateway_bot(bot, /, *, event_managed=True, injector=None, mention_prefix=False, declare_global_commands=False, set_global_commands=False, command_ids=None, message_ids=None, user_ids=None)\n</code></pre> <p>Build a tanjun.Client from a gateway bot.</p> <p>Note</p> <p>This defaults the client to human only mode and sets type dependency injectors for the hikari traits present in <code>bot</code>.</p> PARAMETER DESCRIPTION <code>bot</code> <p>The bot client to build from.</p> <p>This will be used to infer the relevant Hikari clients to use.</p> <p> TYPE: <code>hikari.traits.ShardAware</code> </p> <code>event_managed</code> <p>Whether or not this client is managed by the event manager.</p> <p>An event managed client will be automatically started and closed based on Hikari's lifetime events.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>injector</code> <p>The alluka client this should use for dependency injection.</p> <p>If not provided then the client will initialise its own DI client.</p> <p> TYPE: <code>typing.Optional[alluka.abc.Client]</code> DEFAULT: <code>None</code> </p> <code>mention_prefix</code> <p>Whether or not mention prefixes should be automatically set when this client is first started.</p> <p>It should be noted that this only applies to message commands.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>declare_global_commands</code> <p>Whether or not to automatically set global slash commands when this client is first started.</p> <p>If one or more guild objects/IDs are passed here then the registered global commands will be set on the specified guild(s) at startup rather than globally.</p> <p>The endpoint this uses has a strict ratelimit which, as of writing, only allows for 2 requests per minute (with that ratelimit either being per-guild if targeting a specific guild otherwise globally).</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialGuild], hikari.SnowflakeishOr[hikari.PartialGuild], bool]</code> DEFAULT: <code>False</code> </p> <code>command_ids</code> <p>If provided, a mapping of top level command names to IDs of the commands to update.</p> <p>This field is complementary to <code>declare_global_commands</code> and, while it isn't necessarily required, this will in some situations help avoid permissions which were previously set for a command from being lost after a rename.</p> <p>This currently isn't supported when multiple guild IDs are passed for <code>declare_global_commands</code>.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p> <code>message_ids</code> <p>If provided, a mapping of message context menu command names to the IDs of existing commands to update.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p> <code>user_ids</code> <p>If provided, a mapping of user context menu command names to the IDs of existing commands to update.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/clients/#tanjun.clients.Client.from_rest_bot","title":"from_rest_bot  <code>classmethod</code>","text":"<pre><code>from_rest_bot(bot, /, *, bot_managed=False, declare_global_commands=False, injector=None, set_global_commands=False, command_ids=None, message_ids=None, user_ids=None)\n</code></pre> <p>Build a tanjun.Client from a hikari.traits.RESTBotAware instance.</p> <p>Note</p> <p>This sets type dependency injectors for the hikari traits present in <code>bot</code> (including hikari.traits.RESTBotAware).</p> PARAMETER DESCRIPTION <code>bot</code> <p>The bot client to build from.</p> <p> TYPE: <code>hikari.RESTBotAware</code> </p> <code>declare_global_commands</code> <p>Whether or not to automatically set global slash commands when this client is first started.</p> <p>If one or more guild objects/IDs are passed here then the registered global commands will be set on the specified guild(s) at startup rather than globally.</p> <p>The endpoint this uses has a strict ratelimit which, as of writing, only allows for 2 requests per minute (with that ratelimit either being per-guild if targeting a specific guild otherwise globally).</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialGuild], hikari.SnowflakeishOr[hikari.PartialGuild], bool]</code> DEFAULT: <code>False</code> </p> <code>bot_managed</code> <p>Whether the client should be managed by the REST bot.</p> <p>A REST bot managed client will be automatically started and closed based on the REST bot's startup and shutdown callbacks.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>injector</code> <p>The alluka client this should use for dependency injection.</p> <p>If not provided then the client will initialise its own DI client.</p> <p> TYPE: <code>typing.Optional[alluka.abc.Client]</code> DEFAULT: <code>None</code> </p> <code>command_ids</code> <p>If provided, a mapping of top level command names to IDs of the existing commands to update.</p> <p>This will be used for all application commands but in cases where commands have overlapping names, <code>message_ids</code> and <code>user_ids</code> will take priority over this for their relevant command type.</p> <p>This field is complementary to <code>declare_global_commands</code> and, while it isn't necessarily required, this will in some situations help avoid permissions which were previously set for a command from being lost after a rename.</p> <p>This currently isn't supported when multiple guild IDs are passed for <code>declare_global_commands</code>.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p> <code>message_ids</code> <p>If provided, a mapping of message context menu command names to the IDs of existing commands to update.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p> <code>user_ids</code> <p>If provided, a mapping of user context menu command names to the IDs of existing commands to update.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, hikari.SnowflakeishOr[hikari.PartialCommand]]]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/clients/#tanjun.clients.Client.on_autocomplete_interaction_request","title":"on_autocomplete_interaction_request  <code>async</code>","text":"<pre><code>on_autocomplete_interaction_request(interaction)\n</code></pre> <p>Execute a command autocomplete based on received REST requests.</p> PARAMETER DESCRIPTION <code>interaction</code> <p>The interaction to execute autocomplete based on.</p> <p> TYPE: <code>hikari.AutocompleteInteraction</code> </p> RETURNS DESCRIPTION <code>hikari.api.InteractionAutocompleteBuilder</code> <p>The initial response to send back to Discord.</p>"},{"location":"reference/clients/#tanjun.clients.Client.on_command_interaction_request","title":"on_command_interaction_request  <code>async</code>","text":"<pre><code>on_command_interaction_request(interaction)\n</code></pre> <p>Execute an app command based on received REST requests.</p> PARAMETER DESCRIPTION <code>interaction</code> <p>The interaction to execute a command based on.</p> <p> TYPE: <code>hikari.CommandInteraction</code> </p> RETURNS DESCRIPTION <code>hikari.api.InteractionMessageBuilder | hikari.api.InteractionDeferredBuilder | hikari.api.InteractionModalBuilder</code> <p>The initial response to send back to Discord.</p>"},{"location":"reference/clients/#tanjun.clients.Client.on_gateway_autocomplete_create","title":"on_gateway_autocomplete_create  <code>async</code>","text":"<pre><code>on_gateway_autocomplete_create(interaction)\n</code></pre> <p>Execute command autocomplete based on a received gateway interaction create.</p> PARAMETER DESCRIPTION <code>interaction</code> <p>The interaction to execute a command based on.</p> <p> TYPE: <code>hikari.AutocompleteInteraction</code> </p>"},{"location":"reference/clients/#tanjun.clients.Client.on_gateway_command_create","title":"on_gateway_command_create  <code>async</code>","text":"<pre><code>on_gateway_command_create(interaction)\n</code></pre> <p>Execute an app command based on a received gateway interaction create.</p> PARAMETER DESCRIPTION <code>interaction</code> <p>The interaction to execute a command based on.</p> <p> TYPE: <code>hikari.CommandInteraction</code> </p>"},{"location":"reference/clients/#tanjun.clients.Client.on_interaction_create_event","title":"on_interaction_create_event  <code>async</code>","text":"<pre><code>on_interaction_create_event(event)\n</code></pre> <p>Handle a gateway interaction create event.</p> <p>This will execute both application command and autocomplete interactions.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to execute commands based on.</p> <p> TYPE: <code>hikari.InteractionCreateEvent</code> </p>"},{"location":"reference/clients/#tanjun.clients.Client.on_message_create_event","title":"on_message_create_event  <code>async</code>","text":"<pre><code>on_message_create_event(event)\n</code></pre> <p>Execute a message command based on a gateway event.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to handle.</p> <p> TYPE: <code>hikari.MessageCreateEvent</code> </p>"},{"location":"reference/clients/#tanjun.clients.Client.open","title":"open  <code>async</code>","text":"<pre><code>open(*, register_listeners=True)\n</code></pre> <p>Start the client.</p> <p>If <code>mention_prefix</code> was passed to tanjun.Client.__init__ or tanjun.Client.from_gateway_bot then this function may make a fetch request to Discord if it cannot get the current user from the cache.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the client is already active.</p>"},{"location":"reference/clients/#tanjun.clients.Client.remove_check","title":"remove_check","text":"<pre><code>remove_check(check)\n</code></pre> <p>Remove a check from the client.</p> PARAMETER DESCRIPTION <code>check</code> <p>The check to remove.</p> <p> TYPE: <code>tanjun.AnyCheckSig</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the check was not previously added.</p>"},{"location":"reference/clients/#tanjun.clients.Client.remove_prefix","title":"remove_prefix","text":"<pre><code>remove_prefix(prefix)\n</code></pre> <p>Remove a message content prefix from the client.</p> PARAMETER DESCRIPTION <code>prefix</code> <p>The prefix to remove.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the prefix is not registered with the client.</p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/clients/#tanjun.clients.Client.set_auto_defer_after","title":"set_auto_defer_after","text":"<pre><code>set_auto_defer_after(time)\n</code></pre> <p>Set when this client should automatically defer execution of commands.</p> <p>Warning</p> <p>If <code>time</code> is set to None then automatic deferrals will be disabled. This may lead to unexpected behaviour.</p> PARAMETER DESCRIPTION <code>time</code> <p>The time in seconds to defer interaction command responses after.</p> <p> TYPE: <code>typing.Optional[float]</code> </p>"},{"location":"reference/clients/#tanjun.clients.Client.set_autocomplete_ctx_maker","title":"set_autocomplete_ctx_maker","text":"<pre><code>set_autocomplete_ctx_maker(maker=context.AutocompleteContext)\n</code></pre> <p>Set the autocomplete context maker to use when creating contexts.</p> <p>Warning</p> <p>The caller must return an instance of tanjun.context.AutocompleteContext rather than just any implementation of the AutocompleteContext abc due to this client relying on implementation detail of tanjun.context.AutocompleteContext.</p> PARAMETER DESCRIPTION <code>maker</code> <p>The autocomplete context maker to use.</p> <p>This is a callback which should match the signature of tanjun.context.AutocompleteContext.init and return an instance of tanjun.context.AutocompleteContext.</p> <p> TYPE: <code>_AutocompleteContextMakerProto</code> DEFAULT: <code>context.AutocompleteContext</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This client to enable method chaining.</p>"},{"location":"reference/clients/#tanjun.clients.Client.set_case_sensitive","title":"set_case_sensitive","text":"<pre><code>set_case_sensitive(state)\n</code></pre> <p>Set whether this client defaults to being case sensitive for message commands.</p> PARAMETER DESCRIPTION <code>state</code> <p>Whether this client's message commands should be matched case-sensitively.</p> <p>This may be overridden by component specific configuration.</p> <p> TYPE: <code>bool</code> </p>"},{"location":"reference/clients/#tanjun.clients.Client.set_default_app_command_permissions","title":"set_default_app_command_permissions","text":"<pre><code>set_default_app_command_permissions(permissions)\n</code></pre> <p>Set the default member permissions needed for this client's commands.</p> <p>Warning</p> <p>This may be overridden by guild staff and does not apply to admins.</p> PARAMETER DESCRIPTION <code>permissions</code> <p>The default member permissions needed for this client's application commands.</p> <p>This may be overridden by tanjun.abc.AppCommand.default_member_permissions and tanjun.abc.Component.default_app_cmd_permissions; if this is left as None then this config will be inherited from the parent client.</p> <p> TYPE: <code>typing.Union[int, hikari.Permissions]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This client to enable method chaining.</p>"},{"location":"reference/clients/#tanjun.clients.Client.set_dms_enabled_for_app_cmds","title":"set_dms_enabled_for_app_cmds","text":"<pre><code>set_dms_enabled_for_app_cmds(state)\n</code></pre> <p>Set whether this clients's commands should be enabled in DMs.</p> PARAMETER DESCRIPTION <code>state</code> <p>Whether to enable this client's commands in DMs.</p> <p>This may be overridden by tanjun.abc.AppCommand.is_dm_enabled and tanjun.abc.Component.dms_enabled_for_app_cmds; if this is left as None then this config will be inherited from the parent client.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This client to enable method chaining.</p>"},{"location":"reference/clients/#tanjun.clients.Client.set_ephemeral_default","title":"set_ephemeral_default","text":"<pre><code>set_ephemeral_default(state)\n</code></pre> <p>Set whether slash contexts spawned by this client should default to ephemeral responses.</p> <p>This defaults to False if not explicitly set.</p> PARAMETER DESCRIPTION <code>state</code> <p>Whether slash command contexts executed in this client should should default to ephemeral.</p> <p>This will be overridden by any response calls which specify flags.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This client to enable method chaining.</p>"},{"location":"reference/clients/#tanjun.clients.Client.set_global_commands","title":"set_global_commands  <code>async</code>","text":"<pre><code>set_global_commands(*, application=None, guild=hikari.UNDEFINED, force=False)\n</code></pre> <p>Alias of tanjun.Client.declare_global_commands.</p> <p>deprecated</p> <p>Since v2.1.1a1; use tanjun.Client.declare_global_commands instead.</p>"},{"location":"reference/clients/#tanjun.clients.Client.set_hikari_trait_injectors","title":"set_hikari_trait_injectors","text":"<pre><code>set_hikari_trait_injectors(bot)\n</code></pre> <p>Set type based dependency injection based on the hikari traits found in <code>bot</code>.</p> <p>This is a short hand for calling tanjun.Client.add_type_dependency for all the hikari trait types <code>bot</code> is valid for with bot.</p> PARAMETER DESCRIPTION <code>bot</code> <p>The hikari client to set dependency injectors for.</p> <p> TYPE: <code>hikari.RESTAware</code> </p>"},{"location":"reference/clients/#tanjun.clients.Client.set_hooks","title":"set_hooks","text":"<pre><code>set_hooks(hooks)\n</code></pre> <p>Set the general command execution hooks for this client.</p> <p>The callbacks within this hook will be added to every slash and message command execution started by this client.</p> PARAMETER DESCRIPTION <code>hooks</code> <p>The general command execution hooks to set for this client.</p> <p>Passing None will remove all hooks.</p> <p> TYPE: <code>typing.Optional[tanjun.AnyHooks]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/clients/#tanjun.clients.Client.set_human_only","title":"set_human_only","text":"<pre><code>set_human_only(value=True)\n</code></pre> <p>Set whether or not message commands execution should be limited to \"human\" users.</p> <p>Note</p> <p>This doesn't apply to interaction commands as these can only be triggered by a \"human\" (normal user account).</p> PARAMETER DESCRIPTION <code>value</code> <p>Whether or not message commands execution should be limited to \"human\" users.</p> <p>Passing True here will prevent message commands from being executed based on webhook and bot messages.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"reference/clients/#tanjun.clients.Client.set_interaction_accepts","title":"set_interaction_accepts","text":"<pre><code>set_interaction_accepts(accepts)\n</code></pre> <p>Set the kind of interactions this client should execute.</p> PARAMETER DESCRIPTION <code>accepts</code> <p>Bitfield of the interaction types this client should execute.</p> <p> TYPE: <code>InteractionAcceptsEnum</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If called while the client is running.</p>"},{"location":"reference/clients/#tanjun.clients.Client.set_interaction_not_found","title":"set_interaction_not_found","text":"<pre><code>set_interaction_not_found(message)\n</code></pre> <p>Set the response message for when an interaction command is not found.</p> <p>Warning</p> <p>Setting this to None may lead to unexpected behaviour (especially when the client is still set to auto-defer interactions) and should only be done if you know what you're doing.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message to respond with when an interaction command isn't found.</p> <p> TYPE: <code>typing.Optional[str]</code> </p>"},{"location":"reference/clients/#tanjun.clients.Client.set_menu_ctx_maker","title":"set_menu_ctx_maker","text":"<pre><code>set_menu_ctx_maker(maker=context.MenuContext)\n</code></pre> <p>Set the autocomplete context maker to use when creating contexts.</p> <p>Warning</p> <p>The caller must return an instance of tanjun.context.MenuContext rather than just any implementation of the MenuContext abc due to this client relying on implementation detail of tanjun.context.MenuContext.</p> PARAMETER DESCRIPTION <code>maker</code> <p>The autocomplete context maker to use.</p> <p>This is a callback which should match the signature of tanjun.context.MenuContext.init and return an instance of tanjun.context.MenuContext.</p> <p> TYPE: <code>_MenuContextMakerProto</code> DEFAULT: <code>context.MenuContext</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This client to enable method chaining.</p>"},{"location":"reference/clients/#tanjun.clients.Client.set_menu_hooks","title":"set_menu_hooks","text":"<pre><code>set_menu_hooks(hooks)\n</code></pre> <p>Set the menu command execution hooks for this client.</p> <p>The callbacks within this hook will be added to every menu command execution started by this client.</p> PARAMETER DESCRIPTION <code>hooks</code> <p>The menu context specific command execution hooks to set for this client.</p> <p>Passing None will remove the hooks.</p> <p> TYPE: <code>typing.Optional[tanjun.MenuHooks]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/clients/#tanjun.clients.Client.set_menu_not_found","title":"set_menu_not_found","text":"<pre><code>set_menu_not_found(message)\n</code></pre> <p>Set the response message for when a menu command is not found.</p> <p>Warning</p> <p>Setting this to None may lead to unexpected behaviour (especially when the client is still set to auto-defer interactions) and should only be done if you know what you're doing.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message to respond with when a menu command isn't found.</p> <p> TYPE: <code>typing.Optional[str]</code> </p>"},{"location":"reference/clients/#tanjun.clients.Client.set_message_accepts","title":"set_message_accepts","text":"<pre><code>set_message_accepts(accepts)\n</code></pre> <p>Set the kind of messages commands should be executed based on.</p> PARAMETER DESCRIPTION <code>accepts</code> <p>The type of messages commands should be executed based on.</p> <p> TYPE: <code>MessageAcceptsEnum</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If called while the client is running.</p> <code>ValueError</code> <p>If <code>accepts</code> is set to anything other than tanjun.clients.MessageAcceptsEnum.NONE when the client doesn't have a linked event manager.</p>"},{"location":"reference/clients/#tanjun.clients.Client.set_message_ctx_maker","title":"set_message_ctx_maker","text":"<pre><code>set_message_ctx_maker(maker=context.MessageContext)\n</code></pre> <p>Set the message context maker to use when creating context for a message.</p> <p>Warning</p> <p>The caller must return an instance of tanjun.context.MessageContext rather than just any implementation of the MessageContext abc due to this client relying on implementation detail of tanjun.context.MessageContext.</p> PARAMETER DESCRIPTION <code>maker</code> <p>The message context maker to use.</p> <p>This is a callback which should match the signature of tanjun.context.MessageContext.__init__ and return an instance of tanjun.context.MessageContext.</p> <p> TYPE: <code>_MessageContextMakerProto</code> DEFAULT: <code>context.MessageContext</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This client to enable method chaining.</p>"},{"location":"reference/clients/#tanjun.clients.Client.set_message_hooks","title":"set_message_hooks","text":"<pre><code>set_message_hooks(hooks)\n</code></pre> <p>Set the message command execution hooks for this client.</p> <p>The callbacks within this hook will be added to every message command execution started by this client.</p> PARAMETER DESCRIPTION <code>hooks</code> <p>The message context specific command execution hooks to set for this client.</p> <p>Passing None will remove all hooks.</p> <p> TYPE: <code>typing.Optional[tanjun.MessageHooks]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/clients/#tanjun.clients.Client.set_prefix_getter","title":"set_prefix_getter","text":"<pre><code>set_prefix_getter(getter)\n</code></pre> <p>Set the callback used to retrieve message prefixes set for the relevant guild.</p> PARAMETER DESCRIPTION <code>getter</code> <p>The callback which'll be used to retrieve prefixes for the guild a message context is from. If None is passed here then the callback will be unset.</p> <p>This should be an async callback which one argument of type tanjun.abc.MessageContext and returns an iterable of string prefixes. Dependency injection is supported for this callback's keyword arguments.</p> <p> TYPE: <code>typing.Optional[PrefixGetterSig]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/clients/#tanjun.clients.Client.set_slash_ctx_maker","title":"set_slash_ctx_maker","text":"<pre><code>set_slash_ctx_maker(maker=context.SlashContext)\n</code></pre> <p>Set the slash context maker to use when creating context for a slash command.</p> <p>Warning</p> <p>The caller must return an instance of tanjun.context.SlashContext rather than just any implementation of the SlashContext abc due to this client relying on implementation detail of tanjun.context.SlashContext.</p> PARAMETER DESCRIPTION <code>maker</code> <p>The slash context maker to use.</p> <p>This is a callback which should match the signature of tanjun.context.SlashContext.__init__ and return an instance of tanjun.context.SlashContext.</p> <p> TYPE: <code>_SlashContextMakerProto</code> DEFAULT: <code>context.SlashContext</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This client to enable method chaining.</p>"},{"location":"reference/clients/#tanjun.clients.Client.set_slash_hooks","title":"set_slash_hooks","text":"<pre><code>set_slash_hooks(hooks)\n</code></pre> <p>Set the slash command execution hooks for this client.</p> <p>The callbacks within this hook will be added to every slash command execution started by this client.</p> PARAMETER DESCRIPTION <code>hooks</code> <p>The slash context specific command execution hooks to set for this client.</p> <p>Passing None will remove the hooks.</p> <p> TYPE: <code>typing.Optional[tanjun.SlashHooks]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/clients/#tanjun.clients.Client.set_slash_not_found","title":"set_slash_not_found","text":"<pre><code>set_slash_not_found(message)\n</code></pre> <p>Set the response message for when a slash command is not found.</p> <p>Warning</p> <p>Setting this to None may lead to unexpected behaviour (especially when the client is still set to auto-defer interactions) and should only be done if you know what you're doing.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message to respond with when a slash command isn't found.</p> <p> TYPE: <code>typing.Optional[str]</code> </p>"},{"location":"reference/clients/#tanjun.clients.Client.with_check","title":"with_check","text":"<pre><code>with_check(check)\n</code></pre> <p>Add a check to this client through a decorator call.</p> PARAMETER DESCRIPTION <code>check</code> <p>The check to add. This may be either synchronous or asynchronous and must take one positional argument of type tanjun.abc.Context with dependency injection being supported for its keyword arguments.</p> <p> TYPE: <code>tanjun.abc.CheckSig</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.CheckSig</code> <p>The added check.</p>"},{"location":"reference/clients/#tanjun.clients.Client.with_prefix_getter","title":"with_prefix_getter","text":"<pre><code>with_prefix_getter(getter)\n</code></pre> <p>Set the prefix getter callback for this client through decorator call.</p> <p>Examples:</p> <pre><code>client = tanjun.Client.from_rest_bot(bot)\n\n@client.with_prefix_getter\nasync def prefix_getter(ctx: tanjun.abc.MessageContext) -&gt; collections.abc.Iterable[str]:\n    raise NotImplementedError\n</code></pre> PARAMETER DESCRIPTION <code>getter</code> <p>The callback which'll be  to retrieve prefixes for the guild a message event is from.</p> <p>This should be an async callback which one argument of type tanjun.abc.MessageContext and returns an iterable of string prefixes. Dependency injection is supported for this callback's keyword arguments.</p> <p> TYPE: <code>PrefixGetterSig</code> </p> RETURNS DESCRIPTION <code>PrefixGetterSig</code> <p>The registered callback.</p>"},{"location":"reference/clients/#tanjun.clients.InteractionAcceptsEnum","title":"InteractionAcceptsEnum","text":"<p>         Bases: <code>enum.IntFlag</code></p> <p>The possible configurations for which interaction this client should execute.</p>"},{"location":"reference/clients/#tanjun.clients.InteractionAcceptsEnum.ALL","title":"ALL  <code>class-attribute</code>","text":"<pre><code>ALL = AUTOCOMPLETE | COMMANDS\n</code></pre> <p>Execute all the interaction types Tanjun supports.</p>"},{"location":"reference/clients/#tanjun.clients.InteractionAcceptsEnum.AUTOCOMPLETE","title":"AUTOCOMPLETE  <code>class-attribute</code>","text":"<pre><code>AUTOCOMPLETE = enum.auto()\n</code></pre> <p>Execute autocomplete interactions.</p>"},{"location":"reference/clients/#tanjun.clients.InteractionAcceptsEnum.COMMANDS","title":"COMMANDS  <code>class-attribute</code>","text":"<pre><code>COMMANDS = enum.auto()\n</code></pre> <p>Execute command interactions.</p> <p>This includes slash command and context menu calls.</p>"},{"location":"reference/clients/#tanjun.clients.InteractionAcceptsEnum.NONE","title":"NONE  <code>class-attribute</code>","text":"<pre><code>NONE = 0\n</code></pre> <p>Set the client to execute no interactions.</p>"},{"location":"reference/clients/#tanjun.clients.MessageAcceptsEnum","title":"MessageAcceptsEnum","text":"<p>         Bases: <code>str</code>, <code>enum.Enum</code></p> <p>The possible configurations for which events tanjun.Client should execute commands based on.</p>"},{"location":"reference/clients/#tanjun.clients.MessageAcceptsEnum.ALL","title":"ALL  <code>class-attribute</code>","text":"<pre><code>ALL = 'ALL'\n</code></pre> <p>Set the client to execute commands based on both DM and guild message create events.</p>"},{"location":"reference/clients/#tanjun.clients.MessageAcceptsEnum.DM_ONLY","title":"DM_ONLY  <code>class-attribute</code>","text":"<pre><code>DM_ONLY = 'DM_ONLY'\n</code></pre> <p>Set the client to execute commands based only DM message create events.</p>"},{"location":"reference/clients/#tanjun.clients.MessageAcceptsEnum.GUILD_ONLY","title":"GUILD_ONLY  <code>class-attribute</code>","text":"<pre><code>GUILD_ONLY = 'GUILD_ONLY'\n</code></pre> <p>Set the client to execute commands based only guild message create events.</p>"},{"location":"reference/clients/#tanjun.clients.MessageAcceptsEnum.NONE","title":"NONE  <code>class-attribute</code>","text":"<pre><code>NONE = 'NONE'\n</code></pre> <p>Set the client to not execute commands based on message create events.</p>"},{"location":"reference/clients/#tanjun.clients.MessageAcceptsEnum.get_event_type","title":"get_event_type","text":"<pre><code>get_event_type()\n</code></pre> <p>Get the base event type this mode listens to.</p> RETURNS DESCRIPTION <code>type[hikari.events.MessageCreateEvent] | None</code> <p>The type object of the MessageCreateEvent class this mode will register a listener for.</p> <p>This will be None if this mode disables listening to message create events.</p>"},{"location":"reference/clients/#tanjun.clients.as_loader","title":"as_loader","text":"<pre><code>as_loader(callback=None, /, *, standard_impl=True)\n</code></pre> <p>Mark a callback as being used to load Tanjun components from a module.</p> <p>Note</p> <p>This is only necessary if you wish to use tanjun.Client.load_modules.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback used to load Tanjun components from a module.</p> <p>This should take one argument of type tanjun.Client (or tanjun.abc.Client if <code>standard_impl</code> is False), return nothing and will be expected to initiate and add utilities such as components to the provided client.</p> <p> TYPE: <code>typing.Union[collections.Callable[[tanjun.Client], None], collections.Callable[[Client], None], None]</code> DEFAULT: <code>None</code> </p> <code>standard_impl</code> <p>Whether this loader should only allow instances of tanjun.Client as opposed to tanjun.abc.Client.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.Client], None]]</code> <p>The decorated load callback.</p>"},{"location":"reference/clients/#tanjun.clients.as_unloader","title":"as_unloader","text":"<pre><code>as_unloader(callback=None, /, *, standard_impl=True)\n</code></pre> <p>Mark a callback as being used to unload a module's utilities from a client.</p> <p>Note</p> <p>This is the inverse of tanjun.as_loader and is only necessary if you wish to use the tanjun.Client.unload_modules or tanjun.Client.reload_modules.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback used to unload Tanjun components from a module.</p> <p>This should take one argument of type tanjun.Client (or tanjun.abc.Client if <code>standard_impl</code> is False), return nothing and will be expected to remove utilities such as components from the provided client.</p> <p> TYPE: <code>typing.Union[collections.Callable[[Client], None], collections.Callable[[tanjun.Client], None], None]</code> DEFAULT: <code>None</code> </p> <code>standard_impl</code> <p>Whether this unloader should only allow instances of tanjun.Client as opposed to tanjun.abc.Client.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.Client], None]]</code> <p>The decorated unload callback.</p>"},{"location":"reference/clients/#tanjun.clients.on_parser_error","title":"on_parser_error  <code>async</code>","text":"<pre><code>on_parser_error(ctx, error)\n</code></pre> <p>Handle message parser errors.</p> <p>This is the default message parser error hook included by tanjun.Client.</p>"},{"location":"reference/commands/","title":"tanjun.commands","text":"<p>Standard implementations of Tanjun's command objects.</p>"},{"location":"reference/commands/#tanjun.commands.menu","title":"tanjun.commands.menu","text":"<p>Menu command implementations.</p>"},{"location":"reference/commands/#tanjun.commands.menu.MenuCommand","title":"MenuCommand","text":"<p>         Bases: <code>base.PartialCommand[tanjun.MenuContext]</code>, <code>tanjun.MenuCommand[_AnyMenuCallbackSigT, _MenuTypeT]</code></p> <p>Base class used for the standard menu command implementations.</p>"},{"location":"reference/commands/#tanjun.commands.menu.MenuCommand.wrapped_command","title":"wrapped_command  <code>property</code>","text":"<pre><code>wrapped_command: typing.Optional[tanjun.ExecutableCommand[typing.Any]]\n</code></pre> <p>The command object this wraps, if any.</p>"},{"location":"reference/commands/#tanjun.commands.menu.MenuCommand.__init__","title":"__init__","text":"<pre><code>__init__(callback, type_, name, /, *, always_defer=False, default_member_permissions=None, default_to_ephemeral=None, dm_enabled=None, is_global=True, _wrapped_command=None)\n</code></pre> <p>Initialise a user or message menu command.</p> <p>Note</p> <p>Under the standard implementation, <code>is_global</code> is used to determine whether the command should be bulk set by tanjun.Client.declare_global_commands or when <code>declare_global_commands</code> is True</p> <p>Note</p> <p>If you want your first response to be ephemeral while using <code>always_defer</code>, you must set <code>default_to_ephemeral</code> to <code>True</code>.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback to execute when the command is invoked.</p> <p>This should be an asynchronous callback which takes one positional argument of type tanjun.abc.MenuContext, returns None and may use dependency injection to access other services.</p> <p> TYPE: <code>tanjun.abc.MenuCallbackSig</code> </p> <code>type_</code> <p>The type of menu command this is.</p> <p>Only hikari.commands.CommandType.USER and hikari.commands.CommandType.MESSAGE are valid here.</p> <p> TYPE: <code>hikari.commands.CommandType</code> </p> <code>name</code> <p>The command's name (supports localisation).</p> <p>This must be between 1 and 32 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>always_defer</code> <p>Whether the contexts this command is executed with should always be deferred before being passed to the command's callback.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>default_member_permissions</code> <p>Member permissions necessary to utilize this command by default.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Union[hikari.Permissions, int, None]</code> DEFAULT: <code>None</code> </p> <code>default_to_ephemeral</code> <p>Whether this command's responses should default to ephemeral unless flags are set to override this.</p> <p>If this is left as None then the default set on the parent command(s), component or client will be in effect.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>dm_enabled</code> <p>Whether this command is enabled in DMs with the bot.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>is_global</code> <p>Whether this command is a global command.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MenuCallbackSig], MenuCommand]</code> <p>The decorator callback used to make a tanjun.MenuCommand.</p> <p>This can either wrap a raw command callback or another callable command instance (e.g. tanjun.MenuCommand, tanjun.MessageCommand, tanjun.SlashCommand) and will manage loading the other command into a component when using tanjun.Component.load_from_scope.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the command name isn't in the length range of 1 to 32.</li> <li>If the command name has uppercase characters.</li> </ul>"},{"location":"reference/commands/#tanjun.commands.menu.MenuCommand.set_ephemeral_default","title":"set_ephemeral_default","text":"<pre><code>set_ephemeral_default(state)\n</code></pre> <p>Set whether this command's responses should default to ephemeral.</p> PARAMETER DESCRIPTION <code>state</code> <p>Whether this command's responses should default to ephemeral. This will be overridden by any response calls which specify flags.</p> <p>Setting this to None will let the default set on the parent command(s), component or client propagate and decide the ephemeral default for contexts used by this command.</p> <p> TYPE: <code>typing.Optional[bool]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This command to allow for chaining.</p>"},{"location":"reference/commands/#tanjun.commands.menu.as_message_menu","title":"as_message_menu","text":"<pre><code>as_message_menu(name, /, *, always_defer=False, default_member_permissions=None, default_to_ephemeral=None, dm_enabled=None, is_global=True)\n</code></pre> <p>Build a message tanjun.MenuCommand by decorating a function.</p> <p>Note</p> <p>Under the standard implementation, <code>is_global</code> is used to determine whether the command should be bulk set by tanjun.Client.declare_global_commands or when <code>declare_global_commands</code> is True</p> <p>Note</p> <p>If you want your first response to be ephemeral while using <code>always_defer</code>, you must set <code>default_to_ephemeral</code> to <code>True</code>.</p> <p>Examples:</p> <pre><code>@as_message_menu(\"message\")\nasync def message_command(self, ctx: tanjun.abc.MenuContext, message: hikari.Message) -&gt; None:\n    await ctx.respond(\n        embed=hikari.Embed(title=\"Message content\", description=message.content or \"N/A\")\n    )\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>The command's name (supports localisation).</p> <p>This must be between 1 and 32 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>always_defer</code> <p>Whether the contexts this command is executed with should always be deferred before being passed to the command's callback.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>default_member_permissions</code> <p>Member permissions necessary to utilize this command by default.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Union[hikari.Permissions, int, None]</code> DEFAULT: <code>None</code> </p> <code>default_to_ephemeral</code> <p>Whether this command's responses should default to ephemeral unless flags are set to override this.</p> <p>If this is left as None then the default set on the parent command(s), component or client will be in effect.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>dm_enabled</code> <p>Whether this command is enabled in DMs with the bot.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>is_global</code> <p>Whether this command is a global command.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MenuCallbackSig], MenuCommand]</code> <p>The decorator callback used to make a tanjun.MenuCommand.</p> <p>This can either wrap a raw command callback or another callable command instance (e.g. tanjun.MenuCommand, tanjun.MessageCommand, tanjun.SlashCommand) and will manage loading the other command into a component when using tanjun.Component.load_from_scope.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the command name isn't in the length range of 1 to 32.</li> <li>If the command name has uppercase characters.</li> </ul>"},{"location":"reference/commands/#tanjun.commands.menu.as_user_menu","title":"as_user_menu","text":"<pre><code>as_user_menu(name, /, *, always_defer=False, default_member_permissions=None, default_to_ephemeral=None, dm_enabled=None, is_global=True)\n</code></pre> <p>Build a user tanjun.MenuCommand by decorating a function.</p> <p>Note</p> <p>Under the standard implementation, <code>is_global</code> is used to determine whether the command should be bulk set by tanjun.Client.declare_global_commands or when <code>declare_global_commands</code> is True</p> <p>Note</p> <p>If you want your first response to be ephemeral while using <code>always_defer</code>, you must set <code>default_to_ephemeral</code> to <code>True</code>.</p> <p>Examples:</p> <pre><code>@as_user_menu(\"user\")\nasync def user_command(\n    self,\n    ctx: tanjun.abc.MenuContext,\n    user: hikari.User | hikari.InteractionMember,\n) -&gt; None:\n    await ctx.respond(f\"Hello {user}\")\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>The command's name (supports localisation).</p> <p>This must be between 1 and 32 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>always_defer</code> <p>Whether the contexts this command is executed with should always be deferred before being passed to the command's callback.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>default_member_permissions</code> <p>Member permissions necessary to utilize this command by default.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Union[hikari.Permissions, int, None]</code> DEFAULT: <code>None</code> </p> <code>default_to_ephemeral</code> <p>Whether this command's responses should default to ephemeral unless flags are set to override this.</p> <p>If this is left as None then the default set on the parent command(s), component or client will be in effect.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>dm_enabled</code> <p>Whether this command is enabled in DMs with the bot.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>is_global</code> <p>Whether this command is a global command.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MenuCallbackSig], MenuCommand]</code> <p>The decorator callback used to make a tanjun.MenuCommand.</p> <p>This can either wrap a raw command callback or another callable command instance (e.g. tanjun.MenuCommand, tanjun.MessageCommand, tanjun.SlashCommand) and will manage loading the other command into a component when using tanjun.Component.load_from_scope.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the command name isn't in the length range of 1 to 32.</li> <li>If the command name has uppercase characters.</li> </ul>"},{"location":"reference/commands/#tanjun.commands.message","title":"tanjun.commands.message","text":"<p>Message command implementations.</p>"},{"location":"reference/commands/#tanjun.commands.message.MessageCommand","title":"MessageCommand","text":"<p>         Bases: <code>base.PartialCommand[tanjun.MessageContext]</code>, <code>tanjun.MessageCommand[_MessageCallbackSigT]</code></p> <p>Standard implementation of a message command.</p>"},{"location":"reference/commands/#tanjun.commands.message.MessageCommand.wrapped_command","title":"wrapped_command  <code>property</code>","text":"<pre><code>wrapped_command: typing.Optional[tanjun.ExecutableCommand[typing.Any]]\n</code></pre> <p>The command object this wraps, if any.</p>"},{"location":"reference/commands/#tanjun.commands.message.MessageCommand.__init__","title":"__init__","text":"<pre><code>__init__(callback, name, /, *names, validate_arg_keys=True, _wrapped_command=None)\n</code></pre> <p>Initialise a message command.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback to execute when the command is invoked.</p> <p>This should be an asynchronous callback which takes one positional argument of type tanjun.abc.MessageContext, returns None and may use dependency injection to access other services.</p> <p> TYPE: <code>tanjun.abc.MessageCallbackSig</code> </p> <code>name</code> <p>The command name.</p> <p> TYPE: <code>str</code> </p> <code>*names</code> <p>Other names for the command.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>validate_arg_keys</code> <p>Whether to validate that option keys match the command callback's signature.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"reference/commands/#tanjun.commands.message.MessageCommandGroup","title":"MessageCommandGroup","text":"<p>         Bases: <code>MessageCommand[_MessageCallbackSigT]</code>, <code>tanjun.MessageCommandGroup[_MessageCallbackSigT]</code></p> <p>Standard implementation of a message command group.</p>"},{"location":"reference/commands/#tanjun.commands.message.MessageCommandGroup.__init__","title":"__init__","text":"<pre><code>__init__(callback, name, /, *names, strict=False, validate_arg_keys=True, _wrapped_command=None)\n</code></pre> <p>Initialise a message command group.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback to execute when the command is invoked.</p> <p>This should be an asynchronous callback which takes one positional argument of type tanjun.abc.MessageContext, returns None and may use dependency injection to access other services.</p> <p> TYPE: <code>tanjun.abc.MessageCallbackSig</code> </p> <code>name</code> <p>The command name.</p> <p> TYPE: <code>str</code> </p> <code>*names</code> <p>Other names for the command.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>strict</code> <p>Whether this command group should only allow commands without spaces in their names.</p> <p>This allows for a more optimised command search pattern to be used and enforces that command names are unique to a single command within the group.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>validate_arg_keys</code> <p>Whether to validate that option keys match the command callback's signature.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"reference/commands/#tanjun.commands.message.MessageCommandGroup.add_command","title":"add_command","text":"<pre><code>add_command(command)\n</code></pre> <p>Add a command to this group.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add.</p> <p> TYPE: <code>tanjun.MessageCommand[typing.Any]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The group instance to enable chained calls.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If one of the command's names is already registered in a strict command group.</p>"},{"location":"reference/commands/#tanjun.commands.message.MessageCommandGroup.as_sub_command","title":"as_sub_command","text":"<pre><code>as_sub_command(name, /, *names, validate_arg_keys=True)\n</code></pre> <p>Build a message command in this group from a decorated callback.</p> PARAMETER DESCRIPTION <code>name</code> <p>The command name.</p> <p> TYPE: <code>str</code> </p> <code>*names</code> <p>Other names for the command.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>validate_arg_keys</code> <p>Whether to validate that option keys match the command callback's signature.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MessageCallbackSig], MessageCommand]</code> <p>The decorator callback used to make a sub-command.</p> <p>This can either wrap a raw command callback or another callable command instance (e.g. tanjun.MenuCommand, tanjun.MessageCommand, tanjun.SlashCommand).</p>"},{"location":"reference/commands/#tanjun.commands.message.MessageCommandGroup.as_sub_group","title":"as_sub_group","text":"<pre><code>as_sub_group(name, /, *names, strict=False, validate_arg_keys=True)\n</code></pre> <p>Build a message command group in this group from a decorated callback.</p> PARAMETER DESCRIPTION <code>name</code> <p>The command name.</p> <p> TYPE: <code>str</code> </p> <code>*names</code> <p>Other names for the command.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>strict</code> <p>Whether this command group should only allow commands without spaces in their names.</p> <p>This allows for a more optimised command search pattern to be used and enforces that command names are unique to a single command within the group.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>validate_arg_keys</code> <p>Whether to validate that option keys match the command callback's signature.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MessageCallbackSig], MessageCommand]</code> <p>The decorator callback used to make a sub-command group.</p> <p>This can either wrap a raw command callback or another callable command instance (e.g. tanjun.MenuCommand, tanjun.MessageCommand, tanjun.SlashCommand).</p>"},{"location":"reference/commands/#tanjun.commands.message.as_message_command","title":"as_message_command","text":"<pre><code>as_message_command(name, /, *names, validate_arg_keys=True)\n</code></pre> <p>Build a message command from a decorated callback.</p> PARAMETER DESCRIPTION <code>name</code> <p>The command name.</p> <p> TYPE: <code>str</code> </p> <code>*names</code> <p>Other names for the command.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>validate_arg_keys</code> <p>Whether to validate that option keys match the command callback's signature.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MessageCallbackSig], MessageCommand]</code> <p>The decorator callback used to make a tanjun.MessageCommand.</p> <p>This can either wrap a raw command callback or another callable command instance (e.g. tanjun.MenuCommand, tanjun.MessageCommand, tanjun.SlashCommand) and will manage loading the other command into a component when using tanjun.Component.load_from_scope.</p>"},{"location":"reference/commands/#tanjun.commands.message.as_message_command_group","title":"as_message_command_group","text":"<pre><code>as_message_command_group(name, /, *names, strict=False, validate_arg_keys=True)\n</code></pre> <p>Build a message command group from a decorated callback.</p> PARAMETER DESCRIPTION <code>name</code> <p>The command name.</p> <p> TYPE: <code>str</code> </p> <code>*names</code> <p>Other names for the command.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>strict</code> <p>Whether this command group should only allow commands without spaces in their names.</p> <p>This allows for a more optimised command search pattern to be used and enforces that command names are unique to a single command within the group.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>validate_arg_keys</code> <p>Whether to validate that option keys match the command callback's signature.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MessageCallbackSig], MessageCommand]</code> <p>The decorator callback used to make a tanjun.MessageCommandGroup.</p> <p>This can either wrap a raw command callback or another callable command instance (e.g. tanjun.MenuCommand, tanjun.MessageCommand, tanjun.SlashCommand) and will manage loading the other command into a component when using tanjun.Component.load_from_scope.</p>"},{"location":"reference/commands/#tanjun.commands.slash","title":"tanjun.commands.slash","text":"<p>Slash command implementations.</p>"},{"location":"reference/commands/#tanjun.commands.slash.ConverterSig","title":"ConverterSig  <code>module-attribute</code>","text":"<pre><code>ConverterSig = _ConverterSig[_ConvertT, Ellipsis]\n</code></pre> <p>Type hint of a slash command option converter.</p> <p>This represents the signatures <code>def (int | float | str, ...) -&gt; Any</code> and <code>async def (int | float | str, ...) -&gt; None</code> where dependency injection is supported.</p>"},{"location":"reference/commands/#tanjun.commands.slash.UNDEFINED_DEFAULT","title":"UNDEFINED_DEFAULT  <code>module-attribute</code>","text":"<pre><code>UNDEFINED_DEFAULT = tanjun.NO_DEFAULT\n</code></pre> <p>Deprecated alias for <code>tanjun.abc.NO_DEFAULT</code>.</p>"},{"location":"reference/commands/#tanjun.commands.slash.BaseSlashCommand","title":"BaseSlashCommand","text":"<p>         Bases: <code>base.PartialCommand[tanjun.SlashContext]</code>, <code>tanjun.BaseSlashCommand</code></p> <p>Base class used for the standard slash command implementations.</p>"},{"location":"reference/commands/#tanjun.commands.slash.BaseSlashCommand.set_ephemeral_default","title":"set_ephemeral_default","text":"<pre><code>set_ephemeral_default(state)\n</code></pre> <p>Set whether this command's responses should default to ephemeral.</p> PARAMETER DESCRIPTION <code>state</code> <p>Whether this command's responses should default to ephemeral. This will be overridden by any response calls which specify flags.</p> <p>Setting this to None will let the default set on the parent command(s), component or client propagate and decide the ephemeral default for contexts used by this command.</p> <p> TYPE: <code>typing.Optional[bool]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This command to allow for chaining.</p>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommand","title":"SlashCommand","text":"<p>         Bases: <code>BaseSlashCommand</code>, <code>tanjun.SlashCommand[_SlashCallbackSigT]</code></p> <p>Standard implementation of a slash command.</p>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommand.wrapped_command","title":"wrapped_command  <code>property</code>","text":"<pre><code>wrapped_command: typing.Optional[tanjun.ExecutableCommand[typing.Any]]\n</code></pre> <p>The command object this wraps, if any.</p>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommand.__init__","title":"__init__","text":"<pre><code>__init__(callback, name, description, /, *, always_defer=False, default_member_permissions=None, default_to_ephemeral=None, dm_enabled=None, is_global=True, sort_options=True, validate_arg_keys=True, _wrapped_command=None)\n</code></pre> <p>Initialise a slash command.</p> <p>Note</p> <p>Under the standard implementation, <code>is_global</code> is used to determine whether the command should be bulk set by tanjun.Client.declare_global_commands or when <code>declare_global_commands</code> is True</p> <p>Warning</p> <p><code>default_member_permissions</code>, <code>dm_enabled</code> and <code>is_global</code> are ignored for commands within slash command groups.</p> <p>Note</p> <p>If you want your first response to be ephemeral while using <code>always_defer</code>, you must set <code>default_to_ephemeral</code> to <code>True</code>.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback to execute when the command is invoked.</p> <p>This should be an asynchronous callback which takes one positional argument of type tanjun.abc.SlashContext, returns <code>None</code> and may use dependency injection to access other services.</p> <p> TYPE: <code>tanjun.abc.SlashCallbackSig</code> </p> <code>name</code> <p>The command's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The command's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>always_defer</code> <p>Whether the contexts this command is executed with should always be deferred before being passed to the command's callback.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>default_member_permissions</code> <p>Member permissions necessary to utilize this command by default.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Union[hikari.Permissions, int, None]</code> DEFAULT: <code>None</code> </p> <code>default_to_ephemeral</code> <p>Whether this command's responses should default to ephemeral unless flags are set to override this.</p> <p>If this is left as None then the default set on the parent command(s), component or client will be in effect.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>dm_enabled</code> <p>Whether this command is enabled in DMs with the bot.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>is_global</code> <p>Whether this command is a global command.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>sort_options</code> <p>Whether this command should sort its set options based on whether they're required.</p> <p>If this is True then the options are re-sorted to meet the requirement from Discord that required command options be listed before optional ones.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>validate_arg_keys</code> <p>Whether to validate that option keys match the command callback's signature.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the command name doesn't fit Discord's requirements.</li> <li>If the command name has uppercase characters.</li> <li>If the description is over 100 characters long.</li> </ul>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommand.add_attachment_option","title":"add_attachment_option","text":"<pre><code>add_attachment_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None, pass_as_kwarg=True)\n</code></pre> <p>Add an attachment option to the slash command.</p> <p>Note</p> <p>This will result in options of type hikari.messages.Attachment.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The option's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>default</code> <p>The option's default value.</p> <p>If this is left as no default then this option will be required.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>key</code> <p>Name of the argument this option's value should be passed to.</p> <p>This defaults to the first name provided in <code>name</code> and is no-op if <code>pass_as_kwarg</code> is False.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>pass_as_kwarg</code> <p>Whether or not to pass this option as a keyword argument to the command callback.</p> <p>If False is passed here then <code>default</code> will only decide whether the option is required without the actual value being used and the <code>coverters</code> field will be ignored.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the option name doesn't fit Discord's requirements.</li> <li>If the option name has uppercase characters.</li> <li>If the option description is over 100 characters in length.</li> <li>If the command already has 25 options.</li> <li>If <code>name</code> isn't valid for this command's callback when <code>validate_arg_keys</code> is True.</li> </ul>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommand.add_bool_option","title":"add_bool_option","text":"<pre><code>add_bool_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None, pass_as_kwarg=True)\n</code></pre> <p>Add a boolean option to a slash command.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The option's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>default</code> <p>The option's default value.</p> <p>If this is left as no default then this option will be required.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>key</code> <p>Name of the argument this option's value should be passed to.</p> <p>This defaults to the first name provided in <code>name</code> and is no-op if <code>pass_as_kwarg</code> is False.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>pass_as_kwarg</code> <p>Whether or not to pass this option as a keyword argument to the command callback.</p> <p>If False is passed here then <code>default</code> will only decide whether the option is required without the actual value being used.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the option name doesn't fit Discord's requirements.</li> <li>If the option name has uppercase characters.</li> <li>If the option description is over 100 characters in length.</li> <li>If the command already has 25 options.</li> <li>If <code>name</code> isn't valid for this command's callback when <code>validate_arg_keys</code> is True.</li> </ul>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommand.add_channel_option","title":"add_channel_option","text":"<pre><code>add_channel_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None, types=None, pass_as_kwarg=True)\n</code></pre> <p>Add a channel option to a slash command.</p> <p>Note</p> <p>This will always result in hikari.interactions.base_interactions.InteractionChannel.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The option's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>default</code> <p>The option's default value.</p> <p>If this is left as no default then this option will be required.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>types</code> <p>A collection of the channel classes and types this option should accept.</p> <p>If left as None or empty then the option will allow all channel types.</p> <p> TYPE: <code>typing.Optional[collections.Collection[typing.Union[type[hikari.PartialChannel], int]]]</code> DEFAULT: <code>None</code> </p> <code>key</code> <p>Name of the argument this option's value should be passed to.</p> <p>This defaults to the first name provided in <code>name</code> and is no-op if <code>pass_as_kwarg</code> is False.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>pass_as_kwarg</code> <p>Whether or not to pass this option as a keyword argument to the command callback.</p> <p>If False is passed here then <code>default</code> will only decide whether the option is required without the actual value being used.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the option name doesn't fit Discord's requirements.</li> <li>If the option name has uppercase characters.</li> <li>If the option description is over 100 characters in length.</li> <li>If the command already has 25 options.</li> <li>If an invalid type is passed in <code>types</code>.</li> <li>If <code>name</code> isn't valid for this command's callback when <code>validate_arg_keys</code> is True.</li> </ul>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommand.add_float_option","title":"add_float_option","text":"<pre><code>add_float_option(name, description, /, *, always_float=True, autocomplete=None, choices=None, converters=(), default=tanjun.NO_DEFAULT, key=None, min_value=None, max_value=None, pass_as_kwarg=True, _stack_level=0)\n</code></pre> <p>Add a float option to a slash command.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The option's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>always_float</code> <p>If this is set to True then the value will always be converted to a float (this will happen before it's passed to converters).</p> <p>This masks behaviour from Discord where we will either be provided a float or int dependent on what the user provided.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>autocomplete</code> <p>The autocomplete callback for the option.</p> <p>More information on this callback's signature can be found at tanjun.abc.AutocompleteSig and the 2nd positional argument should be of type float.</p> <p> TYPE: <code>typing.Optional[tanjun.AutocompleteSig[float]]</code> DEFAULT: <code>None</code> </p> <code>choices</code> <p>The option's choices.</p> <p>This is a mapping of [option_name, option_value] where option_name should be a string of up to 100 characters and option_value should be a float.</p> <p> TYPE: <code>collections.abc.Mapping[str, float] | None</code> DEFAULT: <code>None</code> </p> <code>converters</code> <p>The option's converters.</p> <p>This may be either one or multiple converter callbacks used to convert the option's value to the final form. If no converters are provided then the raw value will be passed.</p> <p>Only the first converter to pass will be used.</p> <p> TYPE: <code>typing.Union[collections.Sequence[ConverterSig[float]], ConverterSig[float]]</code> DEFAULT: <code>()</code> </p> <code>default</code> <p>The option's default value.</p> <p>If this is left as no default then this option will be required.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>key</code> <p>Name of the argument this option's value should be passed to.</p> <p>This defaults to the first name provided in <code>name</code> and is no-op if <code>pass_as_kwarg</code> is False.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>min_value</code> <p>The option's (inclusive) minimum value.</p> <p> TYPE: <code>typing.Optional[float]</code> DEFAULT: <code>None</code> </p> <code>max_value</code> <p>The option's (inclusive) maximum value.</p> <p> TYPE: <code>typing.Optional[float]</code> DEFAULT: <code>None</code> </p> <code>pass_as_kwarg</code> <p>Whether or not to pass this option as a keyword argument to the command callback.</p> <p>If False is passed here then <code>default</code> will only decide whether the option is required without the actual value being used and the fields <code>coverters</code>, and <code>always_float</code> will be ignored.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the option name doesn't fit Discord's requirements.</li> <li>If the option name has uppercase characters.</li> <li>If the option description is over 100 characters in length.</li> <li>If the option has more than 25 choices.</li> <li>If the command already has 25 options.</li> <li>If <code>min_value</code> is greater than <code>max_value</code>.</li> <li>If <code>name</code> isn't valid for this command's callback when <code>validate_arg_keys</code> is True.</li> </ul>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommand.add_int_option","title":"add_int_option","text":"<pre><code>add_int_option(name, description, /, *, autocomplete=None, choices=None, converters=(), default=tanjun.NO_DEFAULT, key=None, min_value=None, max_value=None, pass_as_kwarg=True, _stack_level=0)\n</code></pre> <p>Add an integer option to the slash command.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The option's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>autocomplete</code> <p>The autocomplete callback for the option.</p> <p>More information on this callback's signature can be found at tanjun.abc.AutocompleteSig and the 2nd positional argument should be of type int.</p> <p> TYPE: <code>typing.Optional[tanjun.AutocompleteSig[int]]</code> DEFAULT: <code>None</code> </p> <code>choices</code> <p>The option's choices.</p> <p>This is a mapping of [option_name, option_value] where option_name should be a string of up to 100 characters and option_value should be an integer.</p> <p> TYPE: <code>collections.abc.Mapping[str, int] | None</code> DEFAULT: <code>None</code> </p> <code>converters</code> <p>The option's converters.</p> <p>This may be either one or multiple converter callbacks used to convert the option's value to the final form. If no converters are provided then the raw value will be passed.</p> <p>Only the first converter to pass will be used.</p> <p> TYPE: <code>typing.Union[collections.Sequence[ConverterSig[int]], ConverterSig[int]]</code> DEFAULT: <code>()</code> </p> <code>default</code> <p>The option's default value.</p> <p>If this is left as undefined then this option will be required.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>key</code> <p>Name of the argument this option's value should be passed to.</p> <p>This defaults to the first name provided in <code>name</code> and is no-op if <code>pass_as_kwarg</code> is False.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>min_value</code> <p>The option's (inclusive) minimum value.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>max_value</code> <p>The option's (inclusive) maximum value.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>pass_as_kwarg</code> <p>Whether or not to pass this option as a keyword argument to the command callback.</p> <p>If False is passed here then <code>default</code> will only decide whether the option is required without the actual value being used and the <code>coverters</code> field will be ignored.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the option name doesn't fit Discord's requirements.</li> <li>If the option name has uppercase characters.</li> <li>If the option description is over 100 characters in length.</li> <li>If the option has more than 25 choices.</li> <li>If the command already has 25 options.</li> <li>If <code>min_value</code> is greater than <code>max_value</code>.</li> <li>If <code>name</code> isn't valid for this command's callback when <code>validate_arg_keys</code> is True.</li> </ul>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommand.add_member_option","title":"add_member_option","text":"<pre><code>add_member_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None)\n</code></pre> <p>Add a member option to a slash command.</p> <p>Note</p> <p>This will always result in hikari.interactions.base_interactions.InteractionMember.</p> <p>Warning</p> <p>Unlike the other options, this is an artificial option which adds a restraint to the USER option type and therefore cannot have <code>pass_as_kwarg</code> set to False as this artificial constraint isn't present when its not being passed as a keyword argument.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The option's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>default</code> <p>The option's default value.</p> <p>If this is left as no default then this option will be required.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>key</code> <p>Name of the argument this option's value should be passed to.</p> <p>This defaults to the first name provided in <code>name</code> and is no-op if <code>pass_as_kwarg</code> is False.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the option name doesn't fit Discord's requirements.</li> <li>If the option name has uppercase characters.</li> <li>If the option description is over 100 characters in length.</li> <li>If the command already has 25 options.</li> <li>If <code>name</code> isn't valid for this command's callback when <code>validate_arg_keys</code> is True.</li> </ul>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommand.add_mentionable_option","title":"add_mentionable_option","text":"<pre><code>add_mentionable_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None, pass_as_kwarg=True)\n</code></pre> <p>Add a mentionable option to a slash command.</p> <p>Note</p> <p>This may target roles, guild members or users and results in <code>hikari.User | hikari.InteractionMember | hikari.Role</code>.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The option's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>default</code> <p>The option's default value.</p> <p>If this is left as no default then this option will be required.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>key</code> <p>Name of the argument this option's value should be passed to.</p> <p>This defaults to the first name provided in <code>name</code> and is no-op if <code>pass_as_kwarg</code> is False.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>pass_as_kwarg</code> <p>Whether or not to pass this option as a keyword argument to the command callback.</p> <p>If False is passed here then <code>default</code> will only decide whether the option is required without the actual value being used.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the option name doesn't fit Discord's requirements.</li> <li>If the option name has uppercase characters.</li> <li>If the option description is over 100 characters in length.</li> <li>If the command already has 25 options.</li> <li>If <code>name</code> isn't valid for this command's callback when <code>validate_arg_keys</code> is True.</li> </ul>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommand.add_role_option","title":"add_role_option","text":"<pre><code>add_role_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None, pass_as_kwarg=True)\n</code></pre> <p>Add a role option to a slash command.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The option's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>default</code> <p>The option's default value.</p> <p>If this is left as no default then this option will be required.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>key</code> <p>Name of the argument this option's value should be passed to.</p> <p>This defaults to the first name provided in <code>name</code> and is no-op if <code>pass_as_kwarg</code> is False.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>pass_as_kwarg</code> <p>Whether or not to pass this option as a keyword argument to the command callback.</p> <p>If False is passed here then <code>default</code> will only decide whether the option is required without the actual value being used.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the option name doesn't fit Discord's requirements.</li> <li>If the option name has uppercase characters.</li> <li>If the option description is over 100 characters in length.</li> <li>If the command already has 25 options.</li> <li>If <code>name</code> isn't valid for this command's callback when <code>validate_arg_keys</code> is True.</li> </ul>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommand.add_str_option","title":"add_str_option","text":"<pre><code>add_str_option(name, description, /, *, autocomplete=None, choices=None, converters=(), default=tanjun.NO_DEFAULT, key=None, min_length=None, max_length=None, pass_as_kwarg=True, _stack_level=0)\n</code></pre> <p>Add a string option to the slash command.</p> <p>Note</p> <p>As a shorthand, <code>choices</code> also supports passing a list of strings rather than a dict of names to values (each string will used as both the choice's name and value with the names being capitalised).</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The option's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>autocomplete</code> <p>The autocomplete callback for the option.</p> <p>More information on this callback's signature can be found at tanjun.abc.AutocompleteSig and the 2nd positional argument should be of type str.</p> <p> TYPE: <code>typing.Optional[tanjun.AutocompleteSig[str]]</code> DEFAULT: <code>None</code> </p> <code>choices</code> <p>The option's choices.</p> <p>This either a mapping of [option_name, option_value] where both option_name and option_value should be strings of up to 100 characters or a sequence of strings where the string will be used for both the choice's name and value.</p> <p>Passing a sequence of tuples here is deprecated.</p> <p> TYPE: <code>collections.abc.Mapping[str, str], collections.abc.Sequence[str] | None</code> DEFAULT: <code>None</code> </p> <code>converters</code> <p>The option's converters.</p> <p>This may be either one or multiple converter callbacks used to convert the option's value to the final form. If no converters are provided then the raw value will be passed.</p> <p>Only the first converter to pass will be used.</p> <p> TYPE: <code>typing.Union[collections.Sequence[ConverterSig[str]], ConverterSig[str]]</code> DEFAULT: <code>()</code> </p> <code>default</code> <p>The option's default value.</p> <p>If this is left as no default then this option will be required.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>key</code> <p>Name of the argument this option's value should be passed to.</p> <p>This defaults to the first name provided in <code>name</code> and is no-op if <code>pass_as_kwarg</code> is False.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>min_length</code> <p>The minimum length of this string.</p> <p>This must be greater than or equal to 0, and less than or equal to <code>max_length</code> and <code>6000</code>.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>max_length</code> <p>The maximum length of this string.</p> <p>This must be greater then or equal to <code>min_length</code> and 1, and less than or equal to <code>6000</code>.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>pass_as_kwarg</code> <p>Whether or not to pass this option as a keyword argument to the command callback.</p> <p>If False is passed here then <code>default</code> will only decide whether the option is required without the actual value being used and the <code>coverters</code> field will be ignored.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the option name doesn't fit Discord's requirements.</li> <li>If the option name has uppercase characters.</li> <li>If the option description is over 100 characters in length.</li> <li>If the option has more than 25 choices.</li> <li>If the command already has 25 options.</li> <li>If <code>name</code> isn't valid for this command's callback when <code>validate_arg_keys</code> is True.</li> <li>If <code>min_length</code> is greater than <code>max_length</code>.</li> <li>If <code>min_length</code> is less than <code>0</code> or greater than <code>6000</code>.</li> <li>If <code>max_length</code> is less than <code>1</code> or greater than <code>6000</code>.</li> </ul>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommand.add_user_option","title":"add_user_option","text":"<pre><code>add_user_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None, pass_as_kwarg=True)\n</code></pre> <p>Add a user option to a slash command.</p> <p>Note</p> <p>This may result in hikari.interactions.base_interactions.InteractionMember or hikari.users.User if the user isn't in the current guild or if this command was executed in a DM channel.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The option's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>default</code> <p>The option's default value.</p> <p>If this is left as no default then this option will be required.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>key</code> <p>Name of the argument this option's value should be passed to.</p> <p>This defaults to the first name provided in <code>name</code> and is no-op if <code>pass_as_kwarg</code> is False.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>pass_as_kwarg</code> <p>Whether or not to pass this option as a keyword argument to the command callback.</p> <p>If False is passed here then <code>default</code> will only decide whether the option is required without the actual value being used.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the option name doesn't fit Discord's requirements.</li> <li>If the option name has uppercase characters.</li> <li>If the option description is over 100 characters in length.</li> <li>If the option has more than 25 choices.</li> <li>If the command already has 25 options.</li> <li>If <code>name</code> isn't valid for this command's callback when <code>validate_arg_keys</code> is True.</li> </ul>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommand.set_float_autocomplete","title":"set_float_autocomplete","text":"<pre><code>set_float_autocomplete(name, callback)\n</code></pre> <p>Set the autocomplete callback for a float option.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name.</p> <p>If localised names were provided for the option then this should be the default name.</p> <p> TYPE: <code>str</code> </p> <code>callback</code> <p>The autocomplete callback for the option.</p> <p>More information on this callback's signature can be found at tanjun.abc.AutocompleteSig and the 2nd positional argument should be of type float.</p> <p>Passing None here will remove the autocomplete callback for the option.</p> <p> TYPE: <code>typing.Optional[tanjun.AutocompleteSig[float]]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>KeyError</code> <p>Raises a key error if the option doesn't exist.</p> <code>TypeError</code> <p>Raises a type error if the option isn't of type <code>float</code>.</p>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommand.set_int_autocomplete","title":"set_int_autocomplete","text":"<pre><code>set_int_autocomplete(name, callback)\n</code></pre> <p>Set the autocomplete callback for a string option.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name.</p> <p>If localised names were provided for the option then this should be the default name.</p> <p> TYPE: <code>str</code> </p> <code>callback</code> <p>The autocomplete callback for the option.</p> <p>More information on this callback's signature can be found at tanjun.abc.AutocompleteSig and the 2nd positional argument should be of type str.</p> <p>Passing None here will remove the autocomplete callback for the option.</p> <p> TYPE: <code>tanjun.AutocompleteSig[int]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>KeyError</code> <p>Raises a key error if the option doesn't exist.</p> <code>TypeError</code> <p>Raises a type error if the option isn't of type <code>str</code>.</p>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommand.set_str_autocomplete","title":"set_str_autocomplete","text":"<pre><code>set_str_autocomplete(name, callback)\n</code></pre> <p>Set the autocomplete callback for a str option.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name.</p> <p>If localised names were provided for the option then this should be the default name.</p> <p> TYPE: <code>str</code> </p> <code>callback</code> <p>The autocomplete callback for the option.</p> <p>More information on this callback's signature can be found at tanjun.abc.AutocompleteSig and the 2nd positional argument should be of type str.</p> <p>Passing None here will remove the autocomplete callback for the option.</p> <p> TYPE: <code>tanjun.AutocompleteSig[str]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The command object for chaining.</p> RAISES DESCRIPTION <code>KeyError</code> <p>Raises a key error if the option doesn't exist.</p> <code>TypeError</code> <p>Raises a type error if the option isn't of type <code>str</code>.</p>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommand.with_float_autocomplete","title":"with_float_autocomplete","text":"<pre><code>with_float_autocomplete(name)\n</code></pre> <p>Set the autocomplete callback for a float option through a decorator call.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name.</p> <p>If localised names were provided for the option then this should be the default name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Collections.abc.Callable[[tanjun.abc.AutocompleteSig[float]], tanjun.abc.AutocompleteSig[float]]</code> <p>Decorator callback used to capture the autocomplete callback.</p> <p>More information on the autocomplete signature can be found at tanjun.abc.AutocompleteSig and the 2nd positional argument should be of type float.</p> RAISES DESCRIPTION <code>KeyError</code> <p>Raises a key error if the option doesn't exist.</p> <code>TypeError</code> <p>Raises a type error if the option isn't of type <code>float</code>.</p>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommand.with_int_autocomplete","title":"with_int_autocomplete","text":"<pre><code>with_int_autocomplete(name)\n</code></pre> <p>Set the autocomplete callback for a integer option through a decorator call.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name.</p> <p>If localised names were provided for the option then this should be the default name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Collections.abc.Callable[[tanjun.abc.AutocompleteSig[int]], tanjun.abc.AutocompleteSig[int]]</code> <p>Decorator callback used to capture the autocomplete callback.</p> <p>More information on the autocomplete signature can be found at tanjun.abc.AutocompleteSig and the 2nd positional argument should be of type int.</p> RAISES DESCRIPTION <code>KeyError</code> <p>Raises a key error if the option doesn't exist.</p> <code>TypeError</code> <p>Raises a type error if the option isn't of type <code>int</code>.</p>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommand.with_str_autocomplete","title":"with_str_autocomplete","text":"<pre><code>with_str_autocomplete(name)\n</code></pre> <p>Set the autocomplete callback for a string option through a decorator call.</p> PARAMETER DESCRIPTION <code>name</code> <p>The option's name.</p> <p>If localised names were provided for the option then this should be the default name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Collections.abc.Callable[[tanjun.abc.AutocompleteSig[str]], tanjun.abc.AutocompleteSig[str]]</code> <p>Decorator callback used to capture the autocomplete callback.</p> <p>More information on the autocomplete signature can be found at tanjun.abc.AutocompleteSig and the 2nd positional argument should be of type str.</p> RAISES DESCRIPTION <code>KeyError</code> <p>Raises a key error if the option doesn't exist.</p> <code>TypeError</code> <p>Raises a type error if the option isn't of type <code>str</code>.</p>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommandGroup","title":"SlashCommandGroup","text":"<p>         Bases: <code>BaseSlashCommand</code>, <code>tanjun.SlashCommandGroup</code></p> <p>Standard implementation of a slash command group.</p> <p>Note</p> <p>Unlike message command groups, slash command groups cannot be callable functions themselves.</p>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommandGroup.__init__","title":"__init__","text":"<pre><code>__init__(name, description, /, *, default_member_permissions=None, default_to_ephemeral=None, dm_enabled=None, is_global=True)\n</code></pre> <p>Initialise a slash command group.</p> <p>Note</p> <p>Under the standard implementation, <code>is_global</code> is used to determine whether the command should be bulk set by tanjun.Client.declare_global_commands or when <code>declare_global_commands</code> is True</p> <p>Warning</p> <p><code>default_member_permissions</code>, <code>dm_enabled</code> and <code>is_global</code> are ignored for commands groups within another slash command groups.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the command group (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The description of the command group (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>default_member_permissions</code> <p>Member permissions necessary to utilize this command by default.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Union[hikari.Permissions, int, None]</code> DEFAULT: <code>None</code> </p> <code>default_to_ephemeral</code> <p>Whether this command's responses should default to ephemeral unless flags are set to override this.</p> <p>If this is left as None then the default set on the parent command(s), component or client will be in effect.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>dm_enabled</code> <p>Whether this command is enabled in DMs with the bot.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>is_global</code> <p>Whether this command is a global command.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the command name doesn't fit Discord's requirements.</li> <li>If the command name has uppercase characters.</li> <li>If the description is over 100 characters long.</li> </ul>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommandGroup.add_command","title":"add_command","text":"<pre><code>add_command(command)\n</code></pre> <p>Add a slash command to this group.</p> <p>Warning</p> <p>Command groups are only supported within top-level groups.</p> PARAMETER DESCRIPTION <code>command</code> <p>Command to add to this group.</p> <p> TYPE: <code>tanjun.BaseSlashCommand</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Object of this group to enable chained calls.</p>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommandGroup.as_sub_command","title":"as_sub_command","text":"<pre><code>as_sub_command(name, description, /, *, always_defer=False, default_to_ephemeral=None, sort_options=True, validate_arg_keys=True)\n</code></pre> <p>Build a tanjun.SlashCommand in this command group by decorating a function.</p> <p>Note</p> <p>If you want your first response to be ephemeral while using <code>always_defer</code>, you must set <code>default_to_ephemeral</code> to <code>True</code>.</p> PARAMETER DESCRIPTION <code>name</code> <p>The command's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The command's description. This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>always_defer</code> <p>Whether the contexts this command is executed with should always be deferred before being passed to the command's callback.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>default_to_ephemeral</code> <p>Whether this command's responses should default to ephemeral unless flags are set to override this.</p> <p>If this is left as None then the default set on the parent command(s), component or client will be in effect.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>sort_options</code> <p>Whether this command should sort its set options based on whether they're required.</p> <p>If this is True then the options are re-sorted to meet the requirement from Discord that required command options be listed before optional ones.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>validate_arg_keys</code> <p>Whether to validate that option keys match the command callback's signature.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.SlashCallbackSig], SlashCommand]</code> <p>The decorator callback used to make a sub-command.</p> <p>This can either wrap a raw command callback or another callable command instance (e.g. tanjun.MenuCommand, tanjun.MessageCommand tanjun.SlashCommand).</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the command name doesn't fit Discord's requirements.</li> <li>If the command name has uppercase characters.</li> <li>If the description is over 100 characters long.</li> </ul>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommandGroup.make_sub_group","title":"make_sub_group","text":"<pre><code>make_sub_group(name, description, /, *, default_to_ephemeral=None)\n</code></pre> <p>Create a sub-command group in this group.</p> <p>Note</p> <p>Unlike message command groups, slash command groups cannot be callable functions themselves.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the command group (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The description of the command group.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>default_to_ephemeral</code> <p>Whether this command's responses should default to ephemeral unless flags are set to override this.</p> <p>If this is left as None then the default set on the parent command(s), component or client will be in effect.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>SlashCommandGroup</code> <p>The created sub-command group.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the command name doesn't fit Discord's requirements.</li> <li>If the command name has uppercase characters.</li> <li>If the description is over 100 characters long.</li> </ul>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommandGroup.remove_command","title":"remove_command","text":"<pre><code>remove_command(command)\n</code></pre> <p>Remove a command from this group.</p> PARAMETER DESCRIPTION <code>command</code> <p>Command to remove from this group.</p> <p> TYPE: <code>tanjun.BaseSlashCommand</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Object of this group to enable chained calls.</p>"},{"location":"reference/commands/#tanjun.commands.slash.SlashCommandGroup.with_command","title":"with_command","text":"<pre><code>with_command(command)\n</code></pre> <p>Add a slash command to this group through a decorator call.</p> PARAMETER DESCRIPTION <code>command</code> <p>Command to add to this group.</p> <p> TYPE: <code>tanjun.abc.BaseSlashCommand</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.BaseSlashCommand</code> <p>Command which was added to this group.</p>"},{"location":"reference/commands/#tanjun.commands.slash.as_slash_command","title":"as_slash_command","text":"<pre><code>as_slash_command(name, description, /, *, always_defer=False, default_member_permissions=None, default_to_ephemeral=None, dm_enabled=None, is_global=True, sort_options=True, validate_arg_keys=True)\n</code></pre> <p>Build a tanjun.SlashCommand by decorating a function.</p> <p>Note</p> <p>Under the standard implementation, <code>is_global</code> is used to determine whether the command should be bulk set by tanjun.Client.declare_global_commands or when <code>declare_global_commands</code> is True</p> <p>Warning</p> <p><code>default_member_permissions</code>, <code>dm_enabled</code> and <code>is_global</code> are ignored for commands within slash command groups.</p> <p>Note</p> <p>If you want your first response to be ephemeral while using <code>always_defer</code>, you must set <code>default_to_ephemeral</code> to <code>True</code>.</p> <p>Examples:</p> <pre><code>@as_slash_command(\"ping\", \"Get the bot's latency\")\nasync def ping_command(self, ctx: tanjun.abc.SlashContext) -&gt; None:\n    start_time = time.perf_counter()\n    await ctx.rest.fetch_my_user()\n    time_taken = (time.perf_counter() - start_time) * 1_000\n    await ctx.respond(f\"PONG\\n - REST: {time_taken:.0f}mss\")\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>The command's name (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The command's description (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>always_defer</code> <p>Whether the contexts this command is executed with should always be deferred before being passed to the command's callback.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>default_member_permissions</code> <p>Member permissions necessary to utilize this command by default.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Union[hikari.Permissions, int, None]</code> DEFAULT: <code>None</code> </p> <code>default_to_ephemeral</code> <p>Whether this command's responses should default to ephemeral unless flags are set to override this.</p> <p>If this is left as None then the default set on the parent command(s), component or client will be in effect.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>dm_enabled</code> <p>Whether this command is enabled in DMs with the bot.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>is_global</code> <p>Whether this command is a global command.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>sort_options</code> <p>Whether this command should sort its set options based on whether they're required.</p> <p>If this is True then the options are re-sorted to meet the requirement from Discord that required command options be listed before optional ones.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>validate_arg_keys</code> <p>Whether to validate that option keys match the command callback's signature.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.SlashCallbackSig], SlashCommand]</code> <p>The decorator callback used to make a tanjun.SlashCommand.</p> <p>This can either wrap a raw command callback or another callable command instance (e.g. tanjun.MenuCommand, tanjun.MessageCommand tanjun.SlashCommand) and will manage loading the other command into a component when using tanjun.Component.load_from_scope.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the command name doesn't fit Discord's requirements.</li> <li>If the command name has uppercase characters.</li> <li>If the description is over 100 characters long.</li> </ul>"},{"location":"reference/commands/#tanjun.commands.slash.slash_command_group","title":"slash_command_group","text":"<pre><code>slash_command_group(name, description, /, *, default_member_permissions=None, default_to_ephemeral=None, dm_enabled=None, is_global=True)\n</code></pre> <p>Create a slash command group.</p> <p>Note</p> <p>Unlike message command groups, slash command groups cannot be callable functions themselves.</p> <p>Warning</p> <p><code>default_member_permissions</code>, <code>dm_enabled</code> and <code>is_global</code> are ignored for command groups within other slash command groups.</p> <p>Note</p> <p>Under the standard implementation, <code>is_global</code> is used to determine whether the command should be bulk set by tanjun.Client.declare_global_commands or when <code>declare_global_commands</code> is True</p> <p>Examples:</p> <p>Sub-commands can be added to the created slash command object through the following decorator based approach:</p> <pre><code>help_group = tanjun.slash_command_group(\"help\", \"get help\")\n\n@tanjun.with_str_slash_option(\"command_name\", \"command name\")\n@help_group.as_sub_command(\"command\", \"Get help with a command\")\nasync def help_command_command(ctx: tanjun.abc.SlashContext, command_name: str) -&gt; None:\n    ...\n\n@help_group.as_sub_command(\"me\", \"help me\")\nasync def help_me_command(ctx: tanjun.abc.SlashContext) -&gt; None:\n    ...\n\ncomponent = tanjun.Component().add_slash_command(help_group)\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>The name of the command group (supports localisation).</p> <p>This must fit discord's requirements.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>description</code> <p>The description of the command group (supports localisation).</p> <p>This should be inclusively between 1-100 characters in length.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> </p> <code>default_member_permissions</code> <p>Member permissions necessary to utilize this command by default.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Union[hikari.Permissions, int, None]</code> DEFAULT: <code>None</code> </p> <code>default_to_ephemeral</code> <p>Whether this command's responses should default to ephemeral unless flags are set to override this.</p> <p>If this is left as None then the default set on the parent command(s), component or client will be in effect.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>dm_enabled</code> <p>Whether this command is enabled in DMs with the bot.</p> <p>If this is None then the configuration for the parent component or client will be used.</p> <p> TYPE: <code>typing.Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>is_global</code> <p>Whether this command is a global command.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>SlashCommandGroup</code> <p>The command group.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If the command name doesn't fit Discord's requirements.</li> <li>If the command name has uppercase characters.</li> <li>If the description is over 100 characters long.</li> </ul>"},{"location":"reference/commands/#tanjun.commands.slash.with_attachment_slash_option","title":"with_attachment_slash_option","text":"<pre><code>with_attachment_slash_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None, pass_as_kwarg=True)\n</code></pre> <p>Add an attachment option to a slash command.</p> <p>For more information on this function's parameters see tanjun.SlashCommand.add_attachment_option.</p> <p>Examples:</p> <pre><code>@with_attachment_slash_option(\"name\", \"A name.\")\n@as_slash_command(\"command\", \"A command\")\nasync def command(self, ctx: tanjun.abc.SlashContext, name: hikari.Attachment) -&gt; None:\n    ...\n</code></pre> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.SlashCommand], tanjun.SlashCommand]</code> <p>Decorator callback which adds the option to the command.</p>"},{"location":"reference/commands/#tanjun.commands.slash.with_bool_slash_option","title":"with_bool_slash_option","text":"<pre><code>with_bool_slash_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None, pass_as_kwarg=True)\n</code></pre> <p>Add a boolean option to a slash command.</p> <p>For information on this function's parameters see tanjun.SlashCommand.add_bool_option.</p> <p>Examples:</p> <pre><code>@with_bool_slash_option(\"flag\", \"Whether this flag should be enabled.\", default=False)\n@as_slash_command(\"command\", \"A command\")\nasync def command(self, ctx: tanjun.abc.SlashContext, flag: bool) -&gt; None:\n    ...\n</code></pre> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.SlashCommand], tanjun.SlashCommand]</code> <p>Decorator callback which adds the option to the command.</p>"},{"location":"reference/commands/#tanjun.commands.slash.with_channel_slash_option","title":"with_channel_slash_option","text":"<pre><code>with_channel_slash_option(name, description, /, *, types=None, default=tanjun.NO_DEFAULT, key=None, pass_as_kwarg=True)\n</code></pre> <p>Add a channel option to a slash command.</p> <p>For information on this function's parameters see tanjun.SlashCommand.add_channel_option.</p> <p>Note</p> <p>This will always result in hikari.interactions.base_interactions.InteractionChannel.</p> <p>Examples:</p> <pre><code>@with_channel_slash_option(\"channel\", \"channel to target.\")\n@as_slash_command(\"command\", \"A command\")\nasync def command(self, ctx: tanjun.abc.SlashContext, channel: hikari.InteractionChannel) -&gt; None:\n    ...\n</code></pre> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.SlashCommand], tanjun.SlashCommand]</code> <p>Decorator callback which adds the option to the command.</p>"},{"location":"reference/commands/#tanjun.commands.slash.with_float_slash_option","title":"with_float_slash_option","text":"<pre><code>with_float_slash_option(name, description, /, *, always_float=True, autocomplete=None, choices=None, converters=(), default=tanjun.NO_DEFAULT, key=None, min_value=None, max_value=None, pass_as_kwarg=True)\n</code></pre> <p>Add a float option to a slash command.</p> <p>For information on this function's parameters see tanjun.SlashCommand.add_float_option.</p> <p>Examples:</p> <pre><code>@with_float_slash_option(\"float_value\", \"Float value.\")\n@as_slash_command(\"command\", \"A command\")\nasync def command(self, ctx: tanjun.abc.SlashContext, float_value: float) -&gt; None:\n    ...\n</code></pre> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.SlashCommand], tanjun.SlashCommand]</code> <p>Decorator callback which adds the option to the command.</p>"},{"location":"reference/commands/#tanjun.commands.slash.with_int_slash_option","title":"with_int_slash_option","text":"<pre><code>with_int_slash_option(name, description, /, *, autocomplete=None, choices=None, converters=(), default=tanjun.NO_DEFAULT, key=None, min_value=None, max_value=None, pass_as_kwarg=True)\n</code></pre> <p>Add an integer option to a slash command.</p> <p>For information on this function's parameters see tanjun.SlashCommand.add_int_option.</p> <p>Examples:</p> <pre><code>@with_int_slash_option(\"int_value\", \"Int value.\")\n@as_slash_command(\"command\", \"A command\")\nasync def command(self, ctx: tanjun.abc.SlashContext, int_value: int) -&gt; None:\n    ...\n</code></pre> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.SlashCommand], tanjun.SlashCommand]</code> <p>Decorator callback which adds the option to the command.</p>"},{"location":"reference/commands/#tanjun.commands.slash.with_member_slash_option","title":"with_member_slash_option","text":"<pre><code>with_member_slash_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None)\n</code></pre> <p>Add a member option to a slash command.</p> <p>For information on this function's arguments see tanjun.SlashCommand.add_member_option.</p> <p>Note</p> <p>This will always result in hikari.interactions.base_interactions.InteractionMember.</p> <p>Examples:</p> <pre><code>@with_member_slash_option(\"member\", \"member to target.\")\n@as_slash_command(\"command\", \"A command\")\nasync def command(self, ctx: tanjun.abc.SlashContext, member: hikari.InteractionMember) -&gt; None:\n    ...\n</code></pre> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.SlashCommand], tanjun.SlashCommand]</code> <p>Decorator callback which adds the option to the command.</p>"},{"location":"reference/commands/#tanjun.commands.slash.with_mentionable_slash_option","title":"with_mentionable_slash_option","text":"<pre><code>with_mentionable_slash_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None, pass_as_kwarg=True)\n</code></pre> <p>Add a mentionable option to a slash command.</p> <p>For information on this function's arguments see tanjun.SlashCommand.add_mentionable_option.</p> <p>Note</p> <p>This may target roles, guild members or users and results in <code>hikari.User | hikari.InteractionMember | hikari.Role</code>.</p> <p>Examples:</p> <pre><code>@with_mentionable_slash_option(\"mentionable\", \"Mentionable entity to target.\")\n@as_slash_command(\"command\", \"A command\")\nasync def command(self, ctx: tanjun.abc.SlashContext, mentionable: [Role, InteractionMember, User]) -&gt; None:\n    ...\n</code></pre> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.SlashCommand], tanjun.SlashCommand]</code> <p>Decorator callback which adds the option to the command.</p>"},{"location":"reference/commands/#tanjun.commands.slash.with_role_slash_option","title":"with_role_slash_option","text":"<pre><code>with_role_slash_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None, pass_as_kwarg=True)\n</code></pre> <p>Add a role option to a slash command.</p> <p>For information on this function's parameters see tanjun.SlashCommand.add_role_option.</p> <p>Examples:</p> <pre><code>@with_role_slash_option(\"role\", \"Role to target.\")\n@as_slash_command(\"command\", \"A command\")\nasync def command(self, ctx: tanjun.abc.SlashContext, role: hikari.Role) -&gt; None:\n    ...\n</code></pre> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.SlashCommand], tanjun.SlashCommand]</code> <p>Decorator callback which adds the option to the command.</p>"},{"location":"reference/commands/#tanjun.commands.slash.with_str_slash_option","title":"with_str_slash_option","text":"<pre><code>with_str_slash_option(name, description, /, *, autocomplete=None, choices=None, converters=(), default=tanjun.NO_DEFAULT, key=None, min_length=None, max_length=None, pass_as_kwarg=True)\n</code></pre> <p>Add a string option to a slash command.</p> <p>For more information on this function's parameters see tanjun.commands.SlashCommand.add_str_option.</p> <p>Examples:</p> <pre><code>@with_str_slash_option(\"name\", \"A name.\")\n@as_slash_command(\"command\", \"A command\")\nasync def command(self, ctx: tanjun.abc.SlashContext, name: str) -&gt; None:\n    ...\n</code></pre> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.SlashCommand], tanjun.SlashCommand]</code> <p>Decorator callback which adds the option to the command.</p>"},{"location":"reference/commands/#tanjun.commands.slash.with_user_slash_option","title":"with_user_slash_option","text":"<pre><code>with_user_slash_option(name, description, /, *, default=tanjun.NO_DEFAULT, key=None, pass_as_kwarg=True)\n</code></pre> <p>Add a user option to a slash command.</p> <p>For information on this function's parameters see tanjun.SlashCommand.add_user_option.</p> <p>Note</p> <p>This may result in hikari.interactions.base_interactions.InteractionMember or hikari.users.User if the user isn't in the current guild or if this command was executed in a DM channel.</p> <p>Examples:</p> <pre><code>@with_user_slash_option(\"user\", \"user to target.\")\n@as_slash_command(\"command\", \"A command\")\nasync def command(self, ctx: tanjun.abc.SlashContext, user: Union[InteractionMember, User]) -&gt; None:\n    ...\n</code></pre> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.SlashCommand], tanjun.SlashCommand]</code> <p>Decorator callback which adds the option to the command.</p>"},{"location":"reference/components/","title":"tanjun.components","text":"<p>Standard implementation of Tanjun's \"components\" used to manage separate features within a client.</p>"},{"location":"reference/components/#tanjun.components.OnCallbackSig","title":"OnCallbackSig  <code>module-attribute</code>","text":"<pre><code>OnCallbackSig = collections.Callable[Ellipsis, typing.Optional[collections.Coroutine[typing.Any, typing.Any, None]]]\n</code></pre> <p>Type hint of a on_open or on_close component callback.</p> <p>This represents the signatures <code>def (...) -&gt; None</code> and <code>async def (...) -&gt; None</code> where dependency injection is supported.</p>"},{"location":"reference/components/#tanjun.components.AbstractComponentLoader","title":"AbstractComponentLoader","text":"<p>         Bases: <code>abc.ABC</code></p> <p>Abstract interface used for loading utility into a standard tanjun.Component.</p>"},{"location":"reference/components/#tanjun.components.AbstractComponentLoader.load_into_component","title":"load_into_component  <code>abstractmethod</code>","text":"<pre><code>load_into_component(component)\n</code></pre> <p>Load the object into the component.</p> PARAMETER DESCRIPTION <code>component</code> <p>The component this object should be loaded into.</p> <p> TYPE: <code>tanjun.Component</code> </p>"},{"location":"reference/components/#tanjun.components.Component","title":"Component","text":"<p>         Bases: <code>tanjun.Component</code></p> <p>Standard implementation of tanjun.abc.Component.</p> <p>This is a collcetion of commands (both message and slash), hooks and listener callbacks which can be added to a generic client.</p> <p>Note</p> <p>This implementation supports dependency injection for its checks, command callbacks and listeners when linked to a client which supports dependency injection.</p>"},{"location":"reference/components/#tanjun.components.Component.checks","title":"checks  <code>property</code>","text":"<pre><code>checks: collections.Collection[tanjun.AnyCheckSig]\n</code></pre> <p>Collection of the checks being run against every command execution in this component.</p>"},{"location":"reference/components/#tanjun.components.Component.hooks","title":"hooks  <code>property</code>","text":"<pre><code>hooks: typing.Optional[tanjun.AnyHooks]\n</code></pre> <p>The general command hooks set for this component, if any.</p>"},{"location":"reference/components/#tanjun.components.Component.menu_hooks","title":"menu_hooks  <code>property</code>","text":"<pre><code>menu_hooks: typing.Optional[tanjun.MenuHooks]\n</code></pre> <p>The menu command hooks set for this component, if any.</p>"},{"location":"reference/components/#tanjun.components.Component.message_hooks","title":"message_hooks  <code>property</code>","text":"<pre><code>message_hooks: typing.Optional[tanjun.MessageHooks]\n</code></pre> <p>The message command hooks set for this component, if any.</p>"},{"location":"reference/components/#tanjun.components.Component.schedules","title":"schedules  <code>property</code>","text":"<pre><code>schedules: collections.Collection[schedules_.AbstractSchedule]\n</code></pre> <p>Collection of the schedules registered to this component.</p>"},{"location":"reference/components/#tanjun.components.Component.slash_hooks","title":"slash_hooks  <code>property</code>","text":"<pre><code>slash_hooks: typing.Optional[tanjun.SlashHooks]\n</code></pre> <p>The slash command hooks set for this component, if any.</p>"},{"location":"reference/components/#tanjun.components.Component.__init__","title":"__init__","text":"<pre><code>__init__(*, name=None, strict=False)\n</code></pre> <p>Initialise a new component.</p> PARAMETER DESCRIPTION <code>name</code> <p>The component's identifier.</p> <p>If not provided then this will be a random string.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>strict</code> <p>Whether this component should use a stricter (more optimal) approach for message command search.</p> <p>When this is True, message command names will not be allowed to contain spaces and will have to be unique to one command within the component.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"reference/components/#tanjun.components.Component.add_check","title":"add_check","text":"<pre><code>add_check(*checks)\n</code></pre> <p>Add a command check to this component to be used for all its commands.</p> PARAMETER DESCRIPTION <code>*checks</code> <p>The checks to add.</p> <p> TYPE: <code>tanjun.AnyCheckSig</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This component to enable method chaining.</p>"},{"location":"reference/components/#tanjun.components.Component.add_client_callback","title":"add_client_callback","text":"<pre><code>add_client_callback(name, /, *callbacks)\n</code></pre> <p>Add a client callback.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name this callback is being registered to.</p> <p>This is case-insensitive.</p> <p> TYPE: <code>typing.Union[str, tanjun.ClientCallbackNames]</code> </p> <code>*callbacks</code> <p>The callbacks to register.</p> <p>These may be sync or async and must return None. The positional and keyword arguments a callback should expect depend on implementation detail around the <code>name</code> being subscribed to.</p> <p> TYPE: <code>tanjun.MetaEventSig</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/components/#tanjun.components.Component.add_command","title":"add_command","text":"<pre><code>add_command(command)\n</code></pre> <p>Add a command to this component.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add.</p> <p> TYPE: <code>tanjun.ExecutableCommand[typing.Any]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The current component to allow for chaining.</p>"},{"location":"reference/components/#tanjun.components.Component.add_message_command","title":"add_message_command","text":"<pre><code>add_message_command(command)\n</code></pre> <p>Add a message command to the component.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to add.</p> <p> TYPE: <code>tanjun.MessageCommand[typing.Any]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The component to allow method chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If one of the command's name is already registered in a strict component.</p>"},{"location":"reference/components/#tanjun.components.Component.add_on_close","title":"add_on_close","text":"<pre><code>add_on_close(*callbacks)\n</code></pre> <p>Add a close callback to this component.</p> <p>Note</p> <p>Unlike the closing and closed client callbacks, this is only called for the current component's lifetime and is guaranteed to be called regardless of when the component was added to a client.</p> PARAMETER DESCRIPTION <code>*callbacks</code> <p>The close callbacks to add to this component.</p> <p>This should take no positional arguments, return None and may take use injected dependencies.</p> <p> TYPE: <code>OnCallbackSig</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The component object to enable call chaining.</p>"},{"location":"reference/components/#tanjun.components.Component.add_on_open","title":"add_on_open","text":"<pre><code>add_on_open(*callbacks)\n</code></pre> <p>Add a open callback to this component.</p> <p>Note</p> <p>Unlike the starting and started client callbacks, this is only called for the current component's lifetime and is guaranteed to be called regardless of when the component was added to a client.</p> PARAMETER DESCRIPTION <code>*callbacks</code> <p>The open callbacks to add to this component.</p> <p>These should take no positional arguments, return None and may request injected dependencies.</p> <p> TYPE: <code>OnCallbackSig</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The component object to enable call chaining.</p>"},{"location":"reference/components/#tanjun.components.Component.add_schedule","title":"add_schedule","text":"<pre><code>add_schedule(schedule)\n</code></pre> <p>Add a schedule to the component.</p> PARAMETER DESCRIPTION <code>schedule</code> <p>The schedule to add.</p> <p> TYPE: <code>schedules_.AbstractSchedule</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The component itself for chaining.</p>"},{"location":"reference/components/#tanjun.components.Component.get_client_callbacks","title":"get_client_callbacks","text":"<pre><code>get_client_callbacks(name)\n</code></pre> <p>Get a collection of the callbacks registered for a specific name.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name to get the callbacks registered for.</p> <p>This is case-insensitive.</p> <p> TYPE: <code>typing.Union[str, tanjun.ClientCallbackNames]</code> </p> RETURNS DESCRIPTION <code>collections.abc.Collection[MetaEventSig]</code> <p>Collection of the callbacks for the provided name.</p>"},{"location":"reference/components/#tanjun.components.Component.load_from_scope","title":"load_from_scope","text":"<pre><code>load_from_scope(*, include_globals=False, scope=None)\n</code></pre> <p>Load entries such as top-level commands into the component from the calling scope.</p> <p>Note</p> <p>This will load schedules which support and commands AbstractComponentLoader (all standard implementations support this) and will ignore commands which are owned by command groups.</p> <p>Note</p> <p>This will detect entries from the calling scope which implement tanjun.components.AbstractComponentLoader unless <code>scope</code> is passed but this isn't possible in a stack-less python implementation; in stack-less environments the scope will have to be explicitly passed as <code>scope</code>.</p> PARAMETER DESCRIPTION <code>include_globals</code> <p>Whether to include global variables (along with local) while detecting from the calling scope.</p> <p>This cannot be True when <code>scope</code> is provided and will only ever be needed when the local scope is different from the global scope.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>scope</code> <p>The scope to detect entries which implement tanjun.components.AbstractComponentLoader from.</p> <p>This overrides the default usage of stackframe introspection.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, typing.Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The current component to allow for chaining.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If this is called in a python implementation which doesn't support stack frame inspection when <code>scope</code> is not provided.</p> <code>ValueError</code> <p>If <code>scope</code> is provided when <code>include_globals</code> is True.</p>"},{"location":"reference/components/#tanjun.components.Component.make_loader","title":"make_loader","text":"<pre><code>make_loader(*, copy=True)\n</code></pre> <p>Make a loader/unloader for this component.</p> <p>This enables loading, unloading and reloading of this component into a client by targeting the module using tanjun.Client.load_modules, tanjun.Client.unload_modules and tanjun.Client.reload_modules.</p> PARAMETER DESCRIPTION <code>copy</code> <p>Whether to copy the component before loading it into a client.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.ClientLoader</code> <p>The loader for this component.</p>"},{"location":"reference/components/#tanjun.components.Component.remove_check","title":"remove_check","text":"<pre><code>remove_check(check)\n</code></pre> <p>Remove a command check from this component.</p> PARAMETER DESCRIPTION <code>check</code> <p>The check to remove.</p> <p> TYPE: <code>tanjun.AnyCheckSig</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This component to enable method chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the check is not registered with this component.</p>"},{"location":"reference/components/#tanjun.components.Component.remove_client_callback","title":"remove_client_callback","text":"<pre><code>remove_client_callback(name, callback)\n</code></pre> <p>Remove a client callback.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name this callback is being registered to.</p> <p>This is case-insensitive.</p> <p> TYPE: <code>str</code> </p> <code>callback</code> <p>The callback to remove from the client's callbacks.</p> <p> TYPE: <code>tanjun.MetaEventSig</code> </p> RAISES DESCRIPTION <code>KeyError</code> <p>If the provided name isn't found.</p> <code>ValueError</code> <p>If the provided callback isn't found.</p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to enable chained calls.</p>"},{"location":"reference/components/#tanjun.components.Component.remove_command","title":"remove_command","text":"<pre><code>remove_command(command)\n</code></pre> <p>Remove a command from this component.</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to remove.</p> <p> TYPE: <code>tanjun.ExecutableCommand[typing.Any]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This component to enable method chaining.</p>"},{"location":"reference/components/#tanjun.components.Component.remove_schedule","title":"remove_schedule","text":"<pre><code>remove_schedule(schedule)\n</code></pre> <p>Remove a schedule from the component.</p> PARAMETER DESCRIPTION <code>schedule</code> <p>The schedule to remove</p> <p> TYPE: <code>schedules_.AbstractSchedule</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The component itself for chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the schedule isn't registered.</p>"},{"location":"reference/components/#tanjun.components.Component.set_case_sensitive","title":"set_case_sensitive","text":"<pre><code>set_case_sensitive(state)\n</code></pre> <p>Set whether this component defaults to being case sensitive for component.</p> PARAMETER DESCRIPTION <code>state</code> <p>Whether this component's message commands should be matched case-sensitively.</p> <p>If this is left as None then the client's case-sensitive setting will be used.</p> <p> TYPE: <code>typing.Optional[bool]</code> </p>"},{"location":"reference/components/#tanjun.components.Component.set_default_app_command_permissions","title":"set_default_app_command_permissions","text":"<pre><code>set_default_app_command_permissions(permissions)\n</code></pre> <p>Set the default member permissions needed for this component's commands.</p> <p>Warning</p> <p>This may be overridden by guild staff and does not apply to admins.</p> PARAMETER DESCRIPTION <code>permissions</code> <p>The default member permissions needed for this component's application commands.</p> <p>If this is left as None then this config will be inherited from the parent client.</p> <p>This may be overridden by tanjun.abc.AppCommand.default_member_permissions and if this is left as None then this config will be inherited from the parent client.</p> <p> TYPE: <code>typing.Union[int, hikari.Permissions, None]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This client to enable method chaining.</p>"},{"location":"reference/components/#tanjun.components.Component.set_dms_enabled_for_app_cmds","title":"set_dms_enabled_for_app_cmds","text":"<pre><code>set_dms_enabled_for_app_cmds(state)\n</code></pre> <p>Set whether this component's commands should be enabled in DMs.</p> PARAMETER DESCRIPTION <code>state</code> <p>Whether to enable this component's commands in DMs.</p> <p>This may be overridden by tanjun.abc.AppCommand.is_dm_enabled and if this is left as None then this config will be inherited from the parent client.</p> <p> TYPE: <code>typing.Optional[bool]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This client to enable method chaining.</p>"},{"location":"reference/components/#tanjun.components.Component.set_ephemeral_default","title":"set_ephemeral_default","text":"<pre><code>set_ephemeral_default(state)\n</code></pre> <p>Set whether slash contexts executed in this component should default to ephemeral responses.</p> PARAMETER DESCRIPTION <code>state</code> <p>Whether slash command contexts executed in this component should should default to ephemeral. This will be overridden by any response calls which specify flags.</p> <p>Setting this to None will let the default set on the parent client propagate and decide the ephemeral default behaviour.</p> <p> TYPE: <code>typing.Optional[bool]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This component to enable method chaining.</p>"},{"location":"reference/components/#tanjun.components.Component.set_hooks","title":"set_hooks","text":"<pre><code>set_hooks(hooks)\n</code></pre> <p>Set hooks to be called during the execution of all of this component's commands.</p> PARAMETER DESCRIPTION <code>hooks</code> <p>The command hooks to set.</p> <p> TYPE: <code>typing.Optional[tanjun.AnyHooks]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This component to enable method chaining.</p>"},{"location":"reference/components/#tanjun.components.Component.set_menu_hooks","title":"set_menu_hooks","text":"<pre><code>set_menu_hooks(hooks)\n</code></pre> <p>Set hooks to be called during the execution of this component's menu commands.</p> PARAMETER DESCRIPTION <code>hooks</code> <p>The menu command hooks to set.</p> <p> TYPE: <code>typing.Optional[tanjun.MenuHooks]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This component to enable method chaining.</p>"},{"location":"reference/components/#tanjun.components.Component.set_message_hooks","title":"set_message_hooks","text":"<pre><code>set_message_hooks(hooks)\n</code></pre> <p>Set hooks to be called during the execution of this component's message commands.</p> PARAMETER DESCRIPTION <code>hooks</code> <p>The message command hooks to set.</p> <p> TYPE: <code>typing.Optional[tanjun.MessageHooks]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This component to enable method chaining.</p>"},{"location":"reference/components/#tanjun.components.Component.set_slash_hooks","title":"set_slash_hooks","text":"<pre><code>set_slash_hooks(hooks)\n</code></pre> <p>Set hooks to be called during the execution of this component's slash commands.</p> PARAMETER DESCRIPTION <code>hooks</code> <p>The slash command hooks to set.</p> <p> TYPE: <code>typing.Optional[tanjun.SlashHooks]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This component to enable method chaining.</p>"},{"location":"reference/components/#tanjun.components.Component.with_check","title":"with_check","text":"<pre><code>with_check(check)\n</code></pre> <p>Add a general command check to this component through a decorator call.</p> PARAMETER DESCRIPTION <code>check</code> <p>The check to add.</p> <p> TYPE: <code>tanjun.abc.CheckSig</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.CheckSig</code> <p>The added check.</p>"},{"location":"reference/components/#tanjun.components.Component.with_client_callback","title":"with_client_callback","text":"<pre><code>with_client_callback(name)\n</code></pre> <p>Add a client callback through a decorator call.</p> <p>Examples:</p> <pre><code>client = tanjun.Client.from_rest_bot(bot)\n\n@client.with_client_callback(\"closed\")\nasync def on_close() -&gt; None:\n    raise NotImplementedError\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>The name this callback is being registered to.</p> <p>This is case-insensitive.</p> <p> TYPE: <code>typing.Union[str, tanjun.ClientCallbackNames]</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MetaEventSig], tanjun.abc.MetaEventSig]</code> <p>Decorator callback used to register the client callback.</p> <p>This may be sync or async and must return None. The positional and keyword arguments a callback should expect depend on implementation detail around the <code>name</code> being subscribed to.</p>"},{"location":"reference/components/#tanjun.components.Component.with_command","title":"with_command","text":"<pre><code>with_command(command=None, /, *, copy=False, follow_wrapped=False)\n</code></pre> <p>Add a command to this component through a decorator call.</p> <p>Examples:</p> <p>This may be used inconjunction with tanjun.as_slash_command and tanjun.as_message_command.</p> <pre><code>@component.with_command\n@tanjun.with_slash_str_option(\"option_name\", \"option description\")\n@tanjun.as_slash_command(\"command_name\", \"command description\")\nasync def slash_command(ctx: tanjun.abc.Context, arg: str) -&gt; None:\n    await ctx.respond(f\"Hi {arg}\")\n</code></pre> <pre><code>@component.with_command\n@tanjun.with_argument(\"argument_name\")\n@tanjun.as_message_command(\"command_name\")\nasync def message_command(ctx: tanjun.abc.Context, arg: str) -&gt; None:\n    await ctx.respond(f\"Hi {arg}\")\n</code></pre> PARAMETER DESCRIPTION <code>command</code> <p>The command to add to this component.</p> <p> TYPE: <code>typing.Optional[_CommandT]</code> DEFAULT: <code>None</code> </p> <code>copy</code> <p>Whether to copy the command before adding it to this component.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>follow_wrapped</code> <p>Whether to also add any commands <code>command</code> wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.ExecutableCommand</code> <p>The added command.</p>"},{"location":"reference/components/#tanjun.components.Component.with_on_close","title":"with_on_close","text":"<pre><code>with_on_close(callback)\n</code></pre> <p>Add a close callback to this component through a decorator call.</p> <p>Note</p> <p>Unlike the closing and closed client callbacks, this is only called for the current component's lifetime and is guaranteed to be called regardless of when the component was added to a client.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The close callback to add to this component.</p> <p>This should take no positional arguments, return None and may request injected dependencies.</p> <p> TYPE: <code>OnCallbackSig</code> </p> RETURNS DESCRIPTION <code>OnCallbackSig</code> <p>The added close callback.</p>"},{"location":"reference/components/#tanjun.components.Component.with_on_open","title":"with_on_open","text":"<pre><code>with_on_open(callback)\n</code></pre> <p>Add a open callback to this component through a decorator call.</p> <p>Note</p> <p>Unlike the starting and started client callbacks, this is only called for the current component's lifetime and is guaranteed to be called regardless of when the component was added to a client.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The open callback to add to this component.</p> <p>This should take no positional arguments, return None and may take use injected dependencies.</p> <p> TYPE: <code>OnCallbackSig</code> </p> RETURNS DESCRIPTION <code>OnCallbackSig</code> <p>The added open callback.</p>"},{"location":"reference/components/#tanjun.components.Component.with_schedule","title":"with_schedule","text":"<pre><code>with_schedule(schedule)\n</code></pre> <p>Add a schedule to the component through a decorator call.</p>"},{"location":"reference/components/#tanjun.components.Component.with_schedule--example","title":"Example","text":"<p>This may be used in conjunction with tanjun.as_interval or tanjun.as_time_schedule.</p> <pre><code>@component.with_schedule\n@tanjun.as_interval(60)\nasync def my_schedule():\n    print(\"I'm running every minute!\")\n</code></pre> PARAMETER DESCRIPTION <code>schedule</code> <p>The schedule to add.</p> <p> TYPE: <code>tanjun.schedules.AbstractSchedule</code> </p> RETURNS DESCRIPTION <code>tanjun.schedules.AbstractSchedule</code> <p>The added schedule.</p>"},{"location":"reference/context/","title":"tanjun.context","text":"<p>Standard implementations of Tanjun's context classes.</p>"},{"location":"reference/context/#tanjun.context.autocomplete","title":"tanjun.context.autocomplete","text":"<p>Autocomplete context implementation.</p>"},{"location":"reference/context/#tanjun.context.autocomplete.AutocompleteContext","title":"AutocompleteContext","text":"<p>         Bases: <code>alluka.BasicContext</code>, <code>tanjun.AutocompleteContext</code></p> <p>Standard implementation of an autocomplete context.</p>"},{"location":"reference/context/#tanjun.context.autocomplete.AutocompleteContext.__init__","title":"__init__","text":"<pre><code>__init__(client, interaction, *, future=None)\n</code></pre> <p>Initialise an autocomplete context.</p> PARAMETER DESCRIPTION <code>client</code> <p>The Tanjun client this context is bound to.</p> <p> TYPE: <code>tanjun.Client</code> </p> <code>interaction</code> <p>The autocomplete interaction this context is for.</p> <p> TYPE: <code>hikari.AutocompleteInteraction</code> </p> <code>future</code> <p>A future used to set the initial response if this is being called through the REST webhook flow.</p> <p> TYPE: <code>typing.Optional[asyncio.Future[hikari.api.InteractionAutocompleteBuilder]]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/context/#tanjun.context.menu","title":"tanjun.context.menu","text":"<p>Menu context implementation.</p>"},{"location":"reference/context/#tanjun.context.menu.MenuContext","title":"MenuContext","text":"<p>         Bases: <code>slash.AppCommandContext</code>, <code>tanjun.MenuContext</code></p> <p>Standard menu command execution context.</p>"},{"location":"reference/context/#tanjun.context.menu.MenuContext.__init__","title":"__init__","text":"<pre><code>__init__(client, interaction, register_task, *, default_to_ephemeral=False, future=None, on_not_found=None)\n</code></pre> <p>Initialise a menu command context.</p> PARAMETER DESCRIPTION <code>client</code> <p>The Tanjun client this context is bound to.</p> <p> TYPE: <code>tanjun.Client</code> </p> <code>interaction</code> <p>The command interaction this context is for.</p> <p> TYPE: <code>hikari.CommandInteraction</code> </p> <code>register_task</code> <p>Callback used to register long-running tasks spawned by this context.</p> <p> TYPE: <code>collections.Callable[[asyncio.Task[typing.Any]], None]</code> </p> <code>future</code> <p>A future used to set the initial response if this is being called through the REST webhook flow.</p> <p> TYPE: <code>typing.Optional[asyncio.Future[_ResponseTypeT]]</code> DEFAULT: <code>None</code> </p> <code>default_to_ephemeral</code> <p>Whether to default to ephemeral responses.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>on_not_found</code> <p>Callback used to indicate no matching command was found.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[tanjun.MenuContext], collections.Awaitable[None]]]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/context/#tanjun.context.message","title":"tanjun.context.message","text":"<p>Message command implementation.</p>"},{"location":"reference/context/#tanjun.context.message.MessageContext","title":"MessageContext","text":"<p>         Bases: <code>base.BaseContext</code>, <code>tanjun.MessageContext</code></p> <p>Standard implementation of a command context as used within Tanjun.</p>"},{"location":"reference/context/#tanjun.context.message.MessageContext.__init__","title":"__init__","text":"<pre><code>__init__(client, content, message, register_task, *, triggering_name='', triggering_prefix='')\n</code></pre> <p>Initialise a message command context.</p> PARAMETER DESCRIPTION <code>client</code> <p>The client to use for sending messages.</p> <p> TYPE: <code>tanjun.Client</code> </p> <code>content</code> <p>The content of the message (minus any matched prefix and name).</p> <p> TYPE: <code>str</code> </p> <code>message</code> <p>The message that triggered the command.</p> <p> TYPE: <code>hikari.Message</code> </p> <code>register_task</code> <p>Callback used to register long-running tasks spawned by this context.</p> <p> TYPE: <code>collections.Callable[[asyncio.Task[typing.Any]], None]</code> </p> <code>triggering_name</code> <p>The name of the command that triggered this context.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>triggering_prefix</code> <p>The prefix that triggered this context.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p>"},{"location":"reference/context/#tanjun.context.message.MessageContext.set_triggering_prefix","title":"set_triggering_prefix","text":"<pre><code>set_triggering_prefix(triggering_prefix)\n</code></pre> <p>Set the triggering prefix for this context.</p> PARAMETER DESCRIPTION <code>triggering_prefix</code> <p>The triggering prefix to set.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This context to allow for chaining.</p>"},{"location":"reference/context/#tanjun.context.slash","title":"tanjun.context.slash","text":"<p>Slash command implementation.</p>"},{"location":"reference/context/#tanjun.context.slash.AppCommandContext","title":"AppCommandContext","text":"<p>         Bases: <code>base.BaseContext</code>, <code>tanjun.AppCommandContext</code></p> <p>Base class for interaction-based command contexts.</p>"},{"location":"reference/context/#tanjun.context.slash.AppCommandContext.cancel_defer","title":"cancel_defer","text":"<pre><code>cancel_defer()\n</code></pre> <p>Cancel the auto-deferral if its active.</p>"},{"location":"reference/context/#tanjun.context.slash.AppCommandContext.start_defer_timer","title":"start_defer_timer","text":"<pre><code>start_defer_timer(count_down)\n</code></pre> <p>Start the auto-deferral timer.</p> PARAMETER DESCRIPTION <code>count_down</code> <p>The number of seconds to wait before automatically deferring the interaction.</p> <p> TYPE: <code>typing.Union[int, float]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This context to allow for chaining.</p>"},{"location":"reference/context/#tanjun.context.slash.SlashContext","title":"SlashContext","text":"<p>         Bases: <code>AppCommandContext</code>, <code>tanjun.SlashContext</code></p> <p>Standard implementation of tanjun.abc.SlashContext.</p>"},{"location":"reference/context/#tanjun.context.slash.SlashContext.__init__","title":"__init__","text":"<pre><code>__init__(client, interaction, register_task, *, default_to_ephemeral=False, future=None, on_not_found=None)\n</code></pre> <p>Initialise a slash command context.</p> PARAMETER DESCRIPTION <code>client</code> <p>The Tanjun client this context is bound to.</p> <p> TYPE: <code>tanjun.Client</code> </p> <code>interaction</code> <p>The command interaction this context is for.</p> <p> TYPE: <code>hikari.CommandInteraction</code> </p> <code>register_task</code> <p>Callback used to register long-running tasks spawned by this context.</p> <p> TYPE: <code>collections.Callable[[asyncio.Task[typing.Any]], None]</code> </p> <code>default_to_ephemeral</code> <p>Whether to default to ephemeral responses.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>future</code> <p>A future used to set the initial response if this is being called through the REST webhook flow.</p> <p> TYPE: <code>typing.Optional[asyncio.Future[_ResponseTypeT]]</code> DEFAULT: <code>None</code> </p> <code>on_not_found</code> <p>Callback used to indicate no matching command was found.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[tanjun.SlashContext], collections.Awaitable[None]]]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/context/#tanjun.context.slash.SlashOption","title":"SlashOption","text":"<p>         Bases: <code>tanjun.SlashOption</code></p> <p>Standard implementation of the SlashOption interface.</p>"},{"location":"reference/context/#tanjun.context.slash.SlashOption.__init__","title":"__init__","text":"<pre><code>__init__(resolved, option)\n</code></pre> <p>Initialise a slash option.</p> PARAMETER DESCRIPTION <code>resolved</code> <p>The resolved option data if applicable.</p> <p> TYPE: <code>typing.Optional[hikari.ResolvedOptionData]</code> </p> <code>option</code> <p>The raw interaction option.</p> <p> TYPE: <code>hikari.CommandInteractionOption</code> </p>"},{"location":"reference/conversion/","title":"tanjun.conversion","text":"<p>Functions and classes used to enable more Discord oriented argument converters.</p>"},{"location":"reference/conversion/#tanjun.conversion.defragment_url","title":"defragment_url  <code>module-attribute</code>","text":"<pre><code>defragment_url: collections.Callable[[str], urlparse.DefragResult] = _build_url_parser(urlparse.urldefrag)\n</code></pre> <p>Convert an argument to a defragmented URL.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to parse (this argument can only be passed positionally).</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>urllib.parse.DefragResult</code> <p>The parsed URL.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the argument couldn't be parsed.</p>"},{"location":"reference/conversion/#tanjun.conversion.parse_channel_id","title":"parse_channel_id  <code>module-attribute</code>","text":"<pre><code>parse_channel_id: _IDMatcherSigProto = _make_snowflake_parser(_CHANNEL_ID_REGEX)\n</code></pre> <p>Parse a channel ID from a string or int value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to parse (this argument can only be passed positionally).</p> <p> TYPE: <code>str | int | float</code> </p> <code>message</code> <p>The error message to raise if the value cannot be parsed.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>hikari.Snowflake</code> <p>The parsed channel ID.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the value cannot be parsed.</p>"},{"location":"reference/conversion/#tanjun.conversion.parse_emoji_id","title":"parse_emoji_id  <code>module-attribute</code>","text":"<pre><code>parse_emoji_id: _IDMatcherSigProto = _make_snowflake_parser(_EMOJI_ID_REGEX)\n</code></pre> <p>Parse an Emoji ID from a string or int value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to parse (this argument can only be passed positionally).</p> <p> TYPE: <code>str | int | float</code> </p> <code>message</code> <p>The error message to raise if the value cannot be parsed.</p> <p>Defaults to \"No valid mention or ID found\".</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>hikari.Snowflake</code> <p>The parsed Emoji ID.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the value cannot be parsed.</p>"},{"location":"reference/conversion/#tanjun.conversion.parse_role_id","title":"parse_role_id  <code>module-attribute</code>","text":"<pre><code>parse_role_id: _IDMatcherSigProto = _make_snowflake_parser(_ROLE_ID_REGEX)\n</code></pre> <p>Parse a role ID from a string or int value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to parse (this argument can only be passed positionally).</p> <p> TYPE: <code>str | int | float</code> </p> <code>message</code> <p>The error message to raise if the value cannot be parsed.</p> <p>Defaults to \"No valid mention or ID found\".</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>hikari.Snowflake</code> <p>The parsed role ID.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the value cannot be parsed.</p>"},{"location":"reference/conversion/#tanjun.conversion.parse_snowflake","title":"parse_snowflake  <code>module-attribute</code>","text":"<pre><code>parse_snowflake: _IDMatcherSigProto = _make_snowflake_parser(_SNOWFLAKE_REGEX)\n</code></pre> <p>Parse a snowflake from a string or int value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to parse (this argument can only be passed positionally).</p> <p> TYPE: <code>str | int | float</code> </p> <code>message</code> <p>The error message to raise if the value cannot be parsed.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>hikari.Snowflake</code> <p>The parsed snowflake.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the value cannot be parsed.</p>"},{"location":"reference/conversion/#tanjun.conversion.parse_url","title":"parse_url  <code>module-attribute</code>","text":"<pre><code>parse_url: collections.Callable[[str], urlparse.ParseResult] = _build_url_parser(urlparse.urlparse)\n</code></pre> <p>Convert an argument to a parsed URL.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to parse (this argument can only be passed positionally).</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>urllib.parse.ParseResult</code> <p>The parsed URL.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the argument couldn't be parsed.</p>"},{"location":"reference/conversion/#tanjun.conversion.parse_user_id","title":"parse_user_id  <code>module-attribute</code>","text":"<pre><code>parse_user_id: _IDMatcherSigProto = _make_snowflake_parser(_USER_ID_REGEX)\n</code></pre> <p>Parse a user ID from a string or int value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to parse (this argument can only be passed positionally).</p> <p> TYPE: <code>str | int | float</code> </p> <code>message</code> <p>The error message to raise if the value cannot be parsed.</p> <p>Defaults to \"No valid mention or ID found\".</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>hikari.Snowflake</code> <p>The parsed user ID.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the value cannot be parsed.</p>"},{"location":"reference/conversion/#tanjun.conversion.search_channel_ids","title":"search_channel_ids  <code>module-attribute</code>","text":"<pre><code>search_channel_ids: _IDSearcherSig = _make_snowflake_searcher(_CHANNEL_ID_REGEX)\n</code></pre> <p>Get the channel IDs in a string.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to parse (this argument can only be passed positionally).</p> <p> TYPE: <code>str | int | float</code> </p> RETURNS DESCRIPTION <code>list[hikari.Snowflake]</code> <p>List of the channel IDs in the string.</p>"},{"location":"reference/conversion/#tanjun.conversion.search_emoji_ids","title":"search_emoji_ids  <code>module-attribute</code>","text":"<pre><code>search_emoji_ids: _IDSearcherSig = _make_snowflake_searcher(_EMOJI_ID_REGEX)\n</code></pre> <p>Get the emoji IDs in a string.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to parse (this argument can only be passed positionally).</p> <p> TYPE: <code>str | int | float</code> </p> RETURNS DESCRIPTION <code>list[hikari.Snowflake]</code> <p>List of the emoji IDs in the string.</p>"},{"location":"reference/conversion/#tanjun.conversion.search_role_ids","title":"search_role_ids  <code>module-attribute</code>","text":"<pre><code>search_role_ids: _IDSearcherSig = _make_snowflake_searcher(_ROLE_ID_REGEX)\n</code></pre> <p>Get the role IDs in a string.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to parse (this argument can only be passed positionally).</p> <p> TYPE: <code>str | int | float</code> </p> RETURNS DESCRIPTION <code>list[hikari.Snowflake]</code> <p>List of the role IDs in the string.</p>"},{"location":"reference/conversion/#tanjun.conversion.search_snowflakes","title":"search_snowflakes  <code>module-attribute</code>","text":"<pre><code>search_snowflakes: _IDSearcherSig = _make_snowflake_searcher(_SNOWFLAKE_REGEX)\n</code></pre> <p>Get the snowflakes in a string.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to parse (this argument can only be passed positionally).</p> <p> TYPE: <code>str | int | float</code> </p> RETURNS DESCRIPTION <code>list[hikari.Snowflake]</code> <p>List of the snowflakes in the string.</p>"},{"location":"reference/conversion/#tanjun.conversion.search_user_ids","title":"search_user_ids  <code>module-attribute</code>","text":"<pre><code>search_user_ids: _IDSearcherSig = _make_snowflake_searcher(_USER_ID_REGEX)\n</code></pre> <p>Get the user IDs in a string.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to parse (this argument can only be passed positionally).</p> <p> TYPE: <code>str | int | float</code> </p> RETURNS DESCRIPTION <code>list[hikari.Snowflake]</code> <p>List of the user IDs in the string.</p>"},{"location":"reference/conversion/#tanjun.conversion.split_url","title":"split_url  <code>module-attribute</code>","text":"<pre><code>split_url: collections.Callable[[str], urlparse.SplitResult] = _build_url_parser(urlparse.urlsplit)\n</code></pre> <p>Convert an argument to a split URL.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to parse (this argument can only be passed positionally).</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>urllib.parse.SplitResult</code> <p>The split URL.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the argument couldn't be parsed.</p>"},{"location":"reference/conversion/#tanjun.conversion.to_channel","title":"to_channel  <code>module-attribute</code>","text":"<pre><code>to_channel: typing.Final[ToChannel] = ToChannel()\n</code></pre> <p>Convert user input to a hikari.channels.PartialChannel object.</p>"},{"location":"reference/conversion/#tanjun.conversion.to_colour","title":"to_colour  <code>module-attribute</code>","text":"<pre><code>to_colour: typing.Final[collections.Callable[[_SnowflakeIsh], hikari.Color]] = to_color\n</code></pre> <p>Convert user input to a hikari.colors.Color object.</p>"},{"location":"reference/conversion/#tanjun.conversion.to_emoji","title":"to_emoji  <code>module-attribute</code>","text":"<pre><code>to_emoji: typing.Final[ToEmoji] = ToEmoji()\n</code></pre> <p>Convert user input to a cached hikari.emojis.KnownCustomEmoji object.</p> <p>Note</p> <p>If you just want to convert input to a hikari.emojis.Emoji, hikari.emojis.CustomEmoji or hikari.emojis.UnicodeEmoji without making any cache or REST calls then you can just use the relevant hikari.emojis.Emoji.parse, hikari.emojis.CustomEmoji.parse or hikari.emojis.UnicodeEmoji.parse methods.</p>"},{"location":"reference/conversion/#tanjun.conversion.to_guild","title":"to_guild  <code>module-attribute</code>","text":"<pre><code>to_guild: typing.Final[ToGuild] = ToGuild()\n</code></pre> <p>Convert user input to a hikari.guilds.Guild object.</p>"},{"location":"reference/conversion/#tanjun.conversion.to_invite","title":"to_invite  <code>module-attribute</code>","text":"<pre><code>to_invite: typing.Final[ToInvite] = ToInvite()\n</code></pre> <p>Convert user input to a cached hikari.invites.InviteWithMetadata object.</p>"},{"location":"reference/conversion/#tanjun.conversion.to_invite_with_metadata","title":"to_invite_with_metadata  <code>module-attribute</code>","text":"<pre><code>to_invite_with_metadata: typing.Final[ToInviteWithMetadata] = ToInviteWithMetadata()\n</code></pre> <p>Convert user input to a hikari.invites.Invite object.</p>"},{"location":"reference/conversion/#tanjun.conversion.to_member","title":"to_member  <code>module-attribute</code>","text":"<pre><code>to_member: typing.Final[ToMember] = ToMember()\n</code></pre> <p>Convert user input to a hikari.guilds.Member object.</p>"},{"location":"reference/conversion/#tanjun.conversion.to_message","title":"to_message  <code>module-attribute</code>","text":"<pre><code>to_message: typing.Final[ToMessage] = ToMessage()\n</code></pre> <p>Convert user input to a hikari.messages.Message object.</p>"},{"location":"reference/conversion/#tanjun.conversion.to_presence","title":"to_presence  <code>module-attribute</code>","text":"<pre><code>to_presence: typing.Final[ToPresence] = ToPresence()\n</code></pre> <p>Convert user input to a cached hikari.presences.MemberPresence.</p>"},{"location":"reference/conversion/#tanjun.conversion.to_role","title":"to_role  <code>module-attribute</code>","text":"<pre><code>to_role: typing.Final[ToRole] = ToRole()\n</code></pre> <p>Convert user input to a hikari.guilds.Role object.</p>"},{"location":"reference/conversion/#tanjun.conversion.to_snowflake","title":"to_snowflake  <code>module-attribute</code>","text":"<pre><code>to_snowflake: typing.Final[collections.Callable[[_SnowflakeIsh], hikari.Snowflake]] = parse_snowflake\n</code></pre> <p>Convert user input to a hikari.snowflakes.Snowflake.</p> <p>Note</p> <p>This also range validates the input.</p>"},{"location":"reference/conversion/#tanjun.conversion.to_user","title":"to_user  <code>module-attribute</code>","text":"<pre><code>to_user: typing.Final[ToUser] = ToUser()\n</code></pre> <p>Convert user input to a hikari.users.User object.</p>"},{"location":"reference/conversion/#tanjun.conversion.to_voice_state","title":"to_voice_state  <code>module-attribute</code>","text":"<pre><code>to_voice_state: typing.Final[ToVoiceState] = ToVoiceState()\n</code></pre> <p>Convert user input to a cached hikari.voices.VoiceState.</p>"},{"location":"reference/conversion/#tanjun.conversion.BaseConverter","title":"BaseConverter","text":"<p>Base class for the standard converters.</p> <p>Warning</p> <p>Inheriting from this is completely unnecessary and should be avoided for people using the library unless they know what they're doing.</p> <p>This is detail of the standard implementation and isn't guaranteed to work between implementations but will work for implementations which provide the standard dependency injection or special cased support for these.</p> <p>While it isn't necessary to subclass this to implement your own converters since dependency injection can be used to access fields like the current Context, this class introduces some niceties around stuff like state warnings.</p>"},{"location":"reference/conversion/#tanjun.conversion.BaseConverter.async_caches","title":"async_caches  <code>property</code>","text":"<pre><code>async_caches: collections.Sequence[typing.Any]\n</code></pre> <p>Deprecated property.</p>"},{"location":"reference/conversion/#tanjun.conversion.BaseConverter.cache_components","title":"cache_components  <code>property</code>","text":"<pre><code>cache_components: hikari.api.CacheComponents\n</code></pre> <p>Deprecated property.</p>"},{"location":"reference/conversion/#tanjun.conversion.BaseConverter.caches","title":"caches  <code>property</code>","text":"<pre><code>caches: collections.Sequence[tuple[typing.Any, hikari.api.CacheComponents, hikari.Intents]]\n</code></pre> <p>Caches the converter takes advantage of.</p> <p>This returns a tuple of async cache types and the relevant cache components which will be needed if said async cache isn't implemented.</p> <p>Note</p> <p>Unless tanjun.conversion.BaseConverter.requires_cache is True, these cache components aren't necessary but simply avoid the converter from falling back to REST requests.</p>"},{"location":"reference/conversion/#tanjun.conversion.BaseConverter.intents","title":"intents  <code>property</code>","text":"<pre><code>intents: hikari.Intents\n</code></pre> <p>Deprecated property.</p>"},{"location":"reference/conversion/#tanjun.conversion.BaseConverter.requires_cache","title":"requires_cache  <code>property</code>","text":"<pre><code>requires_cache: bool\n</code></pre> <p>Whether this converter relies on the relevant cache stores to work.</p> <p>If this is True then this converter will not function properly in an environment tanjun.conversion.BaseConverter.intents or tanjun.conversion.BaseConverter.cache_components isn't satisfied and will never fallback to REST requests.</p>"},{"location":"reference/conversion/#tanjun.conversion.BaseConverter.check_client","title":"check_client","text":"<pre><code>check_client(client, parent_name)\n</code></pre> <p>Check that this converter will work with the given client.</p> <p>This never raises any errors but simply warns the user if the converter is not compatible with the given client.</p> PARAMETER DESCRIPTION <code>client</code> <p>The client to check against.</p> <p> TYPE: <code>tanjun.Client</code> </p> <code>parent_name</code> <p>The name of the converter's parent, used for warning messages.</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/conversion/#tanjun.conversion.ChannelConverter","title":"ChannelConverter","text":"<p>         Bases: <code>ToChannel</code></p> <p>Deprecated alias of tanjun.conversion.ToChannel.</p>"},{"location":"reference/conversion/#tanjun.conversion.EmojiConverter","title":"EmojiConverter","text":"<p>         Bases: <code>ToEmoji</code></p> <p>Deprecated alias of tanjun.conversion.ToEmoji.</p>"},{"location":"reference/conversion/#tanjun.conversion.GuildConverter","title":"GuildConverter","text":"<p>         Bases: <code>ToGuild</code></p> <p>Deprecated alias of tanjun.conversion.ToGuild.</p>"},{"location":"reference/conversion/#tanjun.conversion.InviteConverter","title":"InviteConverter","text":"<p>         Bases: <code>ToInvite</code></p> <p>Deprecated alias of tanjun.conversion.ToInvite.</p>"},{"location":"reference/conversion/#tanjun.conversion.InviteWithMetadataConverter","title":"InviteWithMetadataConverter","text":"<p>         Bases: <code>ToInviteWithMetadata</code></p> <p>Deprecated alias of tanjun.conversion.ToInviteWithMetadata.</p>"},{"location":"reference/conversion/#tanjun.conversion.MemberConverter","title":"MemberConverter","text":"<p>         Bases: <code>ToMember</code></p> <p>Deprecated alias of tanjun.conversion.ToMember.</p>"},{"location":"reference/conversion/#tanjun.conversion.PresenceConverter","title":"PresenceConverter","text":"<p>         Bases: <code>ToPresence</code></p> <p>Deprecated alias of tanjun.conversion.ToPresence.</p>"},{"location":"reference/conversion/#tanjun.conversion.RoleConverter","title":"RoleConverter","text":"<p>         Bases: <code>ToRole</code></p> <p>Deprecated alias of tanjun.conversion.ToRole.</p>"},{"location":"reference/conversion/#tanjun.conversion.ToChannel","title":"ToChannel","text":"<p>         Bases: <code>BaseConverter</code></p> <p>Standard converter for channels mentions/IDs.</p> <p>For a standard instance of this see tanjun.conversion.to_channel.</p>"},{"location":"reference/conversion/#tanjun.conversion.ToChannel.__init__","title":"__init__","text":"<pre><code>__init__(*, allowed_types=None, include_dms=True)\n</code></pre> <p>Initialise a to channel converter.</p> PARAMETER DESCRIPTION <code>allowed_types</code> <p>Collection of channel types and classes to allow.</p> <p>If this is None then all channel types will be allowed.</p> <p> TYPE: <code>typing.Optional[collections.Collection[typing.Union[type[hikari.PartialChannel], int]]]</code> DEFAULT: <code>None</code> </p> <code>include_dms</code> <p>Whether to include DM channels in the results.</p> <p>May lead to a lot of extra fallbacks to REST requests if the client doesn't have a registered async cache for DMs.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"reference/conversion/#tanjun.conversion.ToEmoji","title":"ToEmoji","text":"<p>         Bases: <code>BaseConverter</code></p> <p>Standard converter for custom emojis.</p> <p>For a standard instance of this see tanjun.conversion.to_emoji.</p> <p>Note</p> <p>If you just want to convert inpute to a hikari.emojis.Emoji, hikari.emojis.CustomEmoji or hikari.emojis.UnicodeEmoji without making any cache or REST calls then you can just use the relevant Emoji.parse, CustomEmoji.parse or UnicodeEmoji.parse methods.</p>"},{"location":"reference/conversion/#tanjun.conversion.ToGuild","title":"ToGuild","text":"<p>         Bases: <code>BaseConverter</code></p> <p>Standard converter for guilds.</p> <p>For a standard instance of this see tanjun.conversion.to_guild.</p>"},{"location":"reference/conversion/#tanjun.conversion.ToInvite","title":"ToInvite","text":"<p>         Bases: <code>BaseConverter</code></p> <p>Standard converter for invites.</p>"},{"location":"reference/conversion/#tanjun.conversion.ToInviteWithMetadata","title":"ToInviteWithMetadata","text":"<p>         Bases: <code>BaseConverter</code></p> <p>Standard converter for invites with metadata.</p> <p>For a standard instance of this see tanjun.conversion.to_invite_with_metadata.</p> <p>Note</p> <p>Unlike tanjun.conversion.InviteConverter, this converter is cache dependent.</p>"},{"location":"reference/conversion/#tanjun.conversion.ToMember","title":"ToMember","text":"<p>         Bases: <code>BaseConverter</code></p> <p>Standard converter for guild members.</p> <p>For a standard instance of this see tanjun.conversion.to_member.</p> <p>This converter allows both mentions, raw IDs and partial usernames/nicknames and only works within a guild context.</p>"},{"location":"reference/conversion/#tanjun.conversion.ToMessage","title":"ToMessage","text":"<p>         Bases: <code>BaseConverter</code></p> <p>Standard converter for messages.</p> <p>For a standard instance of this see tanjun.conversion.to_message.</p>"},{"location":"reference/conversion/#tanjun.conversion.ToPresence","title":"ToPresence","text":"<p>         Bases: <code>BaseConverter</code></p> <p>Standard converter for presences.</p> <p>For a standard instance of this see tanjun.conversion.to_presence.</p> <p>This converter is cache dependent and only works in a guild context.</p>"},{"location":"reference/conversion/#tanjun.conversion.ToRole","title":"ToRole","text":"<p>         Bases: <code>BaseConverter</code></p> <p>Standard converter for guild roles.</p> <p>For a standard instance of this see tanjun.conversion.to_role.</p>"},{"location":"reference/conversion/#tanjun.conversion.ToUser","title":"ToUser","text":"<p>         Bases: <code>BaseConverter</code></p> <p>Standard converter for users.</p> <p>For a standard instance of this see tanjun.conversion.to_user.</p>"},{"location":"reference/conversion/#tanjun.conversion.ToVoiceState","title":"ToVoiceState","text":"<p>         Bases: <code>BaseConverter</code></p> <p>Standard converter for voice states.</p> <p>For a standard instance of this see tanjun.conversion.to_voice_state.</p> <p>Note</p> <p>This converter is cache dependent and only works in a guild context.</p>"},{"location":"reference/conversion/#tanjun.conversion.UserConverter","title":"UserConverter","text":"<p>         Bases: <code>ToUser</code></p> <p>Deprecated alias of tanjun.conversion.ToUser.</p>"},{"location":"reference/conversion/#tanjun.conversion.VoiceStateConverter","title":"VoiceStateConverter","text":"<p>         Bases: <code>ToVoiceState</code></p> <p>Deprecated alias of tanjun.conversion.ToVoiceState.</p>"},{"location":"reference/conversion/#tanjun.conversion.from_datetime","title":"from_datetime","text":"<pre><code>from_datetime(value, /, *, style='f')\n</code></pre> <p>Format a datetime as Discord's datetime format.</p> <p>More information on this format can be found at https://discord.com/developers/docs/reference#message-formatting-timestamp-styles</p> PARAMETER DESCRIPTION <code>value</code> <p>The datetime to format.</p> <p>If a timedelta is passed here then this is treated as a date that's relative to the current time.</p> <p> TYPE: <code>typing.Union[datetime.datetime, datetime.timedelta]</code> </p> <code>style</code> <p>The style to use.</p> <p>The valid styles can be found at https://discord.com/developers/docs/reference#message-formatting-formats.</p> <p>This is always \"R\" when <code>value</code> is a datetime.timedelta.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'f'</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The formatted datetime.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the provided datetime is timezone naive. If an invalid style is provided.</p>"},{"location":"reference/conversion/#tanjun.conversion.parse_message_id","title":"parse_message_id","text":"<pre><code>parse_message_id(value, /, *, message='No valid message link or ID found')\n</code></pre> <p>Parse a user ID from a string or int value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to parse (this argument can only be passed positionally).</p> <p> TYPE: <code>_SnowflakeIsh</code> </p> <code>message</code> <p>The error message to raise if the value cannot be parsed.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'No valid message link or ID found'</code> </p> RETURNS DESCRIPTION <code>tuple[hikari.Snowflake | None, hikari.Snowflake]</code> <p>The parsed channel and message IDs.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the value cannot be parsed.</p>"},{"location":"reference/conversion/#tanjun.conversion.to_bool","title":"to_bool","text":"<pre><code>to_bool(value)\n</code></pre> <p>Convert user string input into a boolean value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to convert.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>The converted value.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the value cannot be converted.</p>"},{"location":"reference/conversion/#tanjun.conversion.to_color","title":"to_color","text":"<pre><code>to_color(argument)\n</code></pre> <p>Convert user input to a hikari.colors.Color object.</p>"},{"location":"reference/conversion/#tanjun.conversion.to_datetime","title":"to_datetime","text":"<pre><code>to_datetime(value)\n</code></pre> <p>Parse a datetime from Discord's datetime format.</p> <p>More information on this format can be found at https://discord.com/developers/docs/reference#message-formatting-timestamp-styles</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to parse.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>datetime.datetime</code> <p>The parsed datetime.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the value cannot be parsed.</p>"},{"location":"reference/dependencies/","title":"tanjun.dependencies","text":"<p>Default dependency utilities used within Tanjun and their abstract interfaces.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.async_cache","title":"tanjun.dependencies.async_cache","text":"<p>Interface for an optional asynchronous gateway cache dependency.</p> <p>This allows you to share data between instances using something like a redis cache (for example) and will be used by standard Tanjun components as well as extensions if implemented.</p> <p>Note</p> <p>While there aren't any standard implementations for these interfaces, a Redis implementation of this for the types found in Hikari's gateway cache can be found in hikari-sake &gt;=v1.0.1a1 (exposed by sake.redis.ResourceClient.add_to_tanjun).</p> <p>Tanjun will use the following type dependencies for these interfaces if they are registered with the client:</p> <ul> <li><code>AsyncCache[str, hikari.InviteWithMetadata]</code></li> <li><code>SfCache[hikari.PermissibleGuildChannel]</code></li> <li><code>SfCache[hikari.GuildThreadChannel]</code></li> <li><code>SfCache[hikari.KnownCustomEmoji]</code></li> <li><code>SfCache[hikari.Guild]</code></li> <li><code>SfCache[hikari.Role]</code></li> <li><code>SfCache[hikari.User]</code></li> <li><code>SfGuildBound[hikari.Member]</code></li> <li><code>SfGuildBound[hikari.MemberPresence]</code></li> <li><code>SfGuildBound[hikari.VoiceState]</code></li> <li><code>SfGuildBound[hikari.Role]</code></li> <li><code>SingleStoreCache[hikari.OwnUser]</code></li> <li><code>SingleStoreCache[hikari.Application]</code></li> <li><code>SingleStoreCache[hikari.AuthorizationApplication]</code></li> </ul>"},{"location":"reference/dependencies/#tanjun.dependencies.async_cache.SfCache","title":"SfCache  <code>module-attribute</code>","text":"<pre><code>SfCache = AsyncCache[hikari.Snowflakeish, _ValueT]\n</code></pre> <p>Alias of tanjun.dependencies.AsyncCache where the key is a snowflake.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.async_cache.SfChannelBound","title":"SfChannelBound  <code>module-attribute</code>","text":"<pre><code>SfChannelBound = ChannelBoundCache[hikari.Snowflakeish, _ValueT]\n</code></pre> <p>Alias of tanjun.dependencies.ChannelBoundCache where the key is a snowflake.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.async_cache.SfGuildBound","title":"SfGuildBound  <code>module-attribute</code>","text":"<pre><code>SfGuildBound = GuildBoundCache[hikari.Snowflakeish, _ValueT]\n</code></pre> <p>Alias of tanjun.dependencies.GuildBoundCache where the key is a snowflake.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.async_cache.AsyncCache","title":"AsyncCache","text":"<p>         Bases: <code>abc.ABC</code>, <code>typing.Generic[_KeyT, _ValueT]</code></p> <p>Abstract interface of a cache which stores globally identifiable resources.</p> <p>Note</p> <p>This will never be implemented for resources such as hikari.guilds.Member and hikari.presences.MemberPresence which are only unique per-parent resource.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.async_cache.AsyncCache.get","title":"get  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>get(key, /, *, default=Ellipsis)\n</code></pre> <p>Get an entry from this cache by ID.</p> PARAMETER DESCRIPTION <code>key</code> <p>Unique key of the entry to get; this will often be a snowflake.</p> <p> TYPE: <code>_KeyT</code> </p> <code>default</code> <p>The default value to return if an entry wasn't found.</p> <p>If provided then no errors will be raised when no entry is found.</p> <p> TYPE: <code>_DefaultT</code> DEFAULT: <code>Ellipsis</code> </p> RETURNS DESCRIPTION <code>_ValueT | _DefaultT</code> <p>The found entry or the default if any was provided.</p> RAISES DESCRIPTION <code>CacheMissError</code> <p>If the entry wasn't found.</p> <p>This won't be raised if <code>default</code> is passed.</p> <code>EntryNotFound</code> <p>If the entry wasn't found and the the entry definitely doesn't exist.</p> <p>This won't be raised if <code>default</code> is passed.</p> <p>This is a specialisation of <code>CacheMissError</code> and thus may be caught as <code>CacheMissError and otherwise would need to be before</code>CacheMissError` in a try, multiple catch statement.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.async_cache.AsyncCache.iter_all","title":"iter_all  <code>abstractmethod</code>","text":"<pre><code>iter_all()\n</code></pre> <p>Asynchronously iterate over the globally cached entries for this resource.</p> <p>Note</p> <p>For more information on how this is used, see the documentation for hikari.iterators.LazyIterator.</p> RETURNS DESCRIPTION <code>CacheIterator[_ValueT]</code> <p>An asynchronous iterator of the entries cached globally for this resource.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.async_cache.CacheIterator","title":"CacheIterator","text":"<p>         Bases: <code>hikari.LazyIterator[_ValueT]</code></p> <p>Abstract interface of a cache resource asynchronous iterator.</p> <p>For more information on how this is used, see the documentation for hikari.iterators.LazyIterator.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.async_cache.CacheIterator.len","title":"len  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>len()\n</code></pre> <p>Get the length of the target resource.</p> <p>Note</p> <p>Unlike tanjun.dependencies.CacheIterator.count, this method will not deplete the iterator.</p> RETURNS DESCRIPTION <code>int</code> <p>The length of the targeted resource.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.async_cache.CacheMissError","title":"CacheMissError","text":"<p>         Bases: <code>errors.TanjunError</code></p> <p>Raised when an entry isn't found in the cache.</p> <p>Note</p> <p>EntryNotFound inherits from this error and will only be raised if the cache knows that the entry doesn't exist.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.async_cache.ChannelBoundCache","title":"ChannelBoundCache","text":"<p>         Bases: <code>abc.ABC</code>, <code>typing.Generic[_KeyT, _ValueT]</code></p> <p>Abstract interface of a cache which stores channel-bound resources.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.async_cache.ChannelBoundCache.get_from_channel","title":"get_from_channel  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>get_from_channel(channel_id, key, /, *, default=Ellipsis)\n</code></pre> <p>Get an entry from this cache for a specific channel by ID.</p> PARAMETER DESCRIPTION <code>channel_id</code> <p>ID of the channel to get an entry for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> <code>key</code> <p>Unique key of the entry to get; this will usually be a snowflake.</p> <p> TYPE: <code>_KeyT</code> </p> <code>default</code> <p>The default value to return if an entry wasn't found.</p> <p>If provided then no errors will be raised when no entry is found.</p> <p> TYPE: <code>_DefaultT</code> DEFAULT: <code>Ellipsis</code> </p> RETURNS DESCRIPTION <code>_ValueT | _DefaultT</code> <p>The found entry or the default if any was provided.</p> RAISES DESCRIPTION <code>CacheMissError</code> <p>If the entry wasn't found.</p> <p>This won't be raised if <code>default</code> is passed.</p> <code>EntryNotFound</code> <p>If the entry wasn't found and the the entry definitely doesn't exist.</p> <p>This won't be raised if <code>default</code> is passed.</p> <p>This is a specialisation of <code>CacheMissError</code> and thus may be caught as <code>CacheMissError and otherwise would need to be before</code>CacheMissError` in a try, multiple catch statement.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.async_cache.ChannelBoundCache.iter_all","title":"iter_all  <code>abstractmethod</code>","text":"<pre><code>iter_all()\n</code></pre> <p>Asynchronously iterate over the globally cached entries for this resource.</p> <p>Note</p> <p>For more information on how this is used, see the documentation for hikari.iterators.LazyIterator.</p> RETURNS DESCRIPTION <code>CacheIterator[_ValueT]</code> <p>An asynchronous iterator of the entries cached globally for this resource.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.async_cache.ChannelBoundCache.iter_for_channel","title":"iter_for_channel  <code>abstractmethod</code>","text":"<pre><code>iter_for_channel(channel_id)\n</code></pre> <p>Asynchronously iterate over the entries entries cached for a channel.</p> PARAMETER DESCRIPTION <code>channel_id</code> <p>ID of the channel to iterate over the entries cached for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>CacheIterator[_ValueT]</code> <p>An asynchronous iterator of the entries cached for the specified channel.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.async_cache.EntryNotFound","title":"EntryNotFound","text":"<p>         Bases: <code>CacheMissError</code></p> <p>Raised when an entry does not exist.</p> <p>Note</p> <p>This is a specialisation of CacheMissError which indicates that the cache is sure that the entry doesn't exist.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.async_cache.GuildBoundCache","title":"GuildBoundCache","text":"<p>         Bases: <code>abc.ABC</code>, <code>typing.Generic[_KeyT, _ValueT]</code></p> <p>Abstract interface of a cache which stores guild-bound resources.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.async_cache.GuildBoundCache.get_from_guild","title":"get_from_guild  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>get_from_guild(guild_id, key, /, *, default=Ellipsis)\n</code></pre> <p>Get an entry from this cache for a specific guild by ID.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>ID of the guild to get an entry for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> <code>key</code> <p>Unique key of the entry to get; this will usually be a snowflake.</p> <p> TYPE: <code>_KeyT</code> </p> <code>default</code> <p>The default value to return if an entry wasn't found.</p> <p>If provided then no errors will be raised when no entry is found.</p> <p> TYPE: <code>_DefaultT</code> DEFAULT: <code>Ellipsis</code> </p> RETURNS DESCRIPTION <code>_ValueT | _DefaultT</code> <p>The found entry or the default if any was provided.</p> RAISES DESCRIPTION <code>CacheMissError</code> <p>If the entry wasn't found.</p> <p>This won't be raised if <code>default</code> is passed.</p> <code>EntryNotFound</code> <p>If the entry wasn't found and the the entry definitely doesn't exist.</p> <p>This won't be raised if <code>default</code> is passed.</p> <p>This is a specialisation of <code>CacheMissError</code> and thus may be caught as <code>CacheMissError and otherwise would need to be before</code>CacheMissError` in a try, multiple catch statement.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.async_cache.GuildBoundCache.iter_all","title":"iter_all  <code>abstractmethod</code>","text":"<pre><code>iter_all()\n</code></pre> <p>Asynchronously iterate over the globally cached entries for this resource.</p> <p>Note</p> <p>For more information on how this is used, see the documentation for hikari.iterators.LazyIterator.</p> RETURNS DESCRIPTION <code>CacheIterator[_ValueT]</code> <p>An asynchronous iterator of the entries cached globally for this resource.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.async_cache.GuildBoundCache.iter_for_guild","title":"iter_for_guild  <code>abstractmethod</code>","text":"<pre><code>iter_for_guild(guild_id)\n</code></pre> <p>Asynchronously iterate over the entries entries cached for a guild.</p> <p>Note</p> <p>For more information on how this is used, see the documentation for hikari.iterators.LazyIterator.</p> PARAMETER DESCRIPTION <code>guild_id</code> <p>ID of the guild to iterate over the entries cached for.</p> <p> TYPE: <code>hikari.Snowflakeish</code> </p> RETURNS DESCRIPTION <code>CacheIterator[_ValueT]</code> <p>An asynchronous iterator of the entries cached for the specified guild.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.async_cache.SingleStoreCache","title":"SingleStoreCache","text":"<p>         Bases: <code>abc.ABC</code>, <code>typing.Generic[_ValueT]</code></p> <p>Abstract interface of a cache which stores one resource.</p> <p>Note</p> <p>This is mostly just for the hikari.users.OwnUser cache store.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.async_cache.SingleStoreCache.get","title":"get  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>get(*, default=Ellipsis)\n</code></pre> <p>Get the entry.</p> PARAMETER DESCRIPTION <code>default</code> <p>The default value to return if an entry wasn't found.</p> <p>If provided then no errors will be raised when no entry is found.</p> <p> TYPE: <code>_DefaultT</code> DEFAULT: <code>Ellipsis</code> </p> RETURNS DESCRIPTION <code>_ValueT | _DefaultT</code> <p>The found entry or the default if any was provided.</p> RAISES DESCRIPTION <code>CacheMissError</code> <p>If the entry wasn't found.</p> <p>This won't be raised if <code>default</code> is passed.</p> <code>EntryNotFound</code> <p>If the entry wasn't found and the the entry definitely doesn't exist.</p> <p>This won't be raised if <code>default</code> is passed.</p> <p>This is a specialisation of <code>CacheMissError</code> and thus may be caught as <code>CacheMissError and otherwise would need to be before</code>CacheMissError` in a try, multiple catch statement.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.callbacks","title":"tanjun.dependencies.callbacks","text":"<p>Callback dependencies used for getting context and client based data.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.callbacks.fetch_my_user","title":"fetch_my_user  <code>async</code>","text":"<pre><code>fetch_my_user(client, *, me_cache=None)\n</code></pre> <p>Fetch the current user from the client's cache or rest client.</p> <p>Note</p> <p>This is used in the standard <code>LazyConstant[hikari.users.OwnUser]</code> dependency.</p> PARAMETER DESCRIPTION <code>client</code> <p>The client to use to fetch the user.</p> <p> TYPE: <code>alluka.Injected[tanjun.Client]</code> </p> RETURNS DESCRIPTION <code>hikari.OwnUser</code> <p>The current user.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the cache couldn't be used to get the current user and the REST client is not bound to a Bot token.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.data","title":"tanjun.dependencies.data","text":"<p>Dependency utilities used for managing data.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.data.LazyConstant","title":"LazyConstant","text":"<p>         Bases: <code>typing.Generic[_T]</code></p> <p>Injected type used to hold and generate lazy constants.</p> <p>Note</p> <p>To easily resolve this type use inject_lc.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.data.LazyConstant.callback","title":"callback  <code>property</code>","text":"<pre><code>callback: alluka.abc.CallbackSig[_T]\n</code></pre> <p>Descriptor of the callback used to get this constant's initial value.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.data.LazyConstant.__init__","title":"__init__","text":"<pre><code>__init__(callback)\n</code></pre> <p>Initiate a new lazy constant.</p> PARAMETER DESCRIPTION <code>callback</code> <p>Callback used to resolve this to a constant value.</p> <p>This supports dependency injection and may either be sync or asynchronous.</p> <p> TYPE: <code>alluka.abc.CallbackSig[_T]</code> </p>"},{"location":"reference/dependencies/#tanjun.dependencies.data.LazyConstant.acquire","title":"acquire","text":"<pre><code>acquire()\n</code></pre> <p>Acquire this lazy constant as an asynchronous lock.</p> <p>This is used to ensure that the value is only generated once and should be kept acquired until LazyConstant.set_value has been called.</p> RETURNS DESCRIPTION <code>contextlib.AbstractAsyncContextManager[typing.Any]</code> <p>Context manager that can be used to acquire the lock.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.data.LazyConstant.get_value","title":"get_value","text":"<pre><code>get_value()\n</code></pre> <p>Get the value of this constant if set, else None.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.data.LazyConstant.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Clear the internally stored value.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.data.LazyConstant.set_value","title":"set_value","text":"<pre><code>set_value(value)\n</code></pre> <p>Set the constant value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to set.</p> <p> TYPE: <code>_T</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the constant has already been set.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.data.cache_callback","title":"cache_callback","text":"<pre><code>cache_callback(callback, /, *, expire_after=None)\n</code></pre> <p>Cache the result of a callback within a dependency injection context.</p> <p>Note</p> <p>This is internally used by cached_inject.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to cache the result of.</p> <p> TYPE: <code>alluka.abc.CallbackSig[_T]</code> </p> <code>expire_after</code> <p>The amount of time to cache the result for in seconds.</p> <p>Leave this as None to cache for the runtime of the application.</p> <p> TYPE: <code>typing.Union[int, float, datetime.timedelta, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[..., collections.abc.Corouting[typing.Any, typing.Any, _T]]</code> <p>A callback which will cache the result of the given callback after the first call.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If expire_after is not a valid value. If expire_after is not less than or equal to 0 seconds.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.data.cached_inject","title":"cached_inject","text":"<pre><code>cached_inject(callback, /, *, expire_after=None)\n</code></pre> <p>Inject a callback with caching.</p> <p>This acts like alluka.inject and the result of it should also be assigned to a parameter's default to be used.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.data.cached_inject--example","title":"Example","text":"<pre><code>async def resolve_database(\n    client: tanjun.abc.Client = tanjun.inject(type=tanjun.abc.Client)\n) -&gt; Database:\n    raise NotImplementedError\n\n@tanjun.as_message_command(\"command name\")\nasync def command(\n    ctx: tanjun.abc.Context, db: Database = tanjun.cached_inject(resolve_database)\n) -&gt; None:\n    raise NotImplementedError\n</code></pre> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to inject.</p> <p> TYPE: <code>alluka.abc.CallbackSig[_T]</code> </p> <code>expire_after</code> <p>The amount of time to cache the result for in seconds.</p> <p>Leave this as None to cache for the runtime of the application.</p> <p> TYPE: <code>typing.Union[float, int, datetime.timedelta, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>alluka.InjectedDescriptor[_T]</code> <p>Injector used to resolve the cached callback.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If expire_after is not a valid value. If expire_after is not less than or equal to 0 seconds.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.data.inject_lc","title":"inject_lc","text":"<pre><code>inject_lc(type_)\n</code></pre> <p>Make a LazyConstant injector.</p> <p>This acts like alluka.inject and the result of it should also be assigned to a parameter's default to be used.</p> <p>Note</p> <p>For this to work, a LazyConstant must've been set as a type dependency for the passed <code>type_</code>.</p> PARAMETER DESCRIPTION <code>type_</code> <p>The type of the constant to resolve.</p> <p> TYPE: <code>type[_T]</code> </p> RETURNS DESCRIPTION <code>alluka.InjectedDescriptor[_T]</code> <p>Injector used to resolve the LazyConstant.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.data.inject_lc--example","title":"Example","text":"<pre><code>@component.with_command\n@tanjun.as_message_command\nasync def command(\n    ctx: tanjun.abc.MessageCommand,\n    application: hikari.Application = tanjun.inject_lc(hikari.Application)\n) -&gt; None:\n    raise NotImplementedError\n\n...\n\nasync def resolve_app(\n    client: tanjun.abc.Client = tanjun.inject(type=tanjun.abc.Client)\n) -&gt; hikari.Application:\n    raise NotImplementedError\n\ntanjun.Client.from_gateway_bot(...).set_type_dependency(\n    tanjun.LazyConstant[hikari.Application] = tanjun.LazyConstant(resolve_app)\n)\n</code></pre>"},{"location":"reference/dependencies/#tanjun.dependencies.data.make_lc_resolver","title":"make_lc_resolver","text":"<pre><code>make_lc_resolver(type_)\n</code></pre> <p>Make an injected callback which resolves a LazyConstant.</p> <p>Note</p> <p>This is internally used by inject_lc.</p> <p>Note</p> <p>For this to work, a LazyConstant must've been set as a type dependency for the passed <code>type_</code>.</p> PARAMETER DESCRIPTION <code>type_</code> <p>The type of the constant to resolve.</p> <p> TYPE: <code>type[_T]</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[..., collections.abc.Coroutine[typing.Any, typing.Any, _T]]</code> <p>An injected callback used to resolve the LazyConstant.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters","title":"tanjun.dependencies.limiters","text":"<p>Command cooldown and concurrency limiters.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.AbstractConcurrencyLimiter","title":"AbstractConcurrencyLimiter","text":"<p>         Bases: <code>abc.ABC</code></p> <p>Interface used for limiting command concurrent usage.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.AbstractConcurrencyLimiter.release","title":"release  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>release(bucket_id, ctx)\n</code></pre> <p>Release a concurrency lock on a bucket.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.AbstractConcurrencyLimiter.try_acquire","title":"try_acquire  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>try_acquire(bucket_id, ctx)\n</code></pre> <p>Try to acquire a concurrency lock on a bucket.</p> PARAMETER DESCRIPTION <code>bucket_id</code> <p>The concurrency bucket to acquire.</p> <p> TYPE: <code>str</code> </p> <code>ctx</code> <p>The context to acquire this resource lock with.</p> <p> TYPE: <code>tanjun.Context</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the lock was acquired.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.AbstractCooldownManager","title":"AbstractCooldownManager","text":"<p>         Bases: <code>abc.ABC</code></p> <p>Interface used for managing command calldowns.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.AbstractCooldownManager.check_cooldown","title":"check_cooldown  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>check_cooldown(bucket_id, ctx, /, *, increment=False)\n</code></pre> <p>Check if a bucket is on cooldown for the provided context.</p> PARAMETER DESCRIPTION <code>bucket_id</code> <p>The cooldown bucket to check.</p> <p> TYPE: <code>str</code> </p> <code>ctx</code> <p>The context of the command.</p> <p> TYPE: <code>tanjun.Context</code> </p> <code>increment</code> <p>Whether this call should increment the bucket's use counter if it isn't depleted.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>datetime.datetime | None</code> <p>When this command will next be usable for the provided context if it's in cooldown else None.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.AbstractCooldownManager.increment_cooldown","title":"increment_cooldown  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>increment_cooldown(bucket_id, ctx)\n</code></pre> <p>Increment the cooldown of a cooldown bucket.</p> PARAMETER DESCRIPTION <code>bucket_id</code> <p>The cooldown bucket's ID.</p> <p> TYPE: <code>str</code> </p> <code>ctx</code> <p>The context of the command.</p> <p> TYPE: <code>tanjun.Context</code> </p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.BucketResource","title":"BucketResource","text":"<p>         Bases: <code>int</code>, <code>enum.Enum</code></p> <p>Resource target types used within command calldowns and concurrency limiters.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.BucketResource.CHANNEL","title":"CHANNEL  <code>class-attribute</code>","text":"<pre><code>CHANNEL = 2\n</code></pre> <p>A per-channel resource bucket.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.BucketResource.GLOBAL","title":"GLOBAL  <code>class-attribute</code>","text":"<pre><code>GLOBAL = 7\n</code></pre> <p>A global resource bucket.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.BucketResource.GUILD","title":"GUILD  <code>class-attribute</code>","text":"<pre><code>GUILD = 6\n</code></pre> <p>A per-guild resource bucket.</p> <p>When executed in a DM this will be per-DM.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.BucketResource.MEMBER","title":"MEMBER  <code>class-attribute</code>","text":"<pre><code>MEMBER = 1\n</code></pre> <p>A per-guild member resource bucket.</p> <p>When executed in a DM this will be per-DM.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.BucketResource.PARENT_CHANNEL","title":"PARENT_CHANNEL  <code>class-attribute</code>","text":"<pre><code>PARENT_CHANNEL = 3\n</code></pre> <p>A per-parent channel resource bucket.</p> <p>For DM channels this will be per-DM, for guild channels with no parents this'll be per-guild.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.BucketResource.TOP_ROLE","title":"TOP_ROLE  <code>class-attribute</code>","text":"<pre><code>TOP_ROLE = 5\n</code></pre> <p>A per-highest role resource bucket.</p> <p>When executed in a DM this will be per-DM, with this defaulting to targeting the @everyone role if they have no real roles.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.BucketResource.USER","title":"USER  <code>class-attribute</code>","text":"<pre><code>USER = 0\n</code></pre> <p>A per-user resource bucket.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.ConcurrencyPostExecution","title":"ConcurrencyPostExecution","text":"<p>Post-execution hook used to release a bucket concurrency limiter.</p> <p>Note</p> <p>For a concurrency limiter to work properly, both ConcurrencyPreExecution and ConcurrencyPostExecution hooks must be registered for a command scope.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.ConcurrencyPostExecution.__init__","title":"__init__","text":"<pre><code>__init__(bucket_id)\n</code></pre> <p>Initialise a concurrency post-execution hook.</p> PARAMETER DESCRIPTION <code>bucket_id</code> <p>The concurrency limit bucket's ID.</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.ConcurrencyPreExecution","title":"ConcurrencyPreExecution","text":"<p>Pre-execution hook used to acquire a bucket concurrency limiter.</p> <p>Note</p> <p>For a concurrency limiter to work properly, both ConcurrencyPreExecution and ConcurrencyPostExecution hooks must be registered for a command scope.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.ConcurrencyPreExecution.__init__","title":"__init__","text":"<pre><code>__init__(bucket_id, /, *, error=None, error_message='This resource is currently busy; please try again later.')\n</code></pre> <p>Initialise a concurrency pre-execution hook.</p> PARAMETER DESCRIPTION <code>bucket_id</code> <p>The concurrency limit bucket's ID.</p> <p> TYPE: <code>str</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This should two one str argument which is the limiting bucket's ID.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[str], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if this fails to acquire the concurrency limit.</p> <p>This supports localisation and uses the check name <code>\"tanjun.concurrency\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> DEFAULT: <code>'This resource is currently busy; please try again later.'</code> </p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.CooldownPreExecution","title":"CooldownPreExecution","text":"<p>Pre-execution hook used to manage a command's cooldowns.</p> <p>To avoid race-conditions this handles both erroring when the bucket is hit instead and incrementing the bucket's use counter.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.CooldownPreExecution.__init__","title":"__init__","text":"<pre><code>__init__(bucket_id, /, *, error=None, error_message='This command is currently in cooldown. Try again {cooldown}.', owners_exempt=True)\n</code></pre> <p>Initialise a pre-execution cooldown command hook.</p> PARAMETER DESCRIPTION <code>bucket_id</code> <p>The cooldown bucket's ID.</p> <p> TYPE: <code>str</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This should two arguments one of type str and datetime.datetime where the first is the limiting bucket's ID and the second is when said bucket can be used again.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[str, datetime.datetime], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>This supports localisation and uses the check name <code>\"tanjun.cooldown\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> DEFAULT: <code>'This command is currently in cooldown. Try again {cooldown}.'</code> </p> <code>owners_exempt</code> <p>Whether owners should be exempt from the cooldown.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.InMemoryConcurrencyLimiter","title":"InMemoryConcurrencyLimiter","text":"<p>         Bases: <code>AbstractConcurrencyLimiter</code></p> <p>In-memory standard implementation of AbstractConcurrencyLimiter.</p> <p>Examples:</p> <p>InMemoryConcurrencyLimiter.set_bucket may be used to set the concurrency limits for a specific bucket:</p> <pre><code>(\n    InMemoryConcurrencyLimiter()\n    # Set the default bucket template to 10 concurrent uses of the command per-user.\n    .set_bucket(\"default\", tanjun.BucketResource.USER, 10)\n    # Set the \"moderation\" bucket with a limit of 5 concurrent uses per-guild.\n    .set_bucket(\"moderation\", tanjun.BucketResource.GUILD, 5)\n    .set_bucket()\n    # add_to_client will setup the concurrency manager (setting it as an\n    # injected dependency and registering callbacks to manage it).\n    .add_to_client(client)\n)\n</code></pre>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.InMemoryConcurrencyLimiter.add_to_client","title":"add_to_client","text":"<pre><code>add_to_client(client)\n</code></pre> <p>Add this concurrency manager to a tanjun client.</p> <p>Note</p> <p>This registers the manager as a type dependency and manages opening and closing the manager based on the client's life cycle.</p> PARAMETER DESCRIPTION <code>client</code> <p>The client to add this concurrency manager to.</p> <p> TYPE: <code>tanjun.Client</code> </p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.InMemoryConcurrencyLimiter.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Stop the concurrency manager.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the concurrency manager is not running.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.InMemoryConcurrencyLimiter.disable_bucket","title":"disable_bucket","text":"<pre><code>disable_bucket(bucket_id)\n</code></pre> <p>Disable a concurrency limit bucket.</p> <p>This will stop the bucket from ever hitting a concurrency limit and also prevents the bucket from defaulting.</p> <p>Note</p> <p>\"default\" is a special <code>bucket_id</code> which is used as a template for unknown bucket IDs.</p> PARAMETER DESCRIPTION <code>bucket_id</code> <p>The bucket to disable.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This concurrency manager to allow for chaining.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.InMemoryConcurrencyLimiter.open","title":"open","text":"<pre><code>open(*, _loop=None)\n</code></pre> <p>Start the concurrency manager.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the concurrency manager is already running. If called in a thread with no running event loop.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.InMemoryConcurrencyLimiter.set_bucket","title":"set_bucket","text":"<pre><code>set_bucket(bucket_id, resource, limit)\n</code></pre> <p>Set the concurrency limit for a specific bucket.</p> <p>Note</p> <p>\"default\" is a special <code>bucket_id</code> which is used as a template for unknown bucket IDs.</p> PARAMETER DESCRIPTION <code>bucket_id</code> <p>The ID of the bucket to set the concurrency limit for.</p> <p> TYPE: <code>str</code> </p> <code>resource</code> <p>The type of resource to target for the concurrency limit.</p> <p> TYPE: <code>BucketResource</code> </p> <code>limit</code> <p>The maximum number of concurrent uses to allow.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The concurrency manager to allow call chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If an invalid resource type is given. if limit is less 0 or negative.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.InMemoryCooldownManager","title":"InMemoryCooldownManager","text":"<p>         Bases: <code>AbstractCooldownManager</code></p> <p>In-memory standard implementation of AbstractCooldownManager.</p> <p>Examples:</p> <p>InMemoryCooldownManager.set_bucket may be used to set the cooldown for a specific bucket:</p> <pre><code>(\n    InMemoryCooldownManager()\n    # Set the default bucket template to a per-user 10 uses per-60 seconds cooldown.\n    .set_bucket(\"default\", tanjun.BucketResource.USER, 10, 60)\n    # Set the \"moderation\" bucket to a per-guild 100 uses per-5 minutes cooldown.\n    .set_bucket(\"moderation\", tanjun.BucketResource.GUILD, 100, datetime.timedelta(minutes=5))\n    .set_bucket()\n    # add_to_client will setup the cooldown manager (setting it as an\n    # injected dependency and registering callbacks to manage it).\n    .add_to_client(client)\n)\n</code></pre>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.InMemoryCooldownManager.add_to_client","title":"add_to_client","text":"<pre><code>add_to_client(client)\n</code></pre> <p>Add this cooldown manager to a tanjun client.</p> <p>Note</p> <p>This registers the manager as a type dependency and manages opening and closing the manager based on the client's life cycle.</p> PARAMETER DESCRIPTION <code>client</code> <p>The client to add this cooldown manager to.</p> <p> TYPE: <code>tanjun.Client</code> </p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.InMemoryCooldownManager.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Stop the cooldown manager.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the cooldown manager is not running.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.InMemoryCooldownManager.disable_bucket","title":"disable_bucket","text":"<pre><code>disable_bucket(bucket_id)\n</code></pre> <p>Disable a cooldown bucket.</p> <p>This will stop the bucket from ever hitting a cooldown and also prevents the bucket from defaulting.</p> <p>Note</p> <p>\"default\" is a special <code>bucket_id</code> which is used as a template for unknown bucket IDs.</p> PARAMETER DESCRIPTION <code>bucket_id</code> <p>The bucket to disable.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This cooldown manager to allow for chaining.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.InMemoryCooldownManager.open","title":"open","text":"<pre><code>open(*, _loop=None)\n</code></pre> <p>Start the cooldown manager.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the cooldown manager is already running. If called in a thread with no running event loop.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.InMemoryCooldownManager.set_bucket","title":"set_bucket","text":"<pre><code>set_bucket(bucket_id, resource, limit, reset_after)\n</code></pre> <p>Set the cooldown for a specific bucket.</p> <p>Note</p> <p>\"default\" is a special <code>bucket_id</code> which is used as a template for unknown bucket IDs.</p> PARAMETER DESCRIPTION <code>bucket_id</code> <p>The ID of the bucket to set the cooldown for.</p> <p> TYPE: <code>str</code> </p> <code>resource</code> <p>The type of resource to target for the cooldown.</p> <p> TYPE: <code>BucketResource</code> </p> <code>limit</code> <p>The number of uses per cooldown period.</p> <p> TYPE: <code>int</code> </p> <code>reset_after</code> <p>The cooldown period.</p> <p> TYPE: <code>typing.Union[int, float, datetime.timedelta]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The cooldown manager to allow call chaining.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If an invalid resource type is given. If reset_after or limit are negative, 0 or invalid. if limit is less 0 or negative.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.with_concurrency_limit","title":"with_concurrency_limit","text":"<pre><code>with_concurrency_limit(bucket_id, /, *, error=None, error_message='This resource is currently busy; please try again later.', follow_wrapped=False)\n</code></pre> <p>Add the hooks used to manage a command's concurrency limit through a decorator call.</p> <p>Warning</p> <p>Concurrency limiters will only work if there's a setup injected AbstractConcurrencyLimiter dependency with InMemoryConcurrencyLimiter being usable as a standard in-memory concurrency manager.</p> PARAMETER DESCRIPTION <code>bucket_id</code> <p>The concurrency limit bucket's ID.</p> <p> TYPE: <code>str</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This should two one str argument which is the limiting bucket's ID.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[str], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if this fails to acquire the concurrency limit.</p> <p>This supports localisation and uses the check name <code>\"tanjun.concurrency\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> DEFAULT: <code>'This resource is currently busy; please try again later.'</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.ExecutableCommand], tanjun.abc.ExecutableCommand]</code> <p>A decorator that adds the concurrency limiter hooks to a command.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.limiters.with_cooldown","title":"with_cooldown","text":"<pre><code>with_cooldown(bucket_id, /, *, error=None, error_message='This command is currently in cooldown. Try again {cooldown}.', follow_wrapped=False, owners_exempt=True)\n</code></pre> <p>Add a pre-execution hook used to manage a command's cooldown through a decorator call.</p> <p>Warning</p> <p>Cooldowns will only work if there's a setup injected AbstractCooldownManager dependency with InMemoryCooldownManager being usable as a standard in-memory cooldown manager.</p> PARAMETER DESCRIPTION <code>bucket_id</code> <p>The cooldown bucket's ID.</p> <p> TYPE: <code>str</code> </p> <code>error</code> <p>Callback used to create a custom error to raise if the check fails.</p> <p>This should two arguments one of type str and datetime.datetime where the first is the limiting bucket's ID and the second is when said bucket can be used again.</p> <p>This takes priority over <code>error_message</code>.</p> <p> TYPE: <code>typing.Optional[collections.Callable[[str, datetime.datetime], Exception]]</code> DEFAULT: <code>None</code> </p> <code>error_message</code> <p>The error message to send in response as a command error if the check fails.</p> <p>This supports localisation and uses the check name <code>\"tanjun.cooldown\"</code> for global overrides.</p> <p> TYPE: <code>typing.Union[str, collections.Mapping[str, str]]</code> DEFAULT: <code>'This command is currently in cooldown. Try again {cooldown}.'</code> </p> <code>follow_wrapped</code> <p>Whether to also add this check to any other command objects this command wraps in a decorator call chain.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>owners_exempt</code> <p>Whether owners should be exempt from the cooldown.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.ExecutableCommand], tanjun.abc.ExecutableCommand]</code> <p>A decorator that adds a CooldownPreExecution hook to the command.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.locales","title":"tanjun.dependencies.locales","text":"<p>Dependency used for managing localising strings around interactions commands.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.locales.AbstractLocalizer","title":"AbstractLocalizer  <code>module-attribute</code>","text":"<pre><code>AbstractLocalizer = AbstractLocaliser\n</code></pre> <p>Alias of <code>AbstractLocaliser</code>.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.locales.BasicLocalizer","title":"BasicLocalizer  <code>module-attribute</code>","text":"<pre><code>BasicLocalizer = BasicLocaliser\n</code></pre> <p>Alias of <code>BasicLocaliser</code>.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.locales.AbstractLocaliser","title":"AbstractLocaliser","text":"<p>         Bases: <code>abc.ABC</code></p> <p>Abstract class of a string localiser.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.locales.AbstractLocaliser.get_all_variants","title":"get_all_variants  <code>abstractmethod</code>","text":"<pre><code>get_all_variants(identifier, /, **kwargs)\n</code></pre> <p>Get all the localisation variants for an identifier.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.locales.AbstractLocaliser.localise","title":"localise  <code>abstractmethod</code>","text":"<pre><code>localise(identifier, tag, /, **kwargs)\n</code></pre> <p>Localise a string with the given identifier and arguments.</p> PARAMETER DESCRIPTION <code>identifier</code> <p>The unique identifier of the string to localise.</p> <p>This may be in any format but the formats used by the standard implementations can be found at client-localiser.</p> <p> TYPE: <code>str</code> </p> <code>tag</code> <p>The \"IETF lang tag\" to localise the string to.</p> <p>This should usually be a hikari.locales.Locale.</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>Key-word arguments to pass to the string as format args.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The localised string.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.locales.AbstractLocaliser.localize","title":"localize","text":"<pre><code>localize(identifier, tag, /, **kwargs)\n</code></pre> <p>Alias for <code>AbstractLocaliser.localise</code>.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.locales.BasicLocaliser","title":"BasicLocaliser","text":"<p>         Bases: <code>AbstractLocaliser</code></p> <p>Standard implementation of <code>AbstractLocaliser</code> with only basic text mapping support.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.locales.BasicLocaliser.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> <p>Initialise a new <code>BasicLocaliser</code>.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.locales.BasicLocaliser.add_to_client","title":"add_to_client","text":"<pre><code>add_to_client(client)\n</code></pre> <p>Add this global localiser to a tanjun client.</p> <p>Note</p> <p>This registers the manager as a type dependency to let Tanjun use it.</p> PARAMETER DESCRIPTION <code>client</code> <p>The client to add this global localiser to.</p> <p> TYPE: <code>tanjun.Client</code> </p>"},{"location":"reference/dependencies/#tanjun.dependencies.locales.BasicLocaliser.set_variants","title":"set_variants","text":"<pre><code>set_variants(identifier, variants=None, /, **other_variants)\n</code></pre> <p>Set the variants for a localised field.</p> PARAMETER DESCRIPTION <code>identifier</code> <p>Identifier of the field to set the localised variants for.</p> <p>This may be in any format but the formats used by the standard implementations can be found at client-localiser.</p> <p> TYPE: <code>str</code> </p> <code>variants</code> <p>Mapping of hikari.locales.Locales to the localised values.</p> <p> TYPE: <code>typing.Optional[collections.Mapping[str, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The localiser object to enable chained calls.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.owners","title":"tanjun.dependencies.owners","text":"<p>Dependency used for managing owner checks.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.owners.AbstractOwners","title":"AbstractOwners","text":"<p>         Bases: <code>abc.ABC</code></p> <p>Interface used to check if a user is deemed to be the bot's \"owner\".</p>"},{"location":"reference/dependencies/#tanjun.dependencies.owners.AbstractOwners.check_ownership","title":"check_ownership  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>check_ownership(client, user)\n</code></pre> <p>Check whether this object is owned by the given object.</p> PARAMETER DESCRIPTION <code>client</code> <p>The Tanjun client this check is being called by.</p> <p> TYPE: <code>tanjun.Client</code> </p> <code>user</code> <p>The user to check ownership for.</p> <p> TYPE: <code>hikari.User</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the bot is owned by the provided user.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.owners.Owners","title":"Owners","text":"<p>         Bases: <code>AbstractOwners</code></p> <p>Default implementation of the owner check interface.</p> <p>Warning</p> <p><code>fallback_to_application</code> is only possible when the REST client is bound to a Bot token or if a type dependency is registered for <code>tanjun.dependencies.SingleStoreCache[hikari.Application]</code>.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.owners.Owners.__init__","title":"__init__","text":"<pre><code>__init__(*, expire_after=datetime.timedelta(minutes=5), fallback_to_application=True, owners=None)\n</code></pre> <p>Initiate a new owner check dependency.</p> PARAMETER DESCRIPTION <code>expire_after</code> <p>The amount of time to cache application owner data for in seconds.</p> <p>This is only applicable if <code>rest</code> is also passed.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, int, float]</code> DEFAULT: <code>datetime.timedelta(minutes=5)</code> </p> <code>fallback_to_application</code> <p>Whether this check should fallback to checking the application's owners if the user isn't in <code>owners</code>.</p> <p>This only works when the bot's rest client is bound to a Bot token or if <code>tanjun.dependencies.SingleStoreCache[hikari.Application]</code> is available.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>owners</code> <p>Sequence of objects and IDs of the users that are allowed to use the bot's owners-only commands.</p> <p> TYPE: <code>typing.Optional[hikari.SnowflakeishSequence[hikari.User]]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/dependencies/#tanjun.dependencies.reloaders","title":"tanjun.dependencies.reloaders","text":"<p>Implementation of a hot reloader for Tanjun.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.reloaders.HotReloader","title":"HotReloader","text":"<p>Manages hot reloading modules for a Tanjun client..</p> <p>Warning</p> <p>An instance of this can only be linked to 1 client.</p> <p>Examples:</p> <pre><code>client = tanjun.Client.from_gateway_bot(bot)\n(\n    tanjun.dependencies.HotReloader()\n    .add_modules(\"python.module.path\", pathlib.Path(\"./module.py\"))\n    .add_directory(\"./modules/\")\n    .add_to_client(client)\n)\n</code></pre>"},{"location":"reference/dependencies/#tanjun.dependencies.reloaders.HotReloader.__init__","title":"__init__","text":"<pre><code>__init__(*, commands_guild=None, interval=datetime.timedelta(microseconds=500000), redeclare_cmds_after=datetime.timedelta(seconds=10), unload_on_delete=True)\n</code></pre> <p>Initialise a hot reloader.</p> <p>Warning</p> <p><code>redeclare_cmds_after</code> is not aware of commands declared outside of the reloader and will lead to commands being redeclared on startup when mixed with tanjun.clients.Client.__init__'s <code>declare_global_commands</code> argument when it is not None.</p> PARAMETER DESCRIPTION <code>commands_guild</code> <p>Object or ID of the guild to declare commands in if <code>redeclare_cmds_after</code> is not None.</p> <p> TYPE: <code>typing.Optional[hikari.SnowflakeishOr[hikari.PartialGuild]]</code> DEFAULT: <code>None</code> </p> <code>interval</code> <p>How often this should scan files and directories for changes in seconds.</p> <p> TYPE: <code>typing.Union[int, float, datetime.timedelta]</code> DEFAULT: <code>datetime.timedelta(microseconds=500000)</code> </p> <code>redeclare_cmds_after</code> <p>How often to redeclare application commands after a change to the commands is detected.</p> <p>If None is passed here then this will not redeclare the application's commands.</p> <p> TYPE: <code>typing.Union[int, float, datetime.timedelta, None]</code> DEFAULT: <code>datetime.timedelta(seconds=10)</code> </p> <code>unload_on_delete</code> <p>Whether this should unload modules when their relevant file is deleted.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"reference/dependencies/#tanjun.dependencies.reloaders.HotReloader.add_directory","title":"add_directory","text":"<pre><code>add_directory(directory, /, *, namespace=None)\n</code></pre> <p>Add a directory for this hot reloader to track.</p> <p>Note</p> <p>This will only reload modules directly in the target directory and will not scan sub-directories.</p> PARAMETER DESCRIPTION <code>directory</code> <p>Path of the directory to hot reload.</p> <p> TYPE: <code>typing.Union[str, pathlib.Path]</code> </p> <code>namespace</code> <p>The python namespace this directory's modules should be imported from, if applicable.</p> <p>This work as <code>{namespace}.{file.name.removesuffix(\".py\")}</code> and will have the same behaviour as when a str is passed to tanjun.abc.Client.load_modules if passed.</p> <p>If left as None then this will have the same behaviour as when a pathlib.Path is passed to tanjun.abc.Client.load_modules.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The hot reloader to enable chained calls.</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If the directory cannot be found</p>"},{"location":"reference/dependencies/#tanjun.dependencies.reloaders.HotReloader.add_directory_async","title":"add_directory_async  <code>async</code>","text":"<pre><code>add_directory_async(directory, /, *, namespace=None)\n</code></pre> <p>Asynchronous variant of tanjun.dependencies.reloaders.HotReloader.add_directory.</p> <p>Unlike tanjun.dependencies.reloaders.HotReloader.add_directory, this method will run blocking code in a background thread.</p> <p>For more information on the behaviour of this method see the documentation for tanjun.dependencies.reloaders.HotReloader.add_directory.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.reloaders.HotReloader.add_modules","title":"add_modules","text":"<pre><code>add_modules(*paths)\n</code></pre> <p>Add modules for this hot reloader to track.</p> PARAMETER DESCRIPTION <code>*paths</code> <p>Module paths for this hot reloader to track.</p> <p>This has the same behaviour as [tanjun.abc.Client.load_modules][ for how [pathlib.Path][] and str are treated.</p> <p> TYPE: <code>typing.Union[str, pathlib.Path]</code> DEFAULT: <code>()</code> </p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If the module's file doesn't exist anymore.</p> <code>ModuleNotFoundError</code> <p>If the str module path cannot be imported.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.reloaders.HotReloader.add_modules_async","title":"add_modules_async  <code>async</code>","text":"<pre><code>add_modules_async(*paths)\n</code></pre> <p>Asynchronous variant of tanjun.dependencies.reloaders.HotReloader.add_modules.</p> <p>Unlike tanjun.dependencies.reloaders.HotReloader.add_modules, this method will run blocking code in a background thread.</p> <p>For more information on the behaviour of this method see the documentation for tanjun.abc.Client.load_modules.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.reloaders.HotReloader.add_to_client","title":"add_to_client","text":"<pre><code>add_to_client(client)\n</code></pre> <p>Add this to a tanjun.abc.Client instance.</p> <p>This registers start and closing callbacks which handle the lifetime of this and adds this as a type dependency.</p> PARAMETER DESCRIPTION <code>client</code> <p>The client to link this hot reloader to.</p> <p> TYPE: <code>tanjun.Client</code> </p>"},{"location":"reference/dependencies/#tanjun.dependencies.reloaders.HotReloader.scan","title":"scan  <code>async</code>","text":"<pre><code>scan(client)\n</code></pre> <p>Manually scan this hot reloader's tracked modules for changes.</p> PARAMETER DESCRIPTION <code>client</code> <p>The client to reload and unload modules in.</p> <p> TYPE: <code>tanjun.Client</code> </p>"},{"location":"reference/dependencies/#tanjun.dependencies.reloaders.HotReloader.start","title":"start","text":"<pre><code>start(client)\n</code></pre> <p>Start the hot reloader.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the hot reloader is already running.</p>"},{"location":"reference/dependencies/#tanjun.dependencies.reloaders.HotReloader.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stop the hot reloader.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the hot reloader isn't running.</p>"},{"location":"reference/errors/","title":"tanjun.errors","text":"<p>The errors and warnings raised within and by Tanjun.</p>"},{"location":"reference/errors/#tanjun.errors.MissingDependencyError","title":"MissingDependencyError  <code>module-attribute</code>","text":"<pre><code>MissingDependencyError = alluka.MissingDependencyError\n</code></pre> <p>Type alias of alluka.MissingDependencyError.</p>"},{"location":"reference/errors/#tanjun.errors.CommandError","title":"CommandError","text":"<p>         Bases: <code>TanjunError</code></p> <p>An error which is sent as a response to the command call.</p>"},{"location":"reference/errors/#tanjun.errors.CommandError.attachments","title":"attachments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attachments = [attachment] if attachment else attachments\n</code></pre> <p>Sequence of the attachments to be sent as a response to the command, if set.</p>"},{"location":"reference/errors/#tanjun.errors.CommandError.components","title":"components  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>components = [component] if component else components\n</code></pre> <p>Sequence of the components to be sent as a response to the command, if set.</p>"},{"location":"reference/errors/#tanjun.errors.CommandError.content","title":"content  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>content = content\n</code></pre> <p>The response error message's content.</p>"},{"location":"reference/errors/#tanjun.errors.CommandError.delete_after","title":"delete_after  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delete_after = delete_after\n</code></pre> <p>The seconds after which the response message should be deleted, if set.</p>"},{"location":"reference/errors/#tanjun.errors.CommandError.embeds","title":"embeds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>embeds = [embed] if embed else embeds\n</code></pre> <p>Sequence of the embeds to be sent as a response to the command, if set.</p>"},{"location":"reference/errors/#tanjun.errors.CommandError.mentions_everyone","title":"mentions_everyone  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mentions_everyone = mentions_everyone\n</code></pre> <p>Whether or not the response should be allowed to mention <code>@everyone</code>/<code>@here</code>.</p>"},{"location":"reference/errors/#tanjun.errors.CommandError.role_mentions","title":"role_mentions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>role_mentions = role_mentions\n</code></pre> <p>Configuration for the response's allowed role mentions.</p> <p>If this is a sequence then the response will only be allowed to mention roles in the sequence.</p> <p>If this is a bool then the response will only be allowed to mention roles if the value is <code>True</code>.</p>"},{"location":"reference/errors/#tanjun.errors.CommandError.user_mentions","title":"user_mentions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user_mentions = user_mentions\n</code></pre> <p>Configuration for the response's allowed user mentions.</p> <p>If this is a sequence then the response will only be allowed to mention users in the sequence.</p> <p>If this is a bool then the response will only be allowed to mention users if the value is <code>True</code>.</p>"},{"location":"reference/errors/#tanjun.errors.CommandError.__init__","title":"__init__","text":"<pre><code>__init__(content=hikari.UNDEFINED, *, delete_after=None, attachment=hikari.UNDEFINED, attachments=hikari.UNDEFINED, component=hikari.UNDEFINED, components=hikari.UNDEFINED, embed=hikari.UNDEFINED, embeds=hikari.UNDEFINED, mentions_everyone=hikari.UNDEFINED, user_mentions=hikari.UNDEFINED, role_mentions=hikari.UNDEFINED)\n</code></pre> <p>Initialise a command error.</p> PARAMETER DESCRIPTION <code>content</code> <p>The content to respond with.</p> <p>If provided, the message contents. If hikari.undefined.UNDEFINED, then nothing will be sent in the content.</p> <p> TYPE: <code>hikari.UndefinedOr[typing.Any]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>delete_after</code> <p>If provided, the seconds after which the response message should be deleted.</p> <p>Slash command responses can only be deleted within 15 minutes of the command being received.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, float, int, None]</code> DEFAULT: <code>None</code> </p> <code>attachment</code> <p>A singular attachment to respond with.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Resourceish]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>attachments</code> <p>A sequence of attachments to respond with.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Resourceish]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>component</code> <p>If provided, builder object of the component to include in this response.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.api.ComponentBuilder]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>components</code> <p>If provided, a sequence of the component builder objects to include in this response.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.api.ComponentBuilder]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embed</code> <p>An embed to respond with.</p> <p> TYPE: <code>hikari.UndefinedOr[hikari.Embed]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>embeds</code> <p>A sequence of embeds to respond with.</p> <p> TYPE: <code>hikari.UndefinedOr[collections.Sequence[hikari.Embed]]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>mentions_everyone</code> <p>If provided, whether the message should parse @everyone/@here mentions.</p> <p> TYPE: <code>hikari.UndefinedOr[bool]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>user_mentions</code> <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.users.PartialUser derivatives to enforce mentioning specific users.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialUser], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> <code>role_mentions</code> <p>If provided, and True, all mentions will be parsed. If provided, and False, no mentions will be parsed.</p> <p>Alternatively this may be a collection of hikari.snowflakes.Snowflake, or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.</p> <p> TYPE: <code>typing.Union[hikari.SnowflakeishSequence[hikari.PartialRole], bool, hikari.UndefinedType]</code> DEFAULT: <code>hikari.UNDEFINED</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>Raised for any of the following reasons:</p> <ul> <li>When both <code>attachment</code> and <code>attachments</code> are provided.</li> <li>When both <code>component</code> and <code>components</code> are passed.</li> <li>When both <code>embed</code> and <code>embeds</code> are passed.</li> <li>If more than 100 entries are passed for <code>role_mentions</code>.</li> <li>If more than 100 entries are passed for <code>user_mentions</code>.</li> </ul>"},{"location":"reference/errors/#tanjun.errors.CommandError.send","title":"send  <code>async</code>","text":"<pre><code>send(ctx, /, *, ensure_result=False)\n</code></pre> <p>Send this error as a command response.</p> PARAMETER DESCRIPTION <code>ctx</code> <p>The command call context to respond to.</p> <p> TYPE: <code>tanjun.Context</code> </p> <code>ensure_result</code> <p>Ensure that this call will always return a message object.</p> <p>If True then this will always return hikari.messages.Message, otherwise this will return <code>hikari.Message | None</code>.</p> <p>It's worth noting that, under certain scenarios within the slash command flow, this may lead to an extre request being made.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>delete_after</code> would be more than 15 minutes after the slash command was called.</p> <code>hikari.BadRequestError</code> <p>This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.</p> <code>hikari.UnauthorizedError</code> <p>If you are unauthorized to make the request (invalid/missing token).</p> <code>hikari.ForbiddenError</code> <p>If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.</p> <code>hikari.NotFoundError</code> <p>If the channel is not found.</p> <code>hikari.RateLimitTooLongError</code> <p>Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.</p> <code>hikari.InternalServerError</code> <p>If an internal error occurs on Discord while handling the request.</p>"},{"location":"reference/errors/#tanjun.errors.ConversionError","title":"ConversionError","text":"<p>         Bases: <code>ParserError</code></p> <p>Error raised by a parser parameter when it failed to converter a value.</p>"},{"location":"reference/errors/#tanjun.errors.ConversionError.errors","title":"errors  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>errors = tuple(errors)\n</code></pre> <p>Sequence of the errors that were caught during conversion for this parameter.</p>"},{"location":"reference/errors/#tanjun.errors.ConversionError.parameter","title":"parameter  <code>class-attribute</code>","text":"<pre><code>parameter: str\n</code></pre> <p>Name of the parameter this error was raised for.</p>"},{"location":"reference/errors/#tanjun.errors.ConversionError.__init__","title":"__init__","text":"<pre><code>__init__(message, parameter, /, *, errors=())\n</code></pre> <p>Initialise a conversion error.</p> PARAMETER DESCRIPTION <code>parameter</code> <p>The parameter this was raised by.</p> <p> TYPE: <code>str</code> </p> <code>errors</code> <p>An iterable of the source value errors which were raised during conversion.</p> <p> TYPE: <code>collections.Iterable[ValueError]</code> DEFAULT: <code>()</code> </p>"},{"location":"reference/errors/#tanjun.errors.FailedCheck","title":"FailedCheck","text":"<p>         Bases: <code>TanjunError</code>, <code>RuntimeError</code></p> <p>Error raised as an alternative to returning <code>False</code> in a check.</p>"},{"location":"reference/errors/#tanjun.errors.FailedModuleImport","title":"FailedModuleImport","text":"<p>         Bases: <code>FailedModuleLoad</code></p> <p>Error raised when a module failed to import.</p> <p>This is a specialisation of tanjun.errors.FailedModuleLoad.</p>"},{"location":"reference/errors/#tanjun.errors.FailedModuleLoad","title":"FailedModuleLoad","text":"<p>         Bases: <code>TanjunError</code></p> <p>Error raised when a module fails to load.</p> <p>This may be raised by the module failing to import or by one of its loaders erroring.</p> <p>This source error can be accessed at FailedModuleLoad.cause.</p>"},{"location":"reference/errors/#tanjun.errors.FailedModuleLoad.__cause__","title":"__cause__  <code>class-attribute</code>","text":"<pre><code>__cause__: Exception\n</code></pre> <p>The root error.</p>"},{"location":"reference/errors/#tanjun.errors.FailedModuleLoad.path","title":"path  <code>property</code>","text":"<pre><code>path: typing.Union[str, pathlib.Path]\n</code></pre> <p>The path of the module which caused the error.</p>"},{"location":"reference/errors/#tanjun.errors.FailedModuleUnload","title":"FailedModuleUnload","text":"<p>         Bases: <code>TanjunError</code></p> <p>Error raised when a module fails to unload.</p> <p>This may be raised by the module failing to import or by one of its unloaders erroring.</p> <p>The source error can be accessed at FailedModuleUnload.cause.</p>"},{"location":"reference/errors/#tanjun.errors.FailedModuleUnload.__cause__","title":"__cause__  <code>class-attribute</code>","text":"<pre><code>__cause__: Exception\n</code></pre> <p>The root error.</p>"},{"location":"reference/errors/#tanjun.errors.FailedModuleUnload.path","title":"path  <code>property</code>","text":"<pre><code>path: typing.Union[str, pathlib.Path]\n</code></pre> <p>The path of the module which caused the error.</p>"},{"location":"reference/errors/#tanjun.errors.HaltExecution","title":"HaltExecution","text":"<p>         Bases: <code>TanjunError</code></p> <p>Error raised while looking for a command in-order to end-execution early.</p> <p>For the most part, this will be raised during checks in-order to prevent other commands from being tried.</p>"},{"location":"reference/errors/#tanjun.errors.InvalidCheck","title":"InvalidCheck","text":"<p>         Bases: <code>TanjunError</code>, <code>RuntimeError</code></p> <p>Error raised as an assertion that a check will never pass in the current environment.</p>"},{"location":"reference/errors/#tanjun.errors.ModuleMissingLoaders","title":"ModuleMissingLoaders","text":"<p>         Bases: <code>RuntimeError</code>, <code>TanjunError</code></p> <p>Error raised when a module is missing loaders.</p>"},{"location":"reference/errors/#tanjun.errors.ModuleMissingLoaders.message","title":"message  <code>property</code>","text":"<pre><code>message: str\n</code></pre> <p>The error message.</p>"},{"location":"reference/errors/#tanjun.errors.ModuleMissingLoaders.path","title":"path  <code>property</code>","text":"<pre><code>path: typing.Union[str, pathlib.Path]\n</code></pre> <p>The path of the module which is missing loaders.</p>"},{"location":"reference/errors/#tanjun.errors.ModuleMissingUnloaders","title":"ModuleMissingUnloaders","text":"<p>         Bases: <code>RuntimeError</code>, <code>TanjunError</code></p> <p>Error raised when a module is missing unloaders.</p>"},{"location":"reference/errors/#tanjun.errors.ModuleMissingUnloaders.message","title":"message  <code>property</code>","text":"<pre><code>message: str\n</code></pre> <p>The error message.</p>"},{"location":"reference/errors/#tanjun.errors.ModuleMissingUnloaders.path","title":"path  <code>property</code>","text":"<pre><code>path: typing.Union[str, pathlib.Path]\n</code></pre> <p>The path of the module which is missing unloaders.</p>"},{"location":"reference/errors/#tanjun.errors.ModuleStateConflict","title":"ModuleStateConflict","text":"<p>         Bases: <code>ValueError</code>, <code>TanjunError</code></p> <p>Error raised when a module cannot be (un)loaded due to a state conflict.</p>"},{"location":"reference/errors/#tanjun.errors.ModuleStateConflict.message","title":"message  <code>property</code>","text":"<pre><code>message: str\n</code></pre> <p>The error message.</p>"},{"location":"reference/errors/#tanjun.errors.ModuleStateConflict.path","title":"path  <code>property</code>","text":"<pre><code>path: typing.Union[str, pathlib.Path]\n</code></pre> <p>The path of the module which caused the error.</p>"},{"location":"reference/errors/#tanjun.errors.NotEnoughArgumentsError","title":"NotEnoughArgumentsError","text":"<p>         Bases: <code>ParserError</code></p> <p>Error raised by the parser when not enough arguments are found for a parameter.</p>"},{"location":"reference/errors/#tanjun.errors.NotEnoughArgumentsError.parameter","title":"parameter  <code>class-attribute</code>","text":"<pre><code>parameter: str\n</code></pre> <p>Name of the parameter this error was raised for.</p>"},{"location":"reference/errors/#tanjun.errors.NotEnoughArgumentsError.__init__","title":"__init__","text":"<pre><code>__init__(message, parameter)\n</code></pre> <p>Initialise a not enough arguments error.</p> PARAMETER DESCRIPTION <code>message</code> <p>The error message.</p> <p> TYPE: <code>str</code> </p> <code>parameter</code> <p>The parameter this error was raised for.</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/errors/#tanjun.errors.ParserError","title":"ParserError","text":"<p>         Bases: <code>TanjunError</code>, <code>ValueError</code></p> <p>Base error raised by a parser or parameter during parsing.</p> <p>Note</p> <p>Expected errors raised by the parser will subclass this error.</p>"},{"location":"reference/errors/#tanjun.errors.ParserError.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre> <p>String message for this error.</p> <p>Note</p> <p>This may be used as a command response message.</p>"},{"location":"reference/errors/#tanjun.errors.ParserError.parameter","title":"parameter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parameter = parameter\n</code></pre> <p>Name of the this was raised for.</p> <p>Note</p> <p>This will be None if it was raised while parsing the provided message content.</p>"},{"location":"reference/errors/#tanjun.errors.ParserError.__init__","title":"__init__","text":"<pre><code>__init__(message, parameter)\n</code></pre> <p>Initialise a parser error.</p> PARAMETER DESCRIPTION <code>message</code> <p>String message for this error.</p> <p> TYPE: <code>str</code> </p> <code>parameter</code> <p>Name of the parameter which caused this error, should be None if not applicable.</p> <p> TYPE: <code>typing.Optional[str]</code> </p>"},{"location":"reference/errors/#tanjun.errors.TanjunError","title":"TanjunError","text":"<p>         Bases: <code>Exception</code></p> <p>The base class for all errors raised by Tanjun.</p>"},{"location":"reference/errors/#tanjun.errors.TooManyArgumentsError","title":"TooManyArgumentsError","text":"<p>         Bases: <code>ParserError</code></p> <p>Error raised by the parser when too many arguments are found for a parameter.</p>"},{"location":"reference/errors/#tanjun.errors.TooManyArgumentsError.parameter","title":"parameter  <code>class-attribute</code>","text":"<pre><code>parameter: str\n</code></pre> <p>Name of the parameter this error was raised for.</p>"},{"location":"reference/errors/#tanjun.errors.TooManyArgumentsError.__init__","title":"__init__","text":"<pre><code>__init__(message, parameter)\n</code></pre> <p>Initialise a too many arguments error.</p> PARAMETER DESCRIPTION <code>message</code> <p>The error message.</p> <p> TYPE: <code>str</code> </p> <code>parameter</code> <p>The parameter this error was raised for.</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/hooks/","title":"tanjun.hooks","text":"<p>Standard implementation of Tanjun's command execution hook models.</p>"},{"location":"reference/hooks/#tanjun.hooks.AnyHooks","title":"AnyHooks  <code>module-attribute</code>","text":"<pre><code>AnyHooks = Hooks[tanjun.Context]\n</code></pre> <p>Hooks that can be used with any context.</p> <p>Note</p> <p>This is shorthand for <code>Hooks[tanjun.abc.Context]</code>.</p>"},{"location":"reference/hooks/#tanjun.hooks.MenuHooks","title":"MenuHooks  <code>module-attribute</code>","text":"<pre><code>MenuHooks = Hooks[tanjun.MenuContext]\n</code></pre> <p>Hooks that can be used with a menu context.</p> <p>Note</p> <p>This is shorthand for <code>Hooks[tanjun.abc.MenuContext]</code>.</p>"},{"location":"reference/hooks/#tanjun.hooks.MessageHooks","title":"MessageHooks  <code>module-attribute</code>","text":"<pre><code>MessageHooks = Hooks[tanjun.MessageContext]\n</code></pre> <p>Hooks that can be used with a message context.</p> <p>Note</p> <p>This is shorthand for <code>Hooks[tanjun.abc.MessageContext]</code>.</p>"},{"location":"reference/hooks/#tanjun.hooks.SlashHooks","title":"SlashHooks  <code>module-attribute</code>","text":"<pre><code>SlashHooks = Hooks[tanjun.SlashContext]\n</code></pre> <p>Hooks that can be used with a slash context.</p> <p>Note</p> <p>This is shorthand for <code>Hooks[tanjun.abc.SlashContext]</code>.</p>"},{"location":"reference/hooks/#tanjun.hooks.Hooks","title":"Hooks","text":"<p>         Bases: <code>tanjun.Hooks[_ContextT_contra]</code></p> <p>Standard implementation of tanjun.abc.Hooks used for command execution.</p> <p>This will take either tanjun.abc.Context, tanjun.abc.MessageContext or tanjun.abc.SlashContext dependent on what its bound by (generic wise).</p> <p>Note</p> <p>This implementation adds a concept of parser errors which won't be dispatched to general \"error\" hooks and do not share the error suppression semantics as they favour to always suppress the error if a registered handler is found.</p>"},{"location":"reference/hooks/#tanjun.hooks.Hooks.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> <p>Initialise a command hook object.</p>"},{"location":"reference/hooks/#tanjun.hooks.Hooks.add_to_command","title":"add_to_command","text":"<pre><code>add_to_command(command)\n</code></pre> <p>Add this hook object to a command.</p> <p>Note</p> <p>This will likely override any previously added hooks.</p> <p>Examples:</p> <p>This method may be used as a command decorator:</p> <pre><code>@standard_hooks.add_to_command\n@as_message_command(\"command\")\nasync def command_command(ctx: tanjun.abc.Context) -&gt; None:\n    await ctx.respond(\"You've called a command!\")\n</code></pre> PARAMETER DESCRIPTION <code>command</code> <p>The command to add the hooks to.</p> <p> TYPE: <code>tanjun.abc.ExecutableCommand</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.ExecutableCommand</code> <p>The command with the hooks added.</p>"},{"location":"reference/hooks/#tanjun.hooks.Hooks.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Copy this hook object.</p>"},{"location":"reference/hooks/#tanjun.hooks.Hooks.set_on_error","title":"set_on_error","text":"<pre><code>set_on_error(callback)\n</code></pre> <p>Set the error callback for this hook object.</p> <p>Note</p> <p>This will not be called for tanjun.ParserErrors as these are generally speaking expected. To handle those see Hooks.set_on_parser_error.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to set for this hook. This will remove any previously set callbacks.</p> <p>This callback should take two positional arguments (of type tanjun.abc.Context and Exception) and may be either synchronous or asynchronous.</p> <p>Returning True indicates that the error should be suppressed, False that it should be re-raised and None that no decision has been made. This will be accounted for along with the decisions other error hooks make by majority rule.</p> <p> TYPE: <code>typing.Optional[tanjun.ErrorHookSig[_ContextT_contra]]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The hook object to enable method chaining.</p>"},{"location":"reference/hooks/#tanjun.hooks.Hooks.set_on_parser_error","title":"set_on_parser_error","text":"<pre><code>set_on_parser_error(callback)\n</code></pre> <p>Set the parser error callback for this hook object.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to set for this hook. This will remove any previously set callbacks.</p> <p>This callback should take two positional arguments (of type tanjun.abc.Context and tanjun.ParserError), return None and may be either synchronous or asynchronous.</p> <p>It's worth noting that, unlike general error handlers, this will always suppress the error.</p> <p> TYPE: <code>typing.Optional[tanjun.ParserHookSig[_ContextT_contra]]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The hook object to enable method chaining.</p>"},{"location":"reference/hooks/#tanjun.hooks.Hooks.set_on_success","title":"set_on_success","text":"<pre><code>set_on_success(callback)\n</code></pre> <p>Set the success callback for this hook object.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to set for this hook. This will remove any previously set callbacks.</p> <p>This callback should take one positional argument (of type tanjun.abc.Context), return None and may be either synchronous or asynchronous.</p> <p> TYPE: <code>typing.Optional[tanjun.HookSig[_ContextT_contra]]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The hook object to enable method chaining.</p>"},{"location":"reference/hooks/#tanjun.hooks.Hooks.set_post_execution","title":"set_post_execution","text":"<pre><code>set_post_execution(callback)\n</code></pre> <p>Set the post-execution callback for this hook object.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to set for this hook. This will remove any previously set callbacks.</p> <p>This callback should take one positional argument (of type tanjun.abc.Context), return None and may be either synchronous or asynchronous.</p> <p> TYPE: <code>typing.Optional[tanjun.HookSig[_ContextT_contra]]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The hook object to enable method chaining.</p>"},{"location":"reference/hooks/#tanjun.hooks.Hooks.set_pre_execution","title":"set_pre_execution","text":"<pre><code>set_pre_execution(callback)\n</code></pre> <p>Set the pre-execution callback for this hook object.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to set for this hook. This will remove any previously set callbacks.</p> <p>This callback should take one positional argument (of type tanjun.abc.Context), return None and may be either synchronous or asynchronous.</p> <p> TYPE: <code>typing.Optional[tanjun.HookSig[_ContextT_contra]]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The hook object to enable method chaining.</p>"},{"location":"reference/parsing/","title":"tanjun.parsing","text":"<p>Standard implementation of message command argument parsing.</p>"},{"location":"reference/parsing/#tanjun.parsing.ConverterSig","title":"ConverterSig  <code>module-attribute</code>","text":"<pre><code>ConverterSig = _ConverterSig[Ellipsis, _T]\n</code></pre> <p>Type hint of a converter used within a parser instance.</p> <p>This represents the signatures <code>def (str, ...) -&gt; Any</code> and <code>async def (str, ...) -&gt; Any</code> where dependency injection is supported.</p>"},{"location":"reference/parsing/#tanjun.parsing.UNDEFINED","title":"UNDEFINED  <code>module-attribute</code>","text":"<pre><code>UNDEFINED = tanjun.NO_DEFAULT\n</code></pre> <p>Deprecated alias of tanjun.abc.NO_DEFAULT.</p>"},{"location":"reference/parsing/#tanjun.parsing.UNDEFINED_DEFAULT","title":"UNDEFINED_DEFAULT  <code>module-attribute</code>","text":"<pre><code>UNDEFINED_DEFAULT = tanjun.NO_DEFAULT\n</code></pre> <p>Deprecated alias of tanjun.abc.NO_DEFAULT.</p>"},{"location":"reference/parsing/#tanjun.parsing.UndefinedDefaultT","title":"UndefinedDefaultT  <code>module-attribute</code>","text":"<pre><code>UndefinedDefaultT = typing.Literal[tanjun.NO_DEFAULT]\n</code></pre> <p>Deprecated alias of <code>typing.Literal[tanjun.abc.NO_DEFAULT]</code>.</p>"},{"location":"reference/parsing/#tanjun.parsing.UndefinedT","title":"UndefinedT  <code>module-attribute</code>","text":"<pre><code>UndefinedT = typing.Literal[tanjun.NO_DEFAULT]\n</code></pre> <p>Deprecated alias of <code>typing.Literal[tanjun.abc.NO_DEFAULT]</code>.</p>"},{"location":"reference/parsing/#tanjun.parsing.AbstractOptionParser","title":"AbstractOptionParser","text":"<p>         Bases: <code>tanjun.MessageParser</code>, <code>abc.ABC</code></p> <p>Abstract interface of a message content parser.</p>"},{"location":"reference/parsing/#tanjun.parsing.AbstractOptionParser.arguments","title":"arguments  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>arguments: collections.Sequence[Argument]\n</code></pre> <p>Sequence of the positional arguments registered with this parser.</p>"},{"location":"reference/parsing/#tanjun.parsing.AbstractOptionParser.options","title":"options  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>options: collections.Sequence[Option]\n</code></pre> <p>Sequence of the named options registered with this parser.</p>"},{"location":"reference/parsing/#tanjun.parsing.AbstractOptionParser.add_argument","title":"add_argument  <code>abstractmethod</code>","text":"<pre><code>add_argument(key, /, converters=(), *, default=tanjun.NO_DEFAULT, greedy=False, min_length=None, max_length=None, min_value=None, max_value=None, multi=False)\n</code></pre> <p>Add a positional argument type to the parser..</p> <p>Note</p> <p>Order matters for positional arguments.</p> PARAMETER DESCRIPTION <code>key</code> <p>The string identifier of this argument (may be used to pass the result of this argument to the command's callback during execution).</p> <p> TYPE: <code>str</code> </p> <code>converters</code> <p>The converter(s) this argument should use to handle values passed to it during parsing.</p> <p>If no converters are provided then the raw string value will be passed.</p> <p>Only the first converter to pass will be used.</p> <p> TYPE: <code>_MaybeIterable[ConverterSig[typing.Any]]</code> DEFAULT: <code>()</code> </p> <code>default</code> <p>The default value of this argument, if left as tanjun.abc.NO_DEFAULT then this will have no default.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>greedy</code> <p>Whether or not this argument should be greedy (meaning that it takes in the remaining argument values).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>min_length</code> <p>Assert that a string argument's length is greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>max_length</code> <p>Assert that a string argument's length is less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>min_value</code> <p>Assert that the parsed value(s) for this argument are greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> <code>max_value</code> <p>Assert that the parsed value(s) for this argument are less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> <code>multi</code> <p>Whether this argument can be passed multiple times.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This parser to enable chained calls.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>key</code> isn't valid for any of the commands this parser is linked to where <code>validate_arg_keys</code> is True.</p>"},{"location":"reference/parsing/#tanjun.parsing.AbstractOptionParser.add_option","title":"add_option  <code>abstractmethod</code>","text":"<pre><code>add_option(key, name, /, *names, converters=(), default, empty_value=tanjun.NO_DEFAULT, min_length=None, max_length=None, min_value=None, max_value=None, multi=False)\n</code></pre> <p>Add an named option to this parser.</p> PARAMETER DESCRIPTION <code>key</code> <p>The string identifier of this option which will be used to pass the result of this option to the command's callback during execution as a keyword argument.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>The name of this option used for identifying it in the parsed content.</p> <p> TYPE: <code>str</code> </p> <code>*names</code> <p>Other names of this option used for identifying it in the parsed content.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>default</code> <p>The default value of this option, unlike arguments this is required for options.</p> <p> TYPE: <code>typing.Any</code> </p> <code>converters</code> <p>The converter(s) this option should use to handle values passed to it during parsing.</p> <p>If no converters are provided then the raw string value will be passed.</p> <p>Only the first converter to pass will be used.</p> <p> TYPE: <code>_MaybeIterable[ConverterSig[typing.Any]]</code> DEFAULT: <code>()</code> </p> <code>empty_value</code> <p>The value to use if this option is provided without a value.</p> <p>If left as tanjun.abc.NO_DEFAULT then this option will error if it's provided without a value.</p> <p>tanjun.abc.NO_PASS is not supported for this.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>min_length</code> <p>Assert that a string argument's length is greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>max_length</code> <p>Assert that a string argument's length is less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>min_value</code> <p>Assert that the parsed value(s) for this option are greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> <code>max_value</code> <p>Assert that the parsed value(s) for this option are less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> <code>multi</code> <p>If this option can be provided multiple times.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>This parser to enable chained calls.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>key</code> isn't valid for any of the commands this parser is linked to where <code>validate_arg_keys</code> is True.</p>"},{"location":"reference/parsing/#tanjun.parsing.AbstractParser","title":"AbstractParser","text":"<p>         Bases: <code>AbstractOptionParser</code></p> <p>Deprecated alias of AbstractOptionParser.</p>"},{"location":"reference/parsing/#tanjun.parsing.Argument","title":"Argument","text":"<p>         Bases: <code>Parameter</code></p> <p>Representation of a positional argument used by the standard parser.</p>"},{"location":"reference/parsing/#tanjun.parsing.Argument.is_greedy","title":"is_greedy  <code>property</code>","text":"<pre><code>is_greedy: bool\n</code></pre> <p>Whether this parameter is greedy.</p> <p>Greedy parameters will consume the remaining message content as one string (with converters also being passed the whole string).</p> <p>Note</p> <p>Greedy and multi parameters cannot be used together.</p>"},{"location":"reference/parsing/#tanjun.parsing.Argument.__init__","title":"__init__","text":"<pre><code>__init__(key, /, *, converters=(), default=tanjun.NO_DEFAULT, greedy=False, min_length=None, max_length=None, min_value=None, max_value=None, multi=False)\n</code></pre> <p>Initialise a positional argument.</p> PARAMETER DESCRIPTION <code>key</code> <p>The string identifier of this argument (may be used to pass the result of this argument to the command's callback during execution).</p> <p> TYPE: <code>str</code> </p> <code>converters</code> <p>The converter(s) this argument should use to handle values passed to it during parsing.</p> <p>If no converters are provided then the raw string value will be passed.</p> <p>Only the first converter to pass will be used.</p> <p> TYPE: <code>_MaybeIterable[ConverterSig[typing.Any]]</code> DEFAULT: <code>()</code> </p> <code>default</code> <p>The default value of this argument, if left as tanjun.abc.NO_DEFAULT then this will have no default.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>greedy</code> <p>Whether or not this argument should be greedy (meaning that it takes in the remaining argument values).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>min_length</code> <p>Assert that a string argument's length is greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>max_length</code> <p>Assert that a string argument's length is less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>min_value</code> <p>Assert that the parsed value(s) for this option are greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> <code>max_value</code> <p>Assert that the parsed value(s) for this option are less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> <p>multi     Whether this argument can be passed multiple times.</p>"},{"location":"reference/parsing/#tanjun.parsing.Option","title":"Option","text":"<p>         Bases: <code>Parameter</code></p> <p>Representation of a named optional parameter used by the standard parser.</p>"},{"location":"reference/parsing/#tanjun.parsing.Option.empty_value","title":"empty_value  <code>property</code>","text":"<pre><code>empty_value: typing.Any\n</code></pre> <p>The value to return if the option is empty.</p> <p>If this is tanjun.abc.NO_DEFAULT then a value will be required for the option.</p>"},{"location":"reference/parsing/#tanjun.parsing.Option.names","title":"names  <code>property</code>","text":"<pre><code>names: collections.Sequence[str]\n</code></pre> <p>Sequence of the CLI names of this option.</p>"},{"location":"reference/parsing/#tanjun.parsing.Option.__init__","title":"__init__","text":"<pre><code>__init__(key, name, /, *names, converters=(), default, empty_value=tanjun.NO_DEFAULT, min_length=None, max_length=None, min_value=None, max_value=None, multi=True)\n</code></pre> <p>Initialise a named optional parameter.</p> PARAMETER DESCRIPTION <code>key</code> <p>The string identifier of this option which will be used to pass the result of this argument to the command's callback during execution as a keyword argument.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>The name of this option used for identifying it in the parsed content.</p> <p> TYPE: <code>str</code> </p> <code>*names</code> <p>Other names of this option used for identifying it in the parsed content.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>default</code> <p>The default value of this argument, unlike arguments this is required for options.</p> <p> TYPE: <code>typing.Any</code> </p> <code>converters</code> <p>The converter(s) this argument should use to handle values passed to it during parsing.</p> <p>If no converters are provided then the raw string value will be passed.</p> <p>Only the first converter to pass will be used.</p> <p> TYPE: <code>_MaybeIterable[ConverterSig[typing.Any]]</code> DEFAULT: <code>()</code> </p> <code>empty_value</code> <p>The value to use if this option is provided without a value.</p> <p>If left as tanjun.abc.NO_DEFAULT then this option will error if it's provided without a value.</p> <p>tanjun.abc.NO_PASS is not supported for this.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>min_length</code> <p>Assert that a string argument's length is greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>max_length</code> <p>Assert that a string argument's length is less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>min_value</code> <p>Assert that the parsed value(s) for this option are greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> <code>max_value</code> <p>Assert that the parsed value(s) for this option are less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> <p>multi     If this option can be provided multiple times.</p>"},{"location":"reference/parsing/#tanjun.parsing.Parameter","title":"Parameter","text":"<p>Base class for parameters for the standard parser(s).</p>"},{"location":"reference/parsing/#tanjun.parsing.Parameter.converters","title":"converters  <code>property</code>","text":"<pre><code>converters: collections.Sequence[ConverterSig[typing.Any]]\n</code></pre> <p>Sequence of the converters registered for this parameter.</p>"},{"location":"reference/parsing/#tanjun.parsing.Parameter.default","title":"default  <code>property</code>","text":"<pre><code>default: typing.Any\n</code></pre> <p>The parameter's default.</p> <p>If this is tanjun.abc.NO_DEFAULT then this parameter is required.</p> <p>If this is tanjun.abc.NO_PASS then the parameter won't be passed when no value was provided.</p>"},{"location":"reference/parsing/#tanjun.parsing.Parameter.is_multi","title":"is_multi  <code>property</code>","text":"<pre><code>is_multi: bool\n</code></pre> <p>Whether this parameter is \"multi\".</p> <p>Multi parameters will be passed a list of all the values provided for this parameter (with each entry being converted separately.)</p>"},{"location":"reference/parsing/#tanjun.parsing.Parameter.key","title":"key  <code>property</code>","text":"<pre><code>key: str\n</code></pre> <p>The key of this parameter used to pass the result to the command's callback.</p>"},{"location":"reference/parsing/#tanjun.parsing.Parameter.max_length","title":"max_length  <code>property</code>","text":"<pre><code>max_length: typing.Optional[int]\n</code></pre> <p>If set, this parameters's parsed values will have to have lengths less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p>"},{"location":"reference/parsing/#tanjun.parsing.Parameter.max_value","title":"max_value  <code>property</code>","text":"<pre><code>max_value: typing.Optional[_CmpProto[typing.Any]]\n</code></pre> <p>If set, this parameters's parsed values will have to be less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p>"},{"location":"reference/parsing/#tanjun.parsing.Parameter.min_length","title":"min_length  <code>property</code>","text":"<pre><code>min_length: typing.Optional[int]\n</code></pre> <p>If set, this parameters's parsed values will have to have lengths greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p>"},{"location":"reference/parsing/#tanjun.parsing.Parameter.min_value","title":"min_value  <code>property</code>","text":"<pre><code>min_value: typing.Optional[_CmpProto[typing.Any]]\n</code></pre> <p>If set, this parameters's parsed values will have to be greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p>"},{"location":"reference/parsing/#tanjun.parsing.Parameter.__init__","title":"__init__","text":"<pre><code>__init__(key, /, *, converters=(), default=tanjun.NO_DEFAULT, min_length=None, max_length=None, min_value=None, max_value=None, multi=False)\n</code></pre> <p>Initialise a parameter.</p>"},{"location":"reference/parsing/#tanjun.parsing.Parameter.convert","title":"convert  <code>async</code>","text":"<pre><code>convert(ctx, value)\n</code></pre> <p>Convert the given value to the type of this parameter.</p>"},{"location":"reference/parsing/#tanjun.parsing.Parameter.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Copy the parameter.</p> RETURNS DESCRIPTION <code>Self</code> <p>A copy of the parameter.</p>"},{"location":"reference/parsing/#tanjun.parsing.ShlexParser","title":"ShlexParser","text":"<p>         Bases: <code>AbstractOptionParser</code></p> <p>A shlex based AbstractOptionParser implementation.</p>"},{"location":"reference/parsing/#tanjun.parsing.ShlexParser.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> <p>Initialise a shlex parser.</p>"},{"location":"reference/parsing/#tanjun.parsing.with_argument","title":"with_argument","text":"<pre><code>with_argument(key, /, converters=(), *, default=tanjun.NO_DEFAULT, greedy=False, min_length=None, max_length=None, min_value=None, max_value=None, multi=False)\n</code></pre> <p>Add an argument to a message command through a decorator call.</p> <p>Warning</p> <p>Since order matters for positional arguments, you'll want to keep in mind that decorator execution starts at the decorator closest to the command and goes upwards with this deciding where a positional argument is located in a command's signature.</p> <p>Note</p> <p>If no parser is explicitly set on the command this is decorating before this decorator call then this will set ShlexParser as the parser.</p> <p>Examples:</p> <pre><code>import tanjun\n\n@tanjun.parsing.with_argument(\"command\", converters=int, default=42)\n@tanjun.parsing.with_parser\n@tanjun.component.as_message_command(\"command\")\nasync def command(self, ctx: tanjun.abc.Context, /, argument: int):\n    ...\n</code></pre> PARAMETER DESCRIPTION <code>key</code> <p>The string identifier of this argument (may be used to pass the result of this argument to the command's callback during execution).</p> <p> TYPE: <code>str</code> </p> <code>converters</code> <p>The converter(s) this argument should use to handle values passed to it during parsing.</p> <p>If no converters are provided then the raw string value will be passed.</p> <p>Only the first converter to pass will be used.</p> <p> TYPE: <code>_MaybeIterable[ConverterSig[typing.Any]]</code> DEFAULT: <code>()</code> </p> <code>default</code> <p>The default value of this argument, if left as tanjun.abc.NO_DEFAULT then this will have no default.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>greedy</code> <p>Whether or not this argument should be greedy (meaning that it takes in the remaining argument values).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>min_length</code> <p>Assert that a string argument's length is greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>max_length</code> <p>Assert that a string argument's length is less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>min_value</code> <p>Assert that the parsed value(s) for this argument are greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> <code>max_value</code> <p>Assert that the parsed value(s) for this argument are less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> <p>multi     Whether this argument can be passed multiple times.</p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MessageCommand], tanjun.abc.MessageCommand]</code> <p>Decorator function for the message command this argument is being added to.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>key</code> isn't valid for any of the commands this command's parser is linked to where <code>validate_arg_keys</code> is True.</p>"},{"location":"reference/parsing/#tanjun.parsing.with_greedy_argument","title":"with_greedy_argument","text":"<pre><code>with_greedy_argument(key, /, converters=(), *, default=tanjun.NO_DEFAULT, min_length=None, max_length=None, min_value=None, max_value=None)\n</code></pre> <p>Add a greedy argument to a message command through a decorator call.</p> <p>A greedy argument will consume the remaining positional arguments and pass them through to the converters as one joined string while also requiring that at least one more positional argument is remaining unless a default is set.</p> <p>Warning</p> <p>Since order matters for positional arguments, you'll want to keep in mind that decorator execution starts at the decorator closest to the command and goes upwards with this deciding where a positional argument is located in a command's signature.</p> <p>Note</p> <p>If no parser is explicitly set on the command this is decorating before this decorator call then this will set ShlexParser as the parser.</p> <p>Examples:</p> <pre><code>import tanjun\n\n@tanjun.parsing.with_greedy_argument(\"command\", converters=StringView)\n@tanjun.parsing.with_parser\n@tanjun.component.as_message_command(\"command\")\nasync def command(self, ctx: tanjun.abc.Context, /, argument: StringView):\n    ...\n</code></pre> PARAMETER DESCRIPTION <code>key</code> <p>The string identifier of this argument (may be used to pass the result of this argument to the command's callback during execution).</p> <p> TYPE: <code>str</code> </p> <code>converters</code> <p>The converter(s) this argument should use to handle values passed to it during parsing.</p> <p>If no converters are provided then the raw string value will be passed.</p> <p>Only the first converter to pass will be used.</p> <p> TYPE: <code>_MaybeIterable[ConverterSig[typing.Any]]</code> DEFAULT: <code>()</code> </p> <code>default</code> <p>The default value of this argument, if left as tanjun.abc.NO_DEFAULT then this will have no default.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>min_length</code> <p>Assert that a string argument's length is greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>max_length</code> <p>Assert that a string argument's length is less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>min_value</code> <p>Assert that the parsed value(s) for this argument are greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> <code>max_value</code> <p>Assert that the parsed value(s) for this argument are less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MessageCommand], tanjun.abc.MessageCommand]</code> <p>Decorator function for the message command this argument is being added to.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>key</code> isn't valid for any of the commands this command's parser is linked to where <code>validate_arg_keys</code> is True.</p>"},{"location":"reference/parsing/#tanjun.parsing.with_multi_argument","title":"with_multi_argument","text":"<pre><code>with_multi_argument(key, /, converters=(), *, default=tanjun.NO_DEFAULT, min_length=None, max_length=None, min_value=None, max_value=None)\n</code></pre> <p>Add a multi-argument to a message command through a decorator call.</p> <p>A multi argument will consume the remaining positional arguments and pass them to the converters through multiple calls while also requiring that at least one more positional argument is remaining unless a default is set and passing through the results to the command's callback as a sequence.</p> <p>Warning</p> <p>Since order matters for positional arguments, you'll want to keep in mind that decorator execution starts at the decorator closest to the command and goes upwards with this deciding where a positional argument is located in a command's signature.</p> <p>Note</p> <p>If no parser is explicitly set on the command this is decorating before this decorator call then this will set ShlexParser as the parser.</p> <p>Examples:</p> <pre><code>import tanjun\n\n@tanjun.parsing.with_multi_argument(\"command\", converters=int)\n@tanjun.parsing.with_parser\n@tanjun.component.as_message_command(\"command\")\nasync def command(self, ctx: tanjun.abc.Context, /, argument: collections.abc.Sequence[int]):\n    ...\n</code></pre> PARAMETER DESCRIPTION <code>key</code> <p>The string identifier of this argument (may be used to pass the result of this argument to the command's callback during execution).</p> <p> TYPE: <code>str</code> </p> <code>converters</code> <p>The converter(s) this argument should use to handle values passed to it during parsing.</p> <p>If no converters are provided then the raw string value will be passed.</p> <p>Only the first converter to pass will be used.</p> <p> TYPE: <code>_MaybeIterable[ConverterSig[typing.Any]]</code> DEFAULT: <code>()</code> </p> <code>default</code> <p>The default value of this argument, if left as tanjun.abc.NO_DEFAULT then this will have no default.</p> <p>If this is tanjun.abc.NO_PASS then the <code>key</code> parameter won't be passed when no value was provided.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>min_length</code> <p>Assert that a string argument's length is greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>max_length</code> <p>Assert that a string argument's length is less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>min_value</code> <p>Assert that the parsed value(s) for this argument are greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> <code>max_value</code> <p>Assert that the parsed value(s) for this argument are less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MessageCommand], tanjun.abc.MessageCommand]</code> <p>Decorator function for the message command this argument is being added to.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>key</code> isn't valid for any of the commands this command's parser is linked to where <code>validate_arg_keys</code> is True.</p>"},{"location":"reference/parsing/#tanjun.parsing.with_multi_option","title":"with_multi_option","text":"<pre><code>with_multi_option(key, name, /, *names, converters=(), default, empty_value=tanjun.NO_DEFAULT, min_length=None, max_length=None, min_value=None, max_value=None)\n</code></pre> <p>Add an multi-option to a command's parser through a decorator call.</p> <p>A multi option will consume all the values provided for an option and pass them through to the converters as an array of strings while also requiring that at least one value is provided for the option unless a default is set.</p> <p>Note</p> <p>If no parser is explicitly set on the command this is decorating before this decorator call then this will set ShlexParser as the parser.</p> <p>Examples:</p> <pre><code>import tanjun\n\n@tanjun.parsing.with_multi_option(\"command\", converters=int, default=())\n@tanjun.parsing.with_parser\n@tanjun.component.as_message_command(\"command\")\nasync def command(self, ctx: tanjun.abc.Context, /, argument: collections.abc.Sequence[int]):\n    ...\n</code></pre> PARAMETER DESCRIPTION <code>key</code> <p>The string identifier of this option which will be used to pass the result of this argument to the command's callback during execution as a keyword argument.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>The name of this option used for identifying it in the parsed content.</p> <p> TYPE: <code>str</code> </p> <code>*names</code> <p>Other names of this option used for identifying it in the parsed content.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>default</code> <p>The default value of this argument, unlike arguments this is required for options.</p> <p> TYPE: <code>typing.Any</code> </p> <code>converters</code> <p>The converter(s) this argument should use to handle values passed to it during parsing.</p> <p>If no converters are provided then the raw string value will be passed.</p> <p>Only the first converter to pass will be used.</p> <p> TYPE: <code>_MaybeIterable[ConverterSig[typing.Any]]</code> DEFAULT: <code>()</code> </p> <code>empty_value</code> <p>The value to use if this option is provided without a value.</p> <p>If left as tanjun.abc.NO_DEFAULT then this option will error if it's provided without a value.</p> <p>tanjun.abc.NO_PASS is not supported for this.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>min_length</code> <p>Assert that a string argument's length is greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>max_length</code> <p>Assert that a string argument's length is less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>min_value</code> <p>Assert that the parsed value(s) for this option are greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> <code>max_value</code> <p>Assert that the parsed value(s) for this option are less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MessageCommand], tanjun.abc.MessageCommand]</code> <p>Decorator function for the message command this option is being added to.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>key</code> isn't valid for any of the commands this command's parser is linked to where <code>validate_arg_keys</code> is True.</p>"},{"location":"reference/parsing/#tanjun.parsing.with_option","title":"with_option","text":"<pre><code>with_option(key, name, /, *names, converters=(), default, empty_value=tanjun.NO_DEFAULT, min_length=None, max_length=None, min_value=None, max_value=None, multi=False)\n</code></pre> <p>Add an option to a message command through a decorator call.</p> <p>Note</p> <p>If no parser is explicitly set on the command this is decorating before this decorator call then this will set ShlexParser as the parser.</p> <p>Examples:</p> <pre><code>import tanjun\n\n@tanjun.parsing.with_option(\"command\", converters=int, default=42)\n@tanjun.parsing.with_parser\n@tanjun.component.as_message_command(\"command\")\nasync def command(self, ctx: tanjun.abc.Context, /, argument: int):\n    ...\n</code></pre> PARAMETER DESCRIPTION <code>key</code> <p>The string identifier of this option which will be used to pass the result of this argument to the command's callback during execution as a keyword argument.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>The name of this option used for identifying it in the parsed content.</p> <p> TYPE: <code>str</code> </p> <code>*names</code> <p>Other names of this option used for identifying it in the parsed content.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>default</code> <p>The default value of this argument, unlike arguments this is required for options.</p> <p> TYPE: <code>typing.Any</code> </p> <code>converters</code> <p>The converter(s) this argument should use to handle values passed to it during parsing.</p> <p>If no converters are provided then the raw string value will be passed.</p> <p>Only the first converter to pass will be used.</p> <p> TYPE: <code>_MaybeIterable[ConverterSig[typing.Any]]</code> DEFAULT: <code>()</code> </p> <code>empty_value</code> <p>The value to use if this option is provided without a value.</p> <p>If left as tanjun.abc.NO_DEFAULT then this option will error if it's provided without a value.</p> <p>tanjun.abc.NO_PASS is not supported for this.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>tanjun.NO_DEFAULT</code> </p> <code>min_length</code> <p>Assert that a string argument's length is greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>max_length</code> <p>Assert that a string argument's length is less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> <code>min_value</code> <p>Assert that the parsed value(s) for this option are greater than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> <code>max_value</code> <p>Assert that the parsed value(s) for this option are less than or equal to this.</p> <p>If any converters are provided then this should be compatible with the result of them.</p> <p> TYPE: <code>typing.Optional[_CmpProto[typing.Any]]</code> DEFAULT: <code>None</code> </p> <code>multi</code> <p>If this option can be provided multiple times.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[[tanjun.abc.MessageCommand], tanjun.abc.MessageCommand]</code> <p>Decorator function for the message command this option is being added to.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>key</code> isn't valid for any of the commands this command's parser is linked to where <code>validate_arg_keys</code> is True.</p>"},{"location":"reference/parsing/#tanjun.parsing.with_parser","title":"with_parser","text":"<pre><code>with_parser(command)\n</code></pre> <p>Add a shlex parser command parser to a supported command.</p>"},{"location":"reference/parsing/#tanjun.parsing.with_parser--example","title":"Example","text":"<pre><code>@tanjun.with_argument(\"arg\", converters=int)\n@tanjun.with_parser\n@tanjun.as_message_command(\"hi\")\nasync def hi(ctx: tanjun.MessageContext, arg: int) -&gt; None:\n    ...\n</code></pre> PARAMETER DESCRIPTION <code>command</code> <p>The message command to set the parser on.</p> <p> TYPE: <code>_CommandT</code> </p> RETURNS DESCRIPTION <code>tanjun.abc.MessageCommand</code> <p>The command with the parser set.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the command already has a parser set.</p>"},{"location":"reference/permissions/","title":"tanjun.permissions","text":"<p>Functions used to calculate permissions in Tanjun.</p>"},{"location":"reference/permissions/#tanjun.permissions.ALL_PERMISSIONS","title":"ALL_PERMISSIONS  <code>module-attribute</code>","text":"<pre><code>ALL_PERMISSIONS: typing.Final[hikari.Permissions] = hikari.Permissions.all_permissions()\n</code></pre> <p>All of all the known permissions based on the linked version of Hikari.</p>"},{"location":"reference/permissions/#tanjun.permissions.DM_PERMISSIONS","title":"DM_PERMISSIONS  <code>module-attribute</code>","text":"<pre><code>DM_PERMISSIONS: typing.Final[hikari.Permissions] = hikari.Permissions.ADD_REACTIONS | hikari.Permissions.VIEW_CHANNEL | hikari.Permissions.SEND_MESSAGES | hikari.Permissions.EMBED_LINKS | hikari.Permissions.ATTACH_FILES | hikari.Permissions.READ_MESSAGE_HISTORY | hikari.Permissions.USE_EXTERNAL_EMOJIS | hikari.Permissions.USE_EXTERNAL_STICKERS | hikari.Permissions.USE_APPLICATION_COMMANDS\n</code></pre> <p>Bitfield of the permissions which are accessibly within DM channels.</p>"},{"location":"reference/permissions/#tanjun.permissions.calculate_everyone_permissions","title":"calculate_everyone_permissions","text":"<pre><code>calculate_everyone_permissions(everyone_role, /, *, channel=None)\n</code></pre> <p>Calculate a guild's default permissions within the guild or for a specific channel.</p> PARAMETER DESCRIPTION <code>everyone_role</code> <p>The guild's default @everyone role.</p> <p> TYPE: <code>hikari.Role</code> </p> <code>channel</code> <p>The channel to calculate the permissions for.</p> <p>If this is left as None then this will just calculate the default permissions on a guild level.</p> <p> TYPE: <code>typing.Optional[hikari.PermissibleGuildChannel]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>hikari.Permissions</code> <p>The calculated permissions.</p>"},{"location":"reference/permissions/#tanjun.permissions.calculate_permissions","title":"calculate_permissions","text":"<pre><code>calculate_permissions(member, guild, roles, /, *, channel=None)\n</code></pre> <p>Calculate the permissions a member has within a guild.</p> PARAMETER DESCRIPTION <code>member</code> <p>Object of the member to calculate the permissions for.</p> <p> TYPE: <code>hikari.Member</code> </p> <code>guild</code> <p>Object of the guild to calculate their permissions within.</p> <p> TYPE: <code>hikari.Guild</code> </p> <code>roles</code> <p>Mapping of snowflake IDs to objects of the roles within the target guild.</p> <p> TYPE: <code>collections.Mapping[hikari.Snowflake, hikari.Role]</code> </p> <code>channel</code> <p>Object of the channel to calculate the member's permissions in.</p> <p>If this is left as None then this will just calculate their permissions on a guild level.</p> <p> TYPE: <code>typing.Optional[hikari.PermissibleGuildChannel]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>hikari.Permission</code> <p>Value of the member's permissions either within the guild or specified guild channel.</p>"},{"location":"reference/permissions/#tanjun.permissions.fetch_everyone_permissions","title":"fetch_everyone_permissions  <code>async</code>","text":"<pre><code>fetch_everyone_permissions(client, guild_id, /, *, channel=None)\n</code></pre> <p>Calculate the permissions a guild's default @everyone role has within a guild or for a specific channel.</p> <p>Note</p> <p>This callback will fallback to REST requests if cache lookups fail or are not possible.</p> PARAMETER DESCRIPTION <code>client</code> <p>The Tanjun client to use for lookups.</p> <p> TYPE: <code>tanjun.Client</code> </p> <code>guild_id</code> <p>ID of the guild to calculate the default permissions for.</p> <p> TYPE: <code>hikari.Snowflake</code> </p> <code>channel</code> <p>The channel to calculate the permissions for.</p> <p>If this is left as None then this will just calculate the default permissions on a guild level.</p> <p> TYPE: <code>typing.Optional[hikari.SnowflakeishOr[hikari.GuildChannel]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>hikari.Permissions</code> <p>The calculated permissions.</p>"},{"location":"reference/permissions/#tanjun.permissions.fetch_permissions","title":"fetch_permissions  <code>async</code>","text":"<pre><code>fetch_permissions(client, member, /, *, channel=None)\n</code></pre> <p>Calculate the permissions a member has within a guild.</p> <p>Note</p> <p>This callback will fallback to REST requests if cache lookups fail or are not possible.</p> PARAMETER DESCRIPTION <code>client</code> <p>The Tanjun client to use for lookups.</p> <p> TYPE: <code>tanjun.Client</code> </p> <code>member</code> <p>The object of the member to calculate the permissions for.</p> <p> TYPE: <code>hikari.Member</code> </p> <code>channel</code> <p>The object or ID of the channel to get their permissions in. If left as None then this will return their base guild permissions.</p> <p> TYPE: <code>typing.Optional[hikari.SnowflakeishOr[hikari.GuildChannel]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>hikari.Permissions</code> <p>The calculated permissions.</p>"},{"location":"reference/schedules/","title":"tanjun.schedules","text":"<p>Interface and interval implementation for a Tanjun based callback scheduler.</p>"},{"location":"reference/schedules/#tanjun.schedules.AbstractSchedule","title":"AbstractSchedule","text":"<p>         Bases: <code>abc.ABC</code></p> <p>Abstract callback schedule class.</p>"},{"location":"reference/schedules/#tanjun.schedules.AbstractSchedule.callback","title":"callback  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>callback: _CallbackSig\n</code></pre> <p>Return the callback attached to the schedule.</p> <p>This will be an asynchronous function which takes zero positional arguments, returns None and may be relying on dependency injection.</p>"},{"location":"reference/schedules/#tanjun.schedules.AbstractSchedule.is_alive","title":"is_alive  <code>property</code> <code>abstractmethod</code>","text":"<pre><code>is_alive: bool\n</code></pre> <p>Whether the schedule is alive.</p>"},{"location":"reference/schedules/#tanjun.schedules.AbstractSchedule.copy","title":"copy  <code>abstractmethod</code>","text":"<pre><code>copy()\n</code></pre> <p>Copy the schedule.</p> RETURNS DESCRIPTION <code>Self</code> <p>The copied schedule.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the schedule is active.</p>"},{"location":"reference/schedules/#tanjun.schedules.AbstractSchedule.force_stop","title":"force_stop  <code>abstractmethod</code>","text":"<pre><code>force_stop()\n</code></pre> <p>Stop the schedule while cancelling any active tasks.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the schedule is not active.</p>"},{"location":"reference/schedules/#tanjun.schedules.AbstractSchedule.start","title":"start  <code>abstractmethod</code>","text":"<pre><code>start(client, /, *, loop=None)\n</code></pre> <p>Start the schedule.</p> PARAMETER DESCRIPTION <code>client</code> <p>The injector client calls should be resolved with.</p> <p> TYPE: <code>alluka.Client</code> </p> <code>loop</code> <p>The event loop to use. If not provided, the current event loop will be used.</p> <p> TYPE: <code>typing.Optional[asyncio.AbstractEventLoop]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the scheduled callback is already running. If the current or provided event loop isn't running.</p>"},{"location":"reference/schedules/#tanjun.schedules.AbstractSchedule.stop","title":"stop  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>stop()\n</code></pre> <p>Stop the schedule after waiting for any existing tasks to finish.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the scheduled callback isn't running.</p>"},{"location":"reference/schedules/#tanjun.schedules.IntervalSchedule","title":"IntervalSchedule","text":"<p>         Bases: <code>typing.Generic[_CallbackSigT]</code>, <code>components.AbstractComponentLoader</code>, <code>AbstractSchedule</code></p> <p>A callback schedule with an interval between calls.</p> <p>This should be loaded into a component using either Component.load_from_scope, Component.add_schedule or Component.with_schedule, and will be started and stopped with the linked tanjun client.</p>"},{"location":"reference/schedules/#tanjun.schedules.IntervalSchedule.interval","title":"interval  <code>property</code>","text":"<pre><code>interval: datetime.timedelta\n</code></pre> <p>The interval between scheduled callback calls.</p>"},{"location":"reference/schedules/#tanjun.schedules.IntervalSchedule.__init__","title":"__init__","text":"<pre><code>__init__(callback, interval, /, *, fatal_exceptions=(), ignored_exceptions=(), max_runs=None)\n</code></pre> <p>Initialise an interval schedule.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback for the schedule.</p> <p>This should be an asynchronous function which takes no positional arguments, returns None and may use dependency injection.</p> <p> TYPE: <code>collections.abc.Callable[..., collections.abc.Coroutine[Any, Any, None]]</code> </p> <code>interval</code> <p>The interval between calls. Passed as a timedelta, or a number of seconds.</p> <p> TYPE: <code>typing.Union[datetime.timedelta, int, float]</code> </p> <code>fatal_exceptions</code> <p>A sequence of exceptions that will cause the schedule to stop if raised by the callback, start callback or stop callback.</p> <p> TYPE: <code>collections.Sequence[type[Exception]]</code> DEFAULT: <code>()</code> </p> <code>ignored_exceptions</code> <p>A sequence of exceptions that should be ignored if raised by the callback, start callback or stop callback.</p> <p> TYPE: <code>collections.Sequence[type[Exception]]</code> DEFAULT: <code>()</code> </p> <code>max_runs</code> <p>The maximum amount of times the schedule runs.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/schedules/#tanjun.schedules.IntervalSchedule.set_fatal_exceptions","title":"set_fatal_exceptions","text":"<pre><code>set_fatal_exceptions(*exceptions)\n</code></pre> <p>Set the exceptions that will stop a schedule.</p> <p>If any of these exceptions are encountered, the task will stop.</p> PARAMETER DESCRIPTION <code>*exceptions</code> <p>Types of the exceptions to stop the task on.</p> <p> TYPE: <code>type[Exception]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The schedule object to enable chianed calls.</p>"},{"location":"reference/schedules/#tanjun.schedules.IntervalSchedule.set_ignored_exceptions","title":"set_ignored_exceptions","text":"<pre><code>set_ignored_exceptions(*exceptions)\n</code></pre> <p>Set the exceptions that a schedule will ignore.</p> <p>If any of these exceptions are encountered, there will be nothing printed to console.</p> PARAMETER DESCRIPTION <code>*exceptions</code> <p>Types of the exceptions to ignore.</p> <p> TYPE: <code>type[Exception]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The schedule object to enable chained calls.</p>"},{"location":"reference/schedules/#tanjun.schedules.IntervalSchedule.set_start_callback","title":"set_start_callback","text":"<pre><code>set_start_callback(callback)\n</code></pre> <p>Set the callback executed before the schedule starts to run.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to set.</p> <p> TYPE: <code>_CallbackSig</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The schedule instance to enable chained calls.</p>"},{"location":"reference/schedules/#tanjun.schedules.IntervalSchedule.set_stop_callback","title":"set_stop_callback","text":"<pre><code>set_stop_callback(callback)\n</code></pre> <p>Set the callback executed after the schedule is finished.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to set.</p> <p> TYPE: <code>_CallbackSig</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The schedule instance to enable chained calls.</p>"},{"location":"reference/schedules/#tanjun.schedules.IntervalSchedule.with_start_callback","title":"with_start_callback","text":"<pre><code>with_start_callback(callback)\n</code></pre> <p>Set the callback executed before the schedule is finished/stopped.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to set.</p> <p> TYPE: <code>collections.abc.Callable[..., collections.abc.Coroutine[Any, Any, None]]</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[..., collections.abc.Coroutine[Any, Any, None]]</code> <p>The added callback.</p> <p>Examples:</p> <pre><code>@component.with_schedule()\n@tanjun.as_interval(1, max_runs=20)\nasync def interval():\n    global counter\n    counter += 1\n    print(f\"Run #{counter}\")\n\n@interval.with_start_callback\nasync def pre():\n    print(\"pre callback\")\n</code></pre>"},{"location":"reference/schedules/#tanjun.schedules.IntervalSchedule.with_stop_callback","title":"with_stop_callback","text":"<pre><code>with_stop_callback(callback)\n</code></pre> <p>Set the callback executed after the schedule is finished.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to set.</p> <p> TYPE: <code>collections.abc.Callable[..., collections.abc.Coroutine[Any, Any, None]]</code> </p> RETURNS DESCRIPTION <code>collections.abc.Callable[..., collections.abc.Coroutine[Any, Any, None]]</code> <p>The added callback.</p> <p>Examples:</p> <pre><code>@component.with_schedule()\n@tanjun.as_interval(1, max_runs=20)\nasync def interval():\n    global counter\n    counter += 1\n    print(f\"Run #{counter}\")\n\n\n@interval.with_stop_callback\nasync def post():\n    print(\"pre callback\")\n</code></pre>"},{"location":"reference/schedules/#tanjun.schedules.TimeSchedule","title":"TimeSchedule","text":"<p>         Bases: <code>typing.Generic[_CallbackSigT]</code>, <code>components.AbstractComponentLoader</code>, <code>AbstractSchedule</code></p> <p>A schedule that runs at specific times.</p> <p>This should be loaded into a component using either Component.load_from_scope, Component.add_schedule or Component.with_schedule and will be started and stopped with the linked tanjun client.</p>"},{"location":"reference/schedules/#tanjun.schedules.TimeSchedule.__init__","title":"__init__","text":"<pre><code>__init__(callback, /, *, months=(), weekly=False, days=(), hours=(), minutes=(), seconds=0, fatal_exceptions=(), ignored_exceptions=(), timezone=None)\n</code></pre> <p>Initialise the time schedule.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback for the schedule.</p> <p>This should be an asynchronous function which takes no positional arguments, returns None and may use dependency injection.</p> <p> TYPE: <code>collections.abc.Callable[..., collections.abc.Coroutine[Any, Any, None]]</code> </p> <code>months</code> <p>Either one or multiple months the schedule shouldrun on.</p> <p>If this is not specified or an empty sequence then the schedule will run on all months.</p> <p> TYPE: <code>typing.Union[int, collections.Sequence[int]]</code> DEFAULT: <code>()</code> </p> <code>weekly</code> <p>Whether the schedule should run on a weekly basis.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>days</code> <p>Either one or multiple days the schedule should run on.</p> <p>When <code>weekly</code> is True, <code>days</code> will refer to the days of the week (<code>range(7)</code>).</p> <p>Otherwise this will refer to the days of the month (<code>range(32)</code>). For months where less than 31 days exist, numbers which are too large will be ignored.</p> <p>If this is not specified or an empty sequence, then the schedule will run on all days.</p> <p> TYPE: <code>typing.Union[int, collections.Sequence[int]]</code> DEFAULT: <code>()</code> </p> <code>hours</code> <p>Either one or multiple hours the schedule should run on.</p> <p>If this is not specified or an empty sequence then the schedule will run on all hours.</p> <p> TYPE: <code>typing.Union[int, collections.Sequence[int]]</code> DEFAULT: <code>()</code> </p> <code>minutes</code> <p>Either one or multiple minutes the schedule should run on.</p> <p>If this is not specified or an empty sequence then the schedule will run on all minutes.</p> <p> TYPE: <code>typing.Union[int, collections.Sequence[int]]</code> DEFAULT: <code>()</code> </p> <code>seconds</code> <p>Either one or multiple seconds the schedule should run on.</p> <p>Defaults to the start of the minute if not specified or an empty sequence.</p> <p> TYPE: <code>typing.Union[int, collections.Sequence[int]]</code> DEFAULT: <code>0</code> </p> <code>fatal_exceptions</code> <p>A sequence of exceptions that will cause the schedule to stop if raised by the callback, start callback or stop callback.</p> <p> TYPE: <code>collections.Sequence[type[Exception]]</code> DEFAULT: <code>()</code> </p> <code>ignored_exceptions</code> <p>A sequence of exceptions that should be ignored if raised by the callback, start callback or stop callback.</p> <p> TYPE: <code>collections.Sequence[type[Exception]]</code> DEFAULT: <code>()</code> </p> <code>timezone</code> <p>The timezone to use for the schedule.</p> <p>If this is not specified then the system's local timezone will be used.</p> <p> TYPE: <code>typing.Optional[datetime.timezone]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If months has any values outside the range of <code>range(1, 13)</code>.</li> <li>If days has any values outside the range of <code>range(1, 32)</code> when <code>weekly</code> is False or outside the range of <code>range(1, 8)</code> when <code>weekly</code> is True.</li> <li>If hours has any values outside the range of <code>range(0, 24)</code>.</li> <li>If minutes has any values outside the range of <code>range(0, 60)</code>.</li> <li>If seconds has any values outside the range of <code>range(0, 60)</code>.</li> </ul>"},{"location":"reference/schedules/#tanjun.schedules.TimeSchedule.set_fatal_exceptions","title":"set_fatal_exceptions","text":"<pre><code>set_fatal_exceptions(*exceptions)\n</code></pre> <p>Set the exceptions that will stop a schedule.</p> <p>If any of these exceptions are encountered, the task will stop.</p> PARAMETER DESCRIPTION <code>*exceptions</code> <p>Types of the exceptions to stop the task on.</p> <p> TYPE: <code>type[Exception]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The schedule object to enable chianed calls.</p>"},{"location":"reference/schedules/#tanjun.schedules.TimeSchedule.set_ignored_exceptions","title":"set_ignored_exceptions","text":"<pre><code>set_ignored_exceptions(*exceptions)\n</code></pre> <p>Set the exceptions that a schedule will ignore.</p> <p>If any of these exceptions are encountered, there will be nothing printed to console.</p> PARAMETER DESCRIPTION <code>*exceptions</code> <p>Types of the exceptions to ignore.</p> <p> TYPE: <code>type[Exception]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The schedule object to enable chained calls.</p>"},{"location":"reference/schedules/#tanjun.schedules.as_interval","title":"as_interval","text":"<pre><code>as_interval(interval, /, *, fatal_exceptions=(), ignored_exceptions=(), max_runs=None)\n</code></pre> <p>Decorator to create an schedule.</p> <p>Examples:</p> <pre><code>@component.with_schedule\n@tanjun.as_interval(datetime.timedelta(minutes=5))  # This will run every 5 minutes\nasync def interval(client: alluka.Injected[tanjun.abc.Client]) -&gt; None:\n    ...\n</code></pre> <p>This should be loaded into a component using either Component.with_schedule or Component.load_from_scope, and will be started and stopped with the linked tanjun client.</p> PARAMETER DESCRIPTION <code>interval</code> <p>The interval between calls. Passed as a timedelta, or a number of seconds.</p> <p> TYPE: <code>typing.Union[int, float, datetime.timedelta]</code> </p> <code>fatal_exceptions</code> <p>A sequence of exceptions that will cause the schedule to stop if raised by the callback, start callback or stop callback.</p> <p> TYPE: <code>collections.Sequence[type[Exception]]</code> DEFAULT: <code>()</code> </p> <code>ignored_exceptions</code> <p>A sequence of exceptions that should be ignored if raised by the callback, start callback or stop callback.</p> <p> TYPE: <code>collections.Sequence[type[Exception]]</code> DEFAULT: <code>()</code> </p> <code>max_runs</code> <p>The maximum amount of times the schedule runs.</p> <p> TYPE: <code>typing.Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>collections.Callable[[_CallbackSigT], tanjun.schedules.IntervalSchedule[_CallbackSigT]]</code> <p>The decorator used to create the schedule.</p> <p>This should be decorating an asynchronous function which takes no positional arguments, returns None and may use dependency injection.</p>"},{"location":"reference/schedules/#tanjun.schedules.as_time_schedule","title":"as_time_schedule","text":"<pre><code>as_time_schedule(*, months=(), weekly=False, days=(), hours=(), minutes=(), seconds=0, fatal_exceptions=(), ignored_exceptions=(), timezone=None)\n</code></pre> <p>Create a time schedule through a decorator call.</p> <p>Examples:</p> <pre><code>@component.with_schedule\n@tanjun.as_time_schedule(  # This will run every week day at 8:00 and 16:00 UTC.\n    minutes=0, hours=[8, 16], days=range(0, 5), weekly=True, timezone=datetime.timezone.utc\n)\nasync def interval(client: alluka.Injected[tanjun.abc.Client]) -&gt; None:\n    ...\n</code></pre> <p>This should be loaded into a component using either Component.with_schedule or Component.load_from_scope, and will be started and stopped with the linked tanjun client.</p> PARAMETER DESCRIPTION <code>months</code> <p>Either one or multiple months the schedule should run on.</p> <p>If this is not specified or an empty sequence then the schedule will run on all months.</p> <p> TYPE: <code>typing.Union[int, collections.Sequence[int]]</code> DEFAULT: <code>()</code> </p> <code>weekly</code> <p>Whether the schedule should run on a weekly basis.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>days</code> <p>Either one or multiple days the schedule should run on.</p> <p>When <code>weekly</code> is True, <code>days</code> will refer to the days of the week (<code>range(7)</code>).</p> <p>Otherwise this will refer to the days of the month (<code>range(32)</code>). For months where less than 31 days exist, numbers which are too large will be ignored.</p> <p>If this is not specified or an empty sequence, then the schedule will run on all days.</p> <p> TYPE: <code>typing.Union[int, collections.Sequence[int]]</code> DEFAULT: <code>()</code> </p> <code>hours</code> <p>Either one or multiple hours the schedule should run on.</p> <p>If this is not specified or an empty sequence then the schedule will run on all hours.</p> <p> TYPE: <code>typing.Union[int, collections.Sequence[int]]</code> DEFAULT: <code>()</code> </p> <code>minutes</code> <p>Either one or multiple minutes the schedule should run on.</p> <p>If this is not specified or an empty sequence then the schedule will run on all minutes.</p> <p> TYPE: <code>typing.Union[int, collections.Sequence[int]]</code> DEFAULT: <code>()</code> </p> <code>seconds</code> <p>Either one or multiple seconds the schedule should run on.</p> <p>Defaults to the start of the minute if not specified or an empty sequence.</p> <p> TYPE: <code>typing.Union[int, collections.Sequence[int]]</code> DEFAULT: <code>0</code> </p> <code>fatal_exceptions</code> <p>A sequence of exceptions that will cause the schedule to stop if raised by the callback, start callback or stop callback.</p> <p> TYPE: <code>collections.Sequence[type[Exception]]</code> DEFAULT: <code>()</code> </p> <code>ignored_exceptions</code> <p>A sequence of exceptions that should be ignored if raised by the callback, start callback or stop callback.</p> <p> TYPE: <code>collections.Sequence[type[Exception]]</code> DEFAULT: <code>()</code> </p> <code>timezone</code> <p>The timezone to use for the schedule.</p> <p>If this is not specified then the system's local timezone will be used.</p> <p> TYPE: <code>typing.Optional[datetime.timezone]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>collections.Callable[[_CallbackSigT], tanjun.schedules.TimeSchedule[_CallbackSigT]]</code> <p>The decorator used to create the schedule.</p> <p>This should be decorating an asynchronous function which takes no positional arguments, returns None and may use dependency injection.</p> RAISES DESCRIPTION <code>ValueError</code> <p>Raises a value error for any of the following reasons:</p> <ul> <li>If months has any values outside the range of <code>range(1, 13)</code>.</li> <li>If days has any values outside the range of <code>range(1, 32)</code> when <code>weekly</code> is False or outside the range of <code>range(1, 7)</code> when <code>weekly</code> is True.</li> <li>If hours has any values outside the range of <code>range(0, 24)</code>.</li> <li>If minutes has any values outside the range of <code>range(0, 60)</code>.</li> <li>If seconds has any values outside the range of <code>range(0, 60)</code>.</li> </ul>"},{"location":"reference/utilities/","title":"tanjun.utilities","text":"<p><code>tanjun.utilities</code> has been deprecated in favour of tanjun.permissions.</p>"}]}